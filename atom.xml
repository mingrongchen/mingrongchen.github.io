<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MingRong&#39;s Boat</title>
  
  <subtitle>O Captain! My Captain!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-20T09:43:30.923Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>MingRongChen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java八大排序算法</title>
    <link href="http://yoursite.com/2021/02/20/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/02/20/Java数据结构与算法/Java八大排序算法/</id>
    <published>2021-02-20T09:41:53.000Z</published>
    <updated>2021-02-20T09:43:30.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java八大排序算法"><a href="#Java八大排序算法" class="headerlink" title="Java八大排序算法"></a>Java八大排序算法</h1><a id="more"></a><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>八大排序算法：直接插入排序（Insertion Sort）、希尔排序（Shell Sort）、选择排序（Selection Sort）、堆排序（Heap Sort）、冒泡排序（Bubble Sort）、快速排序（Quick Sort）、归并排序（Merging Sort）、基数排序（Radix Sort），基数排序也称桶排序。</p><p>都属于内部排序算法，其中直接插入排序和希尔排序属于<strong>插入排序</strong>，简单选择排序和堆排序属于<strong>选择排序</strong>，冒泡排序和快速排序属于<strong>交换排序</strong>。</p><h2 id="直接插入排序算法"><a href="#直接插入排序算法" class="headerlink" title="直接插入排序算法"></a>直接插入排序算法</h2><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。插入排序非常类似于整扑克牌。在开始摸牌时，左手是空的，牌面朝下放在桌上。接着，一次从桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将它与手中已有的牌从右到左地进行比较。无论什么时候，左手中的牌都是排好序的。<br>如果输入数组已经是排好序的话，插入排序出现最佳情况，其运行时间是输入规模的一个线性函数。如果输入数组是逆序排列的，将出现最坏情况。平均情况与最坏情况一样，其时间代价是(n2)。</p><p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。</p><p>通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了要给插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><p>1、从第一个元素开始，该元素可以认为已经被排序。</p><p>2、取出下一个元素，在已经排序的元素序列中从后向前扫描。</p><p>3、如果该元素（已排序）大于新元素，将该元素移到下一位置。</p><p>4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。</p><p>5、将新元素插入到该位置后。</p><p>6、重复步骤2~5。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过将较大的元素都向右移动而不总是交换两个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 装载临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">temp = data[i];</span><br><span class="line"><span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果前一位比当前数据要大，那么进入循环比较</span></span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; data[j] &gt; temp; j--) &#123;</span><br><span class="line"><span class="comment">// 往后退一个位置，让当前数据与之前前位进行比较</span></span><br><span class="line">data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出内层循环，则说明找到了合适的位置，并将当前数据插入合适的位置中</span></span><br><span class="line">data[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过交换进行插入排序，借鉴冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 装载临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"><span class="comment">// 如果前一位比当前数据要大，那么进入循环比较，并两两交换，参考冒泡排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; data[j] &gt; data[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">temp = data[j + <span class="number">1</span>];</span><br><span class="line">data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sortTwo end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>插入排序所需的时间取决于输入元素的初始顺序。例如，对一个很大且其中的元素已经有序(或接近有序)的数组进行排序将会比随机顺序的数组或是逆序数组进行排序要快得多。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell 于1959 年提出而得名。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。<br>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是初次取数组长度的一半为增量，之后每次再减半，直到增量为1。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>1、选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1。</p><p>2、按增量序列个数 k，对序列进行 k 趟排序。</p><p>3、每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><p>引用自网上一张图（侵删）：</p><p><img src="/2021/02/20/Java数据结构与算法/Java八大排序算法/image-20210220134535850.png" alt="image-20210220134535850"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">// 增量每次都/2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> step = data.length / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 从增量那组开始进行插入排序，直至完毕</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; data.length; i++) &#123;</span><br><span class="line">temp = data[i];</span><br><span class="line"><span class="keyword">int</span> j = i - step;</span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; data[j] &gt; temp; j -= step) &#123;</span><br><span class="line"><span class="comment">// 往后退一个step位置，让当前数据与之前前位进行比较</span></span><br><span class="line">data[j + step] = data[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出内层循环，则说明找到了合适的位置，并将当前数据插入合适的位置中</span></span><br><span class="line">data[j + step] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td></tr></tbody></table><p>希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始(末尾)位置，直到全部待排序的数据元素排完。选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5 挪动到第二个5 后面）。</p><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n个元素的表进行排序总共进行至多 n-1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><h3 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h3><p>1、从未排序序列中，找到关键字最小的元素。</p><p>2、如果最小元素不是未排序序列的第一个元素，将其和未排序序列第一个元素互换。</p><p>3、重复1、2步，直到排序结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 记录当前趟数的最小值的角标</span></span><br><span class="line"><span class="keyword">int</span> minPos;</span><br><span class="line"><span class="comment">// 交换的变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"><span class="comment">// 新的趟数的起点</span></span><br><span class="line">minPos = i;</span><br><span class="line"><span class="comment">// 选出之后排序中值最小的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; data.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (data[j] &lt; data[i]) &#123;</span><br><span class="line">minPos = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最小值不等于当前值时进行交换</span></span><br><span class="line"><span class="keyword">if</span> (minPos != i) &#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">data[i] = data[minPos];</span><br><span class="line">data[minPos] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。</p><h3 id="算法描述：-1"><a href="#算法描述：-1" class="headerlink" title="算法描述："></a>算法描述：</h3><p>描述一：</p><p>1、i从0开始，i与i+1比较，如果后面的数（i+1）小于前面的数（i），则交换。<br>2、i不断增加，直到i&lt;n-1（数组长度减一），一趟下来，可以让数组元素中的最大值排在数组的最后，直到完成。</p><p>描述二：</p><p>1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><p>3、针对所有的元素重复以上的步骤，除了最后一个。</p><p>4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试用，记录执行了多少趟</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 装载临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">// 外层是排序的趟数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 内层循环是当前趟数需要比较的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="comment">// 前一位与后一位相比较，如果前一位比后一位要大，则交换</span></span><br><span class="line"><span class="keyword">if</span> (data[j + <span class="number">1</span>] &lt; data[j]) &#123;</span><br><span class="line">temp = data[j + <span class="number">1</span>];</span><br><span class="line">data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"Sort run frequency is : "</span> + num);</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p><h3 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h3><p>如果数据足够乱的情况下，例如反序，需要数据长度-1趟才能将数据完整排好序。</p><p>但是在部分有序情况下，例如在第3趟比较后就已经得到了排好序的数组，就没有必要执行后面的计算了。我们可以做如下优化：</p><ul><li>如果在某趟排序中没有发生交换位置，那么我们可以认为该数组已经排好顺序了。（我们每趟排序的目的就是为了将当前趟最大的数置换到对应的位置上，如果没有发生置换说明已经是排好序的了）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">betterSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试用，记录执行了多少趟</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 装载临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">// 记录是否发生了置换，0代表没有发生置换，1代表发生了置换</span></span><br><span class="line"><span class="keyword">int</span> isChange;</span><br><span class="line"><span class="comment">// 外层是排序的趟数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 每比较一趟就重新初始化为0</span></span><br><span class="line">isChange = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 内层循环是当前趟数需要比较的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="comment">// 前一位与后一位相比较，如果前一位比后一位要大，则交换</span></span><br><span class="line"><span class="keyword">if</span> (data[j + <span class="number">1</span>] &lt; data[j]) &#123;</span><br><span class="line">temp = data[j + <span class="number">1</span>];</span><br><span class="line">data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果进到这里面了，说明发生了置换</span></span><br><span class="line">isChange = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果比较完一趟没有发生置换，那么说明已经排好序了，不需要再执行下去了</span></span><br><span class="line"><span class="keyword">if</span> (isChange == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"betterSort run frequency is : "</span> + num);</span><br><span class="line">&#125; <span class="comment">// better sort end</span></span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序由C. A. R. Hoare 在1962 年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>一次循环：从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。找到这个值之后，又从前往后开始比较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的值才交换。直到从前往后的比较索引&gt;从后往前比较的索引，结束第一次循环，此时，对于基准值来说，左右两边就是有序的了。</p><h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好。</p><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists），算法步骤：</p><p>1、从数列中挑出一个元素，称为”基准”（pivot）。</p><p>2、重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p><p>3、递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"sort start, L : "</span> + L + <span class="string">" ,R : "</span> + R);</span><br><span class="line"><span class="keyword">int</span> i = L;</span><br><span class="line"><span class="keyword">int</span> j = R;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换的变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">// 支点</span></span><br><span class="line"><span class="keyword">int</span> pivot = data[L + (R - L) / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左右两端进行扫描，只要两端没有交替，就一直扫描</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line"><span class="comment">// 左边寻找直到比支点大的数</span></span><br><span class="line"><span class="keyword">while</span> (pivot &gt; data[i]) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边寻找直到比支点小的数</span></span><br><span class="line"><span class="keyword">while</span> (pivot &lt; data[j]) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时已经分别找到了比支点小的数（右边）、比支点大的数（左边），它们进行交换</span></span><br><span class="line"><span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">data[i] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line"><span class="comment">// 左边右移一位</span></span><br><span class="line">i++;</span><br><span class="line"><span class="comment">// 右边左移一位</span></span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面一个while保证了第一趟排序支点的左边比支点小，支点的右边比支点大了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左边再做排序，直到左边剩下一个数（递归出口）</span></span><br><span class="line"><span class="keyword">if</span> (L &lt; j) &#123;</span><br><span class="line">System.out.println(<span class="string">"sort left before, L : "</span> + L + <span class="string">" ,j : "</span> + j);</span><br><span class="line">sort(data, L, j);</span><br><span class="line">System.out.println(<span class="string">"sort left end, L : "</span> + L + <span class="string">" ,j : "</span> + j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右边再做排序，直到右边剩下一个数（递归出口）</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; R) &#123;</span><br><span class="line">System.out.println(<span class="string">"sort right before, i : "</span> + i + <span class="string">" ,R : "</span> + R);</span><br><span class="line">sort(data, i, R);</span><br><span class="line">System.out.println(<span class="string">"sort right end, i : "</span> + i + <span class="string">" ,R : "</span> + R);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用<strong>分治法（Divide and Conquer）</strong>的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>归并排序可通过两种方式实现:</p><ul><li>自上而下的递归</li><li>自下而上的迭代</li></ul><p>递归法（假设序列共有n个元素）：</p><p>1、将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</p><p>2、将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</p><p>3、重复步骤2，直到所有元素排序完毕。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>迭代法归并操作的工作原理如下：</p><p>1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。</p><p>2、设定两个指针，最初位置分别为两个已经排序序列的起始位置。</p><p>3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。</p><p>4、重复步骤3 直到某一指针超出序列尾。</p><p>5、将另一序列剩下的所有元素直接复制到合并序列尾。</p><p>归并排序其实要做两件事：</p><ul><li>分解：将序列每次折半拆分</li><li>合并：将划分后的序列段两两排序合并</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果只有一个元素，那就不用排序了</span></span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 取中间的数，进行拆分</span></span><br><span class="line"><span class="keyword">int</span> M = L + (R - L) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"sort left before, L : "</span> + L + <span class="string">" ,M : "</span> + M);</span><br><span class="line"><span class="comment">// 左边的数不断进行拆分</span></span><br><span class="line">sort(data, L, M);</span><br><span class="line">System.out.println(<span class="string">"sort left end, L : "</span> + L + <span class="string">" ,M : "</span> + M);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"sort right before, M+1 : "</span> + (M + <span class="number">1</span>) + <span class="string">" ,R : "</span> + R);</span><br><span class="line"><span class="comment">// 右边的数不断进行拆分</span></span><br><span class="line">sort(data, M + <span class="number">1</span>, R);</span><br><span class="line">System.out.println(<span class="string">"sort right end, M+1 : "</span> + (M + <span class="number">1</span>) + <span class="string">" ,R : "</span> + R);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"merge before, L: "</span> + L + <span class="string">", M+1 : "</span> + (M + <span class="number">1</span>) + <span class="string">" ,R : "</span> + R);</span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">merge(data, L, M + <span class="number">1</span>, R);</span><br><span class="line">System.out.println(<span class="string">"merge end, L: "</span> + L + <span class="string">", M+1 : "</span> + (M + <span class="number">1</span>) + <span class="string">" ,R : "</span> + R);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 左边数组的大小</span></span><br><span class="line"><span class="keyword">int</span>[] leftData = <span class="keyword">new</span> <span class="keyword">int</span>[M - L];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边数组的大小</span></span><br><span class="line"><span class="keyword">int</span>[] rightData = <span class="keyword">new</span> <span class="keyword">int</span>[R - M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往这两个数组填充数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; M; i++) &#123;</span><br><span class="line">leftData[i - L] = data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt;= R; i++) &#123;</span><br><span class="line">rightData[i - M] = data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// data数组的第一个元素</span></span><br><span class="line"><span class="keyword">int</span> k = L;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个数组的值，哪个小，就往数组上放</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; leftData.length &amp;&amp; j &lt; rightData.length) &#123;</span><br><span class="line"><span class="comment">// 谁比较小，谁将元素放入大数组中，移动指针，继续比较下一个</span></span><br><span class="line"><span class="keyword">if</span> (leftData[i] &lt; rightData[j]) &#123;</span><br><span class="line">data[k] = leftData[i];</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">data[k] = rightData[j];</span><br><span class="line"></span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果左边数组没有比较完，右边数组已经完了，那么将左边数组复制到大数组中（剩下的都是大数字）</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; leftData.length) &#123;</span><br><span class="line">data[k] = leftData[i];</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果右边数组没有比较完，左边数组已经完了，那么将右边数组复制到大数组中（剩下的都是大数字）</span></span><br><span class="line"><span class="keyword">while</span> (j &lt; rightData.length) &#123;</span><br><span class="line">data[k] = rightData[j];</span><br><span class="line"></span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// merge end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(1)</td></tr></tbody></table><p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p><p>归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比，它的主要缺点则是他所需的额外空间和N成正比。</p><h2 id="基数排序（桶排序）"><a href="#基数排序（桶排序）" class="headerlink" title="基数排序（桶排序）"></a>基数排序（桶排序）</h2><p>基数排序(radix sort)属于”分配式排序”(distribution sort)，又称”桶子法”(bucket sort)或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些”桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r 为所采取的基数，而m 为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。基数排序不同与其他的7种排序，其他7 种排序本质上都是按照交换或者比较来进行排序，但是基数排序并不是，它是按照分配，回收(分配到不同的位置上，然后回收)..不断分配..回收来进行排序，直到有序。</p><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p><p><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</p><p><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</p><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>基数排序按照优先从高位或低位来排序有两种实现方案：</p><ul><li><p>MSD（Most significant digital） 从最左侧高位开始进行排序。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。MSD方式适用于位数多的序列。</p></li><li><p>LSD （Least significant digital）从最右侧低位开始进行排序。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。LSD方式适用于位数少的序列。</p></li></ul><p>以LSD为例，从最低位开始，算法步骤：</p><p>1、取得数组中的最大数，并取得位数；</p><p>2、arr为原始数组，从最低位开始取每个位组成radix数组；</p><p>3、对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (data.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得数组中最大的数，并取得位数</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; data[i]) &#123;</span><br><span class="line">max = data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 位数计算</span></span><br><span class="line"><span class="keyword">int</span> maxDigit = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (max / <span class="number">10</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">maxDigit++;</span><br><span class="line">max = max / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请一个桶空间，二维数组</span></span><br><span class="line"><span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][data.length];</span><br><span class="line"><span class="keyword">int</span> base = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从低位到高位，对每一位遍历，将所有元素分配到桶中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++) &#123;</span><br><span class="line"><span class="comment">// 存储各个桶中存储元素的数量</span></span><br><span class="line"><span class="keyword">int</span>[] bktLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配，将所有元素分配到桶中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> whichBucket = (data[j] % base) / (base / <span class="number">10</span>);</span><br><span class="line">buckets[whichBucket][bktLen[whichBucket]] = data[j];</span><br><span class="line">bktLen[whichBucket]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集，将不同桶里的数据挨个捞出来，为下一轮高位排序做准备，由于靠近桶底的元素排名靠前，因此从桶底先捞</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; buckets.length; b++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; bktLen[b]; p++) &#123;</span><br><span class="line">data[k++] = buckets[b][p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">base *= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(d*(n + r))</td><td>O(d*(n + r))</td><td>O(d*(n + r))</td><td>O(n+r)</td></tr></tbody></table><p>其中，d 为位数，r 为基数，n 为原数组个数。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d*(n + r))。</p><p>备注：</p><p>基数排序更适合用于对时间, 字符串等这些 整体权值未知的数据 进行排序。</p><p>基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p>基数排序 vs 计数排序 vs 桶排序</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><p>1、基数排序：根据键值的每位数字来分配桶</p><p>2、计数排序：每个桶只存储单一键值</p><p>3、桶排序：每个桶存储一定范围的数值</p><h2 id="八大排序算法总结"><a href="#八大排序算法总结" class="headerlink" title="八大排序算法总结"></a>八大排序算法总结</h2><p>从时间复杂度来说：</p><p>1、平方阶O(n²)排序：<strong>各类简单排序：直接插入、直接选择和冒泡排序</strong></p><p>2、线性对数阶O(nlog₂n)排序：<strong>快速排序、堆排序和归并排序</strong></p><p>3、O(n1+§))排序，§是介于0和1之间的常数：<strong>希尔排序</strong></p><p>4、线性阶O(n)排序：<strong>基数排序，此外还有桶、箱排序</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java八大排序算法&quot;&gt;&lt;a href=&quot;#Java八大排序算法&quot; class=&quot;headerlink&quot; title=&quot;Java八大排序算法&quot;&gt;&lt;/a&gt;Java八大排序算法&lt;/h1&gt;
    
    </summary>
    
      <category term="Java数据结构与算法" scheme="http://yoursite.com/categories/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java数据结构与算法概览</title>
    <link href="http://yoursite.com/2021/02/19/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2021/02/19/Java数据结构与算法/Java数据结构与算法概览/</id>
    <published>2021-02-19T08:04:53.000Z</published>
    <updated>2021-02-19T08:08:29.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java数据结构与算法概览"><a href="#Java数据结构与算法概览" class="headerlink" title="Java数据结构与算法概览"></a>Java数据结构与算法概览</h1><a id="more"></a><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>1、数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。</p><p>2、数据元素之间的相互关系包括：数据的逻辑结构、数据的存储结构、数据的运算结构。</p><p>3、数据结构的设计过程分为：抽象层、数据结构层、实现层。</p><h3 id="逻辑结构分类"><a href="#逻辑结构分类" class="headerlink" title="逻辑结构分类"></a>逻辑结构分类</h3><p>线性数据结构：数组，线性表，栈，队列，串等。</p><p>非线性数据结构：多维数组，集合，树，图，散列表(hash)。</p><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>定义：树形结构，作者觉得它是一种特殊的链形数据结构。最少有一个根节点组成，可以有多个子节点。树，显然是由递归算法组成。</p><p>种类：</p><p>（1）二叉树：每个节点最多含有两个子节点的树称为二叉树。</p><ul><li>1）一般二叉树：无限制，每个子节点的父亲节点不一定有两个子节点的二叉树成为一般二叉树。</li><li>2）完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</li><li>3）满二叉树：所有的节点都是二叉的二叉树成为满二叉树。</li></ul><p>（2）二叉搜索树/BST：二叉排序树、二叉查找树。是有序的。要点：如果不为空，那么其左子树节点的值都小于根节点的值；右子树节点的值都大于根节点的值。</p><ul><li>1）二叉平衡树：二叉搜索树，是有序的排序树，但左右两边包括子节点不一定平衡，而二叉平衡树是排序树的一种，并且加点条件，就是任意一个节点的两个叉的深度差不多（比如差值的绝对值小于某个常数，或者一个不能比另一个深出去一倍之类的）。这样的树可以保证二分搜索任意元素都是O(log n)的，一般还附带带有插入或者删除某个元素也是O(log n)的的性质。</li><li>2）AVL树：最早的平衡二叉树之一。windows对进程地址空间的管理用到了AVL树。</li><li>3）红黑树：通过制定了一些红黑标记和左右旋转规则来保证二叉树平衡。</li></ul><p>（3）B树/B-tree：又叫平衡(balance)多路查找树。树中每个结点最多含有m个孩子（m&gt;=2）。它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。</p><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系，通常记为，G=(V,E)。</p><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><p>分为无向图和有向图。</p><p>无向图G1：</p><p><img src="/2021/02/19/Java数据结构与算法/Java数据结构与算法概览/image-20210210105538609.png" alt="image-20210210105538609"></p><p>上面的图是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V1,{E1})。其中，</p><p>（1）V1={A,C,B,F,D,E}。 V2表示由”A,B,C,D,E,F”几个顶点组成的集合。</p><p>（2）E1={&lt;A,B&gt;,&lt;A,C&gt;,&lt;A,D&gt;,&lt;C,D&gt;,&lt;C,E&gt;,&lt;C,F&gt;,&lt;D,C&gt;,&lt;E,D&gt;}。 E1是由矢量&lt;A,B&gt;,矢量&lt;A,C&gt;…等等组成的集合。其中，矢量&lt;A,B)表示由”顶点A”指向”顶点B”的有向边。</p><p>无向图G2：</p><p><img src="/2021/02/19/Java数据结构与算法/Java数据结构与算法概览/image-20210210105554780.png" alt="image-20210210105554780"></p><p>上面的图是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中，</p><p>（1）V1={A,B,C,D,E,F}。 V1表示由”A,B,C,D,E,F”几个顶点组成的集合。</p><p>（2）E1={(A,C),(A,D),(B,C),(D,E),(E,F)}。 E1是由边(A,C),边(A,D)…等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。</p><h5 id="邻接点"><a href="#邻接点" class="headerlink" title="邻接点"></a>邻接点</h5><p>一条边上的两个顶点叫做邻接点。<br>例如，上面无向图中的顶点A和顶点C就是邻接点。<br>在有向图中，除了邻接点之外；还有”入边”和”出边”的概念。<br>顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。<br>例如，上面有向图中的A和C是邻接点；&lt;A,C&gt;是A的出边，还是C的入边。</p><h5 id="度"><a href="#度" class="headerlink" title="度"></a>度</h5><p>在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。<br>例如，上面无向图G2中顶点A的度是2。<br>在有向图中，度还有”入度”和”出度”之分。<br>某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。<br>顶点的度=入度+出度。<br>例如，上面有向图G1中，顶点C的入度是2，出度是3；顶点B的度=2+3=5。</p><h5 id="路径和回路"><a href="#路径和回路" class="headerlink" title="路径和回路"></a>路径和回路</h5><p>路径：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。<br>路径长度：路径中”边的数量”。<br>简单路径：若一条路径上顶点不重复出现，则是简单路径。<br>回路：若路径的第一个顶点和最后一个顶点相同，则是回路。<br>简单回路：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。</p><h5 id="连通图和连通分量"><a href="#连通图和连通分量" class="headerlink" title="连通图和连通分量"></a>连通图和连通分量</h5><p>连通图：对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。 对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。<br>连通分量：非连通图中的各个连通子图称为该图的连通分量。</p><h5 id="权"><a href="#权" class="headerlink" title="权"></a>权</h5><p>带权图如下：</p><p><img src="/2021/02/19/Java数据结构与算法/Java数据结构与算法概览/image-20210210110001284.png" alt="image-20210210110001284"></p><h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><p>图的存储结构，常用的是<strong>邻接矩阵</strong>和<strong>邻接表</strong></p><h5 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h5><p>深度优先搜索（DFS）：递归实现；或者定义栈，使用非递归方法。</p><p>广度优先搜索（BFS）：队列实现，自动查找从一个顶点到另一个相邻顶点的最短路径。</p><h5 id="图的算法"><a href="#图的算法" class="headerlink" title="图的算法"></a>图的算法</h5><p>（1）最短路径问题：Dijkstra算法，算法的思路如下，Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。 然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点， 然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。</p><p>（2）拓扑排序：拓扑排序（Topological Sorting）是一个<strong>有向无环图</strong>（DAG, Directed Acyclic Graph）的所有顶点的线性序列。序列必须满足下面两个条件：一个是每个顶点出现且只出现一次，另一个是若存在一条从顶点A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</p><p>计算方法：</p><ul><li>从DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</li><li>从图中删除该顶点和所有以它为起点的有向边。</li><li>重复1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</li></ul><p>（3）最小生成树：</p><ul><li>Kruskal算法：此算法可以称为 “加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。</li><li>Prime算法：此算法可以称为 “加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点 s 开始，逐渐长大覆盖整个连通网的所有顶点。</li></ul><h5 id="现实应用"><a href="#现实应用" class="headerlink" title="现实应用"></a>现实应用</h5><p>（1）交通流量建模：顶点可以表示街道的十字路口，边表示街道。加权的边可以表示限速或者车道的数量。建模人员可以用这个系统来判断最佳路线及最有可能堵车的街道。</p><p>（2）运输系统：比如，航空公司可以用图来为其飞行系统建模。将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。加权的边可以看作从一个机场到另一个机场的航班成本，或两个机场之间的距离，这取决与建模的对象是什么。</p><p>（3）局域网、广域网等计算机网络</p><p>（4）消费市场：顶点可以用来表示供应商和消费者。</p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>定义：</p><p>（1）Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。</p><p>（2）所谓的Hash算法都是散列算法，把任意长度的输入，变换成固定长度的输出，该输出就是散列值.（如：MD5,SHA1,加解密算法等）</p><p>（3）简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><h5 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h5><p>Java中数据存储方式最底层的两种结构，一种是数组，另一种就是链表。而Hash表就是综合了这两种数据结构。</p><p>例如：HashTable,HashMap，哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。</p><h5 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h5><p>Hash很好的解决了单体应用情况下的数据查找和插入的速度问题。但是毕竟单体应用的储存空间是有限的，所有在分布式环境下，应运而生了一致性Hash算法。</p><p>用意和hashCode的用意一样，只不过它是取模放在不同的IP机器上而已。</p><p>一致性Hash需要注意的就是默认分配的桶比较多些，而当其中一台机器挂了，影响的面比较小一些。</p><p>需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。</p><h3 id="评定"><a href="#评定" class="headerlink" title="评定"></a>评定</h3><p>时间复杂度：算法的时间复杂度是指执行算法所需要的计算工作量。简单理解，算法在规模为n的情况下，一个算法语句执行的次数。</p><p>空间复杂度：算法的空间复杂度是指算法需要消耗的内存空间。简单理解，算法在规模为n的情况下额外消耗的存储空间。</p><h3 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h3><p>查找：顺序查找、二分查找、插值查找、</p><p>排序（八大排序算法）：直接插入排序（Insertion Sort）、希尔排序（Shell Sort）、选择排序（Selection Sort）、堆排序（Heap Sort）、冒泡排序（Bubble Sort）、快速排序（Quick Sort）、归并排序（Merging Sort）、基数排序（Radix Sort）</p><p>其它：分治法、贪心算法、动态规划算法、回溯法、分支限界法</p><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>对称加密算法、非对称加密算法、签名</p><p>常见算法：AES、RSA、CRC、MD5</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java数据结构与算法概览&quot;&gt;&lt;a href=&quot;#Java数据结构与算法概览&quot; class=&quot;headerlink&quot; title=&quot;Java数据结构与算法概览&quot;&gt;&lt;/a&gt;Java数据结构与算法概览&lt;/h1&gt;
    
    </summary>
    
      <category term="Java数据结构与算法" scheme="http://yoursite.com/categories/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法概览" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse的环境配置</title>
    <link href="http://yoursite.com/2021/02/09/%E6%9D%82/Eclipse%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2021/02/09/杂/Eclipse的环境配置/</id>
    <published>2021-02-09T12:11:20.000Z</published>
    <updated>2021-02-10T01:12:51.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Eclipse环境配置"><a href="#Eclipse环境配置" class="headerlink" title="Eclipse环境配置"></a>Eclipse环境配置</h1><a id="more"></a><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="1、修改Eclipse默认工作空间编码集，修改成UTF-8"><a href="#1、修改Eclipse默认工作空间编码集，修改成UTF-8" class="headerlink" title="1、修改Eclipse默认工作空间编码集，修改成UTF-8"></a>1、修改Eclipse默认工作空间编码集，修改成UTF-8</h3><p>路径： Window → Preferences →  General →  Workspace，修改编码集为 UTF-8。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209201308485.png" alt="image-20210209201308485"></p><h3 id="2、修改Eclipse的资源文件编码集，修改成UTF-8"><a href="#2、修改Eclipse的资源文件编码集，修改成UTF-8" class="headerlink" title="2、修改Eclipse的资源文件编码集，修改成UTF-8"></a>2、修改Eclipse的资源文件编码集，修改成UTF-8</h3><p>路径：Window → Preferences →  General →  Content Types，并点击打开Content Types：中的Text下面的Java Properties File。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209201547784.png" alt="image-20210209201547784"></p><h3 id="3、自动化格式所有行"><a href="#3、自动化格式所有行" class="headerlink" title="3、自动化格式所有行"></a>3、自动化格式所有行</h3><p>路径：Window → Preferences →  Java→  Editor  →  Save Actions。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209201742842.png" alt="image-20210209201742842"></p><h3 id="4、设置内容自动提示"><a href="#4、设置内容自动提示" class="headerlink" title="4、设置内容自动提示"></a>4、设置内容自动提示</h3><p>路径：Window → Preferences →  Java→  Editor  →  Content Assist。</p><p>在Auto activation triggers for java对应输入框中输入“.qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM”。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209201922362.png" alt="image-20210209201922362"></p><h3 id="5、修改默认浏览器"><a href="#5、修改默认浏览器" class="headerlink" title="5、修改默认浏览器"></a>5、修改默认浏览器</h3><p>路径：Window → Preferences →  General →  Web Browser。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202043441.png" alt="image-20210209202043441"></p><h3 id="6、Eclipse代码模板的构建"><a href="#6、Eclipse代码模板的构建" class="headerlink" title="6、Eclipse代码模板的构建"></a>6、Eclipse代码模板的构建</h3><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径：Window → Preferences →  Java→  Editor  →  Templates。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202209208.png" alt="image-20210209202209208"></p><p>  代码模板构建操作如下图：</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202251247.png" alt="image-20210209202251247"></p><h3 id="7、Eclipse配置类注释模板和方法注释模板"><a href="#7、Eclipse配置类注释模板和方法注释模板" class="headerlink" title="7、Eclipse配置类注释模板和方法注释模板"></a>7、Eclipse配置类注释模板和方法注释模板</h3><p>路径：Window → Preferences →  Java→ Code Style → Code Templates。</p><p>备注：</p><p>1、将光标放到类名上，按下快捷键 alt+shift+j 会添加类的注释。</p><p>2、将光标放到方法名上，按下快捷键 alt+shift+j 会添加方法的注释。</p><p>配置类的注释模板内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @版权 : Copyright (c) 2020-2021 *********公司技术开发部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 作者姓名(一般是写姓名的拼音)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@E</span>-mail: 邮箱</span></span><br><span class="line"><span class="comment"> * @版本: 1.0</span></span><br><span class="line"><span class="comment"> * @创建日期: $&#123;date&#125; $&#123;time&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> $&#123;type_name&#125;</span></span><br><span class="line"><span class="comment"> * @类描述-Description:  $&#123;todo&#125;(这里用一句话描述这个方法的作用)</span></span><br><span class="line"><span class="comment"> * @修改记录:</span></span><br><span class="line"><span class="comment"> * @版本: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>配置方法的注释模板内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: $&#123;enclosing_method&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $&#123;todo&#125;(这里用一句话描述这个方法的作用)</span></span><br><span class="line"><span class="comment"> * $&#123;tags&#125;    參數描述</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> $&#123;return_type&#125;  返回类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>操作如下图：</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202613197.png" alt="image-20210209202613197"></p><p>配置创建类时的注释模板：</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202928859.png" alt="image-20210209202928859"></p><h3 id="8、Eclipse字体大小设置"><a href="#8、Eclipse字体大小设置" class="headerlink" title="8、Eclipse字体大小设置"></a>8、Eclipse字体大小设置</h3><p>路径：Window → Preferences →  General → Appearance → Colors and Fonts。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209203054240.png" alt="image-20210209203054240"></p><h2 id="环境配置保存"><a href="#环境配置保存" class="headerlink" title="环境配置保存"></a>环境配置保存</h2><p>右键点击Package Explorer，点击Export，导出Perferences。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209203629604.png" alt="image-20210209203629604"></p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209203727742.png" alt="image-20210209203727742"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Eclipse环境配置&quot;&gt;&lt;a href=&quot;#Eclipse环境配置&quot; class=&quot;headerlink&quot; title=&quot;Eclipse环境配置&quot;&gt;&lt;/a&gt;Eclipse环境配置&lt;/h1&gt;
    
    </summary>
    
      <category term="杂" scheme="http://yoursite.com/categories/%E6%9D%82/"/>
    
    
      <category term="杂" scheme="http://yoursite.com/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>递归算法</title>
    <link href="http://yoursite.com/2021/02/09/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/02/09/Java数据结构与算法/递归算法/</id>
    <published>2021-02-09T03:26:25.000Z</published>
    <updated>2021-02-09T08:02:00.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><a id="more"></a><h2 id="尾递归的数学理解"><a href="#尾递归的数学理解" class="headerlink" title="尾递归的数学理解"></a>尾递归的数学理解</h2><p>示例：阶乘f(n) = n * f(n-1)</p><p>以计算f(5)为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f(5)</span><br><span class="line">=&gt;5 * f(4)</span><br><span class="line">=&gt;5 * (4 * f(3))</span><br><span class="line">=&gt;5 * (4 * (3 * f(2)))</span><br><span class="line">=&gt;5 * (4 * (3 * (2 * f(1))))</span><br><span class="line">&lt;=5 * (4 * (3 * (2 * 1))) </span><br><span class="line">&lt;=5 * (4 * (3 * 2)) </span><br><span class="line">&lt;=5 * (4 * 6) </span><br><span class="line">&lt;=5 * 24</span><br><span class="line">&lt;=120</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">备注：=&gt;是一个递进的过程，&lt;=是回归的过程，这就是尾递归的逻辑</span></span><br><span class="line"><span class="meta">#</span><span class="bash">递归是一个入栈出栈的过程</span></span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归定义：程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有<strong>边界条件</strong>、<strong>递归前进段</strong>和<strong>递归返回段</strong>。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p><p>通俗来讲，递归是函数调用自身函数的一种现象，函数不断引用自身，直到引用对象已知。</p><p>递归三大要素为：<strong>递归前进段</strong>，<strong>边界条件</strong>，<strong>递归返回段</strong></p><p>递归可以总结以下三点：</p><p>（1）明确函数的功能，即需要解决什么样的问题。</p><p>（2）具备边界调节，否则一直递归下去。</p><p>（3）函数的等价关系，则可以理解如何前进，如何返回。</p><p>例如阶乘的函数等价关系为f(n) = n * f(n-1)，这种跟数学归纳法有点类似，但是递归是有限处理并得到最终结果，而数学归纳法是归纳一种现象，且可以无限延生。</p><p>优缺点：</p><p>（1）优点：思路清晰，代码简单；将复杂大问题分解为小问题解决。</p><p>（2）缺点：基于栈内存运气，占空间。</p><p>备注：明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节。千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。</p><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p>边界条件：当n为1的时候结束返回数值1</p><p>函数等价关系：f(n) = n * f(n-1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorialRecursion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 边界条件</span></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数等价关系</span></span><br><span class="line"><span class="keyword">return</span> n * factorialRecursion(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>问题描述：斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34….，即第一项 f(1) = 1,第二项 f(2) = 1…..,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。</p><p>边界条件：当n为1或者2的时候结束返回数值1</p><p>函数等价关系：f(n) = f(n-1) + f(n-2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacciRecursion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 边界条件</span></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数等价关系</span></span><br><span class="line"><span class="keyword">return</span> fibonacciRecursion(n - <span class="number">1</span>) + fibonacciRecursion(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上知乎的理解（侵删）：</p><p><img src="/2021/02/09/Java数据结构与算法/递归算法/image-20210209143340154.png" alt="image-20210209143340154"></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="循环与递归"><a href="#循环与递归" class="headerlink" title="循环与递归"></a>循环与递归</h4><p>循环是有去无回，而递归则是有去有回(因为存在终止条件)。</p><p>例如：</p><p>（1）你用你手中的钥匙打开一扇门，结果去发现前方还有一扇门，紧接着你又用钥匙打开了这扇门，然后你又看到一扇们…但是当你开到某扇门时，发现前方是一堵墙无路可走了，你选择原路返回——这就是递归。</p><p>（2）但是如果你打开一扇门后，同样发现前方也有一扇们，紧接着你又打开下一扇门…直到打开最后一扇门出去，或者一直没有碰到尽头 （死循环）——这就是循环。</p><h4 id="分治算法与递归"><a href="#分治算法与递归" class="headerlink" title="分治算法与递归"></a>分治算法与递归</h4><p>分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。</p><p>分治算法是用迭代的方法将每一次的过程不断重复，每次迭代的结果会作为下次迭代的初始值。分治算法典型案例为二分查找。</p><ul><li>递归能写的，迭代不一定能写。</li><li>迭代能写的，递归一定能完成。</li></ul><h4 id="回溯算法与递归"><a href="#回溯算法与递归" class="headerlink" title="回溯算法与递归"></a>回溯算法与递归</h4><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。</p><p><strong>回溯的思路</strong>基本如下：当前局面下，我们有若干种选择，所以我们对每一种选择进行尝试。如果发现某种选择违反了某些限定条件，此时 return；如果尝试某种选择到了最后，发现该选择是正确解，那么就将其加入到解集中。<br>在这种思想下，我们需要清晰的找出三个要素：<strong>选择 (Options)</strong>，<strong>限制 (Restraints)</strong>，<strong>结束条件 (Termination)</strong>。</p><p>用回溯算法解决问题的一般步骤为:<br>1、定义一个解空间，它包含问题的解。<br>2、利用适于搜索的方法组织解空间。<br>3、利用深度优先法搜索解空间。<br>4、利用限界函数避免移动到不可能产生解的子空间。<br>问题的解空间通常是在搜索问题的解的过程中动态产生的，这是回溯算法的一个重要特性。</p><p>例如探索迷宫问题。</p><p>回溯算法的基本框架如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><h5 id="回溯算法与递归的区别"><a href="#回溯算法与递归的区别" class="headerlink" title="回溯算法与递归的区别"></a>回溯算法与递归的区别</h5><p>递归是一种算法结构。递归会出现在子程序中，形式上表现为直接或间接的自己调用自己。典型的例子是阶乘，计算规律为：n!=n×(n−1)!<br>回溯是一种算法思想，它是用递归实现的。回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。例如有求和问题，给定有 7 个元素的组合 [1, 2, 3, 4, 5, 6, 7]，求加和为 7 的子集。累加计算中，选择 1+2+3+4 时，判断得到结果为 10 大于 7，那么后面的 5, 6, 7 就没有必要计算了。这种方法属于搜索过程中的优化，即“剪枝”功能。<br>用一个比较通俗的说法来解释递归和回溯：<br>我们在路上走着，前面是一个多岔路口，因为我们并不知道应该走哪条路，所以我们需要尝试。尝试的过程就是一个函数。<br>我们选择了一个方向，后来发现又有一个多岔路口，这时候又需要进行一次选择。所以我们需要在上一次尝试结果的基础上，再做一次尝试，即在函数内部再调用一次函数，这就是递归的过程。<br>这样重复了若干次之后，发现这次选择的这条路走不通，这时候我们知道我们上一个路口选错了，所以我们要回到上一个路口重新选择其他路，这就是回溯的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;递归算法&quot;&gt;&lt;a href=&quot;#递归算法&quot; class=&quot;headerlink&quot; title=&quot;递归算法&quot;&gt;&lt;/a&gt;递归算法&lt;/h1&gt;
    
    </summary>
    
      <category term="Java数据结构与算法" scheme="http://yoursite.com/categories/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归算法" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找算法</title>
    <link href="http://yoursite.com/2021/02/08/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/02/08/Java数据结构与算法/二分查找算法/</id>
    <published>2021-02-08T13:44:06.000Z</published>
    <updated>2021-02-09T09:43:54.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h1><a id="more"></a><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>定义：二分查找（binary search）算法又叫折半查找算法，是一种在<strong>有序数组</strong>中，查找某一特定元素的搜索算法。</p><p>使用条件：必须是有序。</p><p>大致流程：搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><p>算法复杂度分析：</p><table><thead><tr><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(logN)</td><td>O(1)</td></tr></tbody></table><p>解决方法：非递归方法、递归方法</p><h2 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化左右指针, [left, right]</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历</span></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line"><span class="comment">// (right + left) / 2</span></span><br><span class="line"><span class="comment">// 目的:防止溢出</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line"><span class="comment">// 返回该数值的位置</span></span><br><span class="line"><span class="keyword">return</span> mid;    </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line"><span class="comment">// 目标值在右边,移动左指针</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line"><span class="comment">// 目标值在左边,移动右指针</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// whild end</span></span><br><span class="line"><span class="comment">// 未找到这个值</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="comment">// binarySearch end</span></span><br></pre></td></tr></table></figure><p>需要注意一下几点：</p><p>1、为什么while循环的条件中是&lt;=，而不是&lt;？</p><p>回答：因为初始化 right 的赋值是 nums.length - 1 ，即最后⼀个元素的索引，⽽不是 nums.length。可以理解为每次搜索空间两端都为闭区间[left， right]；</p><p>while退出条件：</p><p>（1）当找到目标的时候，即mid索引的值等于target的值就返回索引。</p><p>（2）当没有该目标的时候，终止条件为left==right + 1。</p><p>例如数组[1,2,4]，开始查找left和right相邻且指向1、4两个值，我们需要查找的值为3。第一次查找没找到，mid索引为1，则移动左指针mid+1为2；此时跟右指针相等都指向4这个值，进行逻辑判断，此时目标值在该值的左边，则移动右指针mid-1；此时right索引为3，left索引为4，没找到该值，则退出循环返回-1。</p><p>语言描述不够形象，后续补上动图。</p><p>2、为什么要写成left = mid +1，right = mid -1。而不是left = mid，right = mid。</p><p>由于我们的<strong>搜索区间</strong>左右都是闭区间[left，right]，当我们发现mid不是需要找的target时，我们下一步则需要去找[left，mid-1]或者[mid+1，right]。当然我们也可以写成left = mid，right = mid的形式，则需要修改相应的代码。</p><p>3、算法缺陷</p><p>如果有序数组[1,2,2,2,3]，target为2，算法返回的索引是2，结果正确，但是如果我们想得到target的左边界或者右边界的索引（1或者3），这种方法无法处理。</p><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchRecursion</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="comment">// 目的:防止溢出</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line"><span class="comment">// 目标值在右边,向右递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearchRecursion(nums, mid + <span class="number">1</span>, right, target);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line"><span class="comment">// 目标值在左边,向左递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearchRecursion(nums, left, mid - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：判断条件left &lt;= right与left &lt; right的区别。</p><h2 id="二分查找使用场景及优缺点"><a href="#二分查找使用场景及优缺点" class="headerlink" title="二分查找使用场景及优缺点"></a>二分查找使用场景及优缺点</h2><p>二分查找的时间复杂度为O(logN)，具有非常高效的查找算法。除了二分查找，在堆、二叉树的操作时间复杂度也可以为O(logN)。</p><p><strong>优点</strong>：时间复杂度低，用来查找数据效率很高。</p><p><strong>局限性</strong>：</p><p>（1）依赖顺序表结构，例如数组支持的下标随机访问，如果为链表，查找索引的值得时间复杂度为O(N)。</p><p>（2）数据有序，无序数据需要在二分查找之前进行排序，所以二分查找不适合频繁插入删除操作的数据。</p><p>（3）数据量小不适合二分查找，时间复杂度O(logN)是指的时间开销趋势，如果数据量小，顺序遍历的查找跟二分查找速度基本相差不大。</p><p>（4）数据量大也不适合二分查找，由于二分查找底层依赖于数组这类数据结构，如果几个G以上的数据，用数组存储需要连续内存空间，这种是不符合实际的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二分查找算法&quot;&gt;&lt;a href=&quot;#二分查找算法&quot; class=&quot;headerlink&quot; title=&quot;二分查找算法&quot;&gt;&lt;/a&gt;二分查找算法&lt;/h1&gt;
    
    </summary>
    
      <category term="Java数据结构与算法" scheme="http://yoursite.com/categories/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找算法" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java抽象类和接口</title>
    <link href="http://yoursite.com/2021/02/08/Java/%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2021/02/08/Java/基础/深入理解Java抽象类和接口/</id>
    <published>2021-02-08T03:17:36.000Z</published>
    <updated>2021-02-09T01:21:33.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Java抽象类和接口"><a href="#深入理解Java抽象类和接口" class="headerlink" title="深入理解Java抽象类和接口"></a>深入理解Java抽象类和接口</h1><a id="more"></a><p>对于面向对象编程来说，抽象是它的一大特征之一。在Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。</p><h2 id="一、抽象类"><a href="#一、抽象类" class="headerlink" title="一、抽象类"></a>一、抽象类</h2><p>抽象类和抽象方法必须使用abstract关键字进行修饰。</p><p>使用方法：使用extends关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstractDoor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含抽象方法的类称为抽象类，除了定义抽象方法，其它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：</p><p>  1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</p><p>  2）抽象类可以理解成在普通类的基础上拓展定义抽象方法，提供一种模板，由于抽象类是“半成品”，所以不能用来创建对象，即不能被实例化；但可以通过向上转型实例化，参考代理模式。</p><p>  3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。若子类没有完全实现父类所有抽象方法，则该子类也必须定为抽象类。</p><p>  在其他方面，抽象类和普通的类并没有区别。</p><h2 id="二、接口"><a href="#二、接口" class="headerlink" title="二、接口"></a>二、接口</h2><p>接口泛指指供别人调用的方法或者函数，它是对行为的抽象。</p><p>使用方法：使用implements关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeHandle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dealHandle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterHandle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口可以含有变量和方法（且方法不能有具体实现），变量会被隐式地指定为public static final变量（只能是public static final变量，否则编译报错），方法会被隐式地指定为public abstract方法且只能是public abstract方法，即接口中的方法必须全为抽象方法。允许一个类遵循多个特定的接口。</p><ul><li>非抽象类遵循了某个接口，就必须实现该接口中的所有方法。</li><li>抽象类遵循了某个接口，可以不实现该接口中的抽象方法。</li></ul><h2 id="三、抽象类和接口的区别"><a href="#三、抽象类和接口的区别" class="headerlink" title="三、抽象类和接口的区别"></a>三、抽象类和接口的区别</h2><h3 id="1、语法层面的区别"><a href="#1、语法层面的区别" class="headerlink" title="1、语法层面的区别"></a>1、语法层面的区别</h3><p>1）方法：抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法<br>2）成员变量：抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的<br>3）静态代码块和静态方法：接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><h3 id="2、设计层面的区别"><a href="#2、设计层面的区别" class="headerlink" title="2、设计层面的区别"></a>2、设计层面的区别</h3><p>1）抽象类是对一种事物的抽象、对类抽象，而接口是对行为的抽象。<strong>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象</strong>。</p><p>eg：例如，飞机和鸟都具有飞的属性，可以设计一个接口Fly，包含Fly()方法。如果有不同类别的战斗机，可以继承飞机抽象类。</p><p>总结：<strong>继承是一个“是不是”的关系，而接口是“有没有”的关系</strong>。如果一个类继承了一个抽象类，那么子类也是属于这个抽象类的一种。而接口只是约束行为（方法）。</p><p>2）抽象类可以作为很多子类的父类，它是一种模板式设计；而接口是一种行为规范，它是一种辐射式设计。</p><p>模板式设计：如果两个B、C子类继承C抽象类，B、C子类公共部分就是模板A，如果公共部分需要改动，只需要改动模板A了，不需要重新改动B、C子类。</p><p>辐射式设计：比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstractDoor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterfaceDoor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p><p>　　1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p><p>　　2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p><p>​    从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类衍生接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterfaceAlarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAlarmDoor</span> <span class="keyword">extends</span> <span class="title">TestAbstractDoor</span> <span class="keyword">implements</span> <span class="title">TestInterfaceAlarm</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深入理解Java抽象类和接口&quot;&gt;&lt;a href=&quot;#深入理解Java抽象类和接口&quot; class=&quot;headerlink&quot; title=&quot;深入理解Java抽象类和接口&quot;&gt;&lt;/a&gt;深入理解Java抽象类和接口&lt;/h1&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java面向对象" scheme="http://yoursite.com/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>UML类图的使用</title>
    <link href="http://yoursite.com/2021/02/07/%E6%9D%82/UML%E7%B1%BB%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2021/02/07/杂/UML类图的使用/</id>
    <published>2021-02-07T07:14:36.000Z</published>
    <updated>2021-02-07T07:15:20.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UML类图的使用"><a href="#UML类图的使用" class="headerlink" title="UML类图的使用"></a>UML类图的使用</h1><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>UML类图包含6种关系：继承关系、实现关系、依赖关系、关联关系、聚合关系、组合关系</p><h2 id="1、继承关系"><a href="#1、继承关系" class="headerlink" title="1、继承关系"></a>1、继承关系</h2><p>一个类（子类、子接口）继承另外一个类（称为父类、父接口）的功能，并可以增加自己新功能的能力。在Java继承关系中通过关键字<strong>extends</strong>标识。</p><p>图形表示：<strong>空心三角箭头，实线</strong>表示，从子类指向父类，或者子接口指向父接口；</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204163339948.png" alt="image-20210204163339948"></p><h3 id="2、实现关系"><a href="#2、实现关系" class="headerlink" title="2、实现关系"></a>2、实现关系</h3><p>一个Class类实现interface接口（可以多个）的功能，是类与接口之间的关系。在Java中实现关系通过<strong>implements</strong>明确标识。</p><p>图形表示：<strong>空心三角箭头，虚线</strong>表示。从类指向接口。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204163735026.png" alt="image-20210204163735026"></p><h3 id="3、依赖关系"><a href="#3、依赖关系" class="headerlink" title="3、依赖关系"></a>3、依赖关系</h3><p>依赖是一个类A使用到了另一个类B，关系较弱，偶尔调用另一对象或者临时调用，类B的改动会影响到类A。在代码层面为，类B作为参数被类A中的某个method方法中使用。</p><p>图形表示：<strong>箭头，虚线</strong>。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204172535428.png" alt="image-20210204172535428"></p><h3 id="4、关联关系"><a href="#4、关联关系" class="headerlink" title="4、关联关系"></a>4、关联关系</h3><p>关联体现两个类之间有强依赖关系，这种关系比依赖更强，不存在偶然性或者临时性，一般是长期性质的，并且两个类之间的关系是平等的。关联可以是单向、双向的，在代码层面，被关联类B以类的属性存在于关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。</p><p>图形表示：<strong>箭头，实线</strong>。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204173144804.png" alt="image-20210204173144804"></p><h3 id="5、聚合关系"><a href="#5、聚合关系" class="headerlink" title="5、聚合关系"></a>5、聚合关系</h3><p>聚合是关联关系的一种特例，体现整体与部分的关系，即has-a的关系。聚合关系整体与部分可以分离，可以跟组合关系做对比。</p><p>例如：家庭和孩子的关系，一个家庭里面可以没有孩子，可以有也可以没有。</p><p>图形表示：<strong>空心棱形，实线</strong>。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204173444209.png" alt="image-20210204173444209"></p><h3 id="6、组合关系"><a href="#6、组合关系" class="headerlink" title="6、组合关系"></a>6、组合关系</h3><p>组合是关联关系的一种特例，体现contains-a的关系，比聚合更强。整体与部分不可分。</p><p>例如：人和大脑的关系，人必须有大脑。</p><p>图形表示：<strong>实心棱形，实线</strong>。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204174510211.png" alt="image-20210204174510211"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UML类图的使用&quot;&gt;&lt;a href=&quot;#UML类图的使用&quot; class=&quot;headerlink&quot; title=&quot;UML类图的使用&quot;&gt;&lt;/a&gt;UML类图的使用&lt;/h1&gt;
    
    </summary>
    
      <category term="杂" scheme="http://yoursite.com/categories/%E6%9D%82/"/>
    
    
      <category term="UML" scheme="http://yoursite.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://yoursite.com/2021/02/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/02/05/设计模式/工厂模式/</id>
    <published>2021-02-05T12:45:12.000Z</published>
    <updated>2021-02-07T02:14:11.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><a id="more"></a><p>介绍简单工厂模式和工厂方法模式。</p><h2 id="1、简单工厂模式（静态工厂方法模式）"><a href="#1、简单工厂模式（静态工厂方法模式）" class="headerlink" title="1、简单工厂模式（静态工厂方法模式）"></a>1、简单工厂模式（静态工厂方法模式）</h2><p><strong>定义</strong>：简单工厂模式属于创建型模式，又被称为静态工厂方法模式，这是一个工厂对象决定创建出哪一种产品类的实例。</p><p><img src="/2021/02/05/设计模式/工厂模式/image-20210204213840439.png" alt="image-20210204213840439"></p><p>（1）抽象产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"><span class="comment">// 产品的抽象方法,由具体的产品类实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）具体产品类</p><p>继承抽象类，具体实现三种产品类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体产品类,联想计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"联想计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类,惠普计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"惠普计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类,华硕计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"华硕计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）工厂类</p><p>通过传入具体产品类别来实例化对应对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title">createComputer</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">Computer mComputer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"lenovo"</span>:</span><br><span class="line">mComputer = <span class="keyword">new</span> LenovoComputer();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"hp"</span>:</span><br><span class="line">mComputer = <span class="keyword">new</span> HpComputer();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"asus"</span>:</span><br><span class="line">mComputer = <span class="keyword">new</span> AsusComputer();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mComputer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）客户端调用工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端调用工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatComputer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ComputerFactory.createComputer(<span class="string">"hp"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单工厂模式优缺点</strong></p><p>优点：根据参数获取对应的类实例，避免类的直接实例化。</p><p>缺点：可实例化对象在编译期间就确定。如果需要新增加类型，则需要重新修改工厂类方法。简单工厂需要知道所有要生成的类型，当子类过多或者层次过多时候不宜使用。</p><h2 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h2><p><strong>定义</strong>：定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到子类。</p><p><img src="/2021/02/05/设计模式/工厂模式/image-20210204220304332.png" alt="image-20210204220304332"></p><p>（1）抽象产品类（同上、重复内容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"><span class="comment">// 产品的抽象方法,由具体的产品类实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）具体产品类（同上、重复内容）</p><p>继承抽象类，具体实现三种产品类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体产品类,联想计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"联想计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类,惠普计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"惠普计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类,华硕计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"华硕计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）抽象工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Computer&gt; <span class="function">T <span class="title">createComputer</span><span class="params">(Class&lt;T&gt; clz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）具体工厂</p><p>具体工厂继承抽象工厂，通过反射来生产不同厂家的计算机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComputerFactor</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Computer&gt; <span class="function">T <span class="title">creatComputer</span><span class="params">(Class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">Computer computer = <span class="keyword">null</span>;</span><br><span class="line">String className = clz.getName();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 通过反射来实例化不同厂家的计算机</span></span><br><span class="line">computer = (Computer) Class.forName(className).newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T)computer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）客户端调用</p><p>通过反射和抽象工厂来实例化不同厂家计算机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 抽象工厂实例化</span></span><br><span class="line">ComputerFactory computerFactory = <span class="keyword">new</span> MyComputerFactor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射和抽象工厂来实例化不同厂家计算机</span></span><br><span class="line">LenovoComputer mLenovoComputer = computerFactory.createComputer(LenovoComputer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">mLenovoComputer.start();</span><br><span class="line"></span><br><span class="line">HpComputer mHpComputer = computerFactory.createComputer(HpComputer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">mHpComputer.start();</span><br><span class="line"></span><br><span class="line">AsusComputer mAsusComputer = computerFactory.createComputer(AsusComputer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">mAsusComputer.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工厂方法模式优缺点</strong></p><p>解决需求更改后不用修改工厂类，而是直接创建具体产品类，通过抽象工厂模式来实例化具体产品对象，解决了与具体产品的依赖，符合开放封闭原则。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h1&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="工厂模式" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客迁移记录</title>
    <link href="http://yoursite.com/2021/02/05/%E6%9D%82/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2021/02/05/杂/hexo博客迁移记录/</id>
    <published>2021-02-05T12:43:57.000Z</published>
    <updated>2021-02-07T02:14:11.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo博客迁移记录"><a href="#hexo博客迁移记录" class="headerlink" title="hexo博客迁移记录"></a>hexo博客迁移记录</h1><a id="more"></a><p>1、新建hexo分支</p><p>git checkout -b hexo</p><p>并将推送分支并merge到远程分支</p><p>git push origin hexo:hexo</p><p>2、删除hexo下面除了.git所有内容</p><p>3、将现有hexo目录拷贝到hexo分支下</p><p><img src="/2021/02/05/杂/hexo博客迁移记录/image-20210205105140194.png" alt="image-20210205105140194"></p><p>修改.gitgnore里的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><p>清除npm缓存</p><p>删除node_model文件夹，删除package.lock.json文件</p><p>npm cache clean –force</p><p>使用淘宝npm镜像</p><p>npm install cnpm -g –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><p>然后使用cnpm安装模块</p><p>cnpm install hexo</p><p>cnpm install</p><p>cnpm install hexo-deployer-git</p><p>hexo c &amp; hexo g &amp; hexo s</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hexo博客迁移记录&quot;&gt;&lt;a href=&quot;#hexo博客迁移记录&quot; class=&quot;headerlink&quot; title=&quot;hexo博客迁移记录&quot;&gt;&lt;/a&gt;hexo博客迁移记录&lt;/h1&gt;
    
    </summary>
    
      <category term="杂" scheme="http://yoursite.com/categories/%E6%9D%82/"/>
    
    
      <category term="杂" scheme="http://yoursite.com/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/02/04/设计模式/单例模式/</id>
    <published>2021-02-04T02:40:49.000Z</published>
    <updated>2021-02-07T02:14:11.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><a id="more"></a><p>定义：保证一个类只有一个实例，并提供访问它的全局访问点。</p><p><img src="/2021/02/04/设计模式/单例模式/image-20210204091623224.png" alt="image-20210204091623224"></p><p>Client为客户端，Singleton为单例类，通过调用getInstance()方法获取实例对象</p><p>以下介绍单例模式的6种写法，其中第一种静态内部类单例模式是常用方法，后面5种介绍其他方法，并分析其优缺点。</p><h2 id="6种写法"><a href="#6种写法" class="headerlink" title="6种写法"></a>6种写法</h2><h3 id="1、静态内部类单例模式"><a href="#1、静态内部类单例模式" class="headerlink" title="1、静态内部类单例模式"></a>1、静态内部类单例模式</h3><p>静态内部类单例模式是推荐使用方法，在第一次加载Singleton类不会初始化sInstance，只有第一次调用getInstance()方法时JVM虚拟机加载SingletonHolder内部类并初始化sInstance。</p><p>优点：既能保证线程安全，也能保证Singleton的唯一性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHolder.sInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、枚举单例"><a href="#2、枚举单例" class="headerlink" title="2、枚举单例"></a>2、枚举单例</h3><p>默认枚举实例是线程安全的，并且在任何情况都是单例模式。普通类在反序列化的时候，会重新创建对象。由于枚举枚举默认继承Enum类，在枚举类中禁用了readObject方法，不会因为序列化的时候破坏单例，并且在反序列化的时候不会去重新创建对象。</p><p>优点：杜绝在反序列化的时候重新创建对象。</p><p>确定：使用较少，可读性不高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义枚举单例</span></span><br><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举单例方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、饿汉模式"><a href="#3、饿汉模式" class="headerlink" title="3、饿汉模式"></a>3、饿汉模式</h3><p>优点：基于类加载机制，避免多线程问题；获取对象较快。</p><p>缺点：在类加载时进行初始化，加载较慢；如果从未获取该实例，造成内存浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、懒汉模式（线程不安全）"><a href="#4、懒汉模式（线程不安全）" class="headerlink" title="4、懒汉模式（线程不安全）"></a>4、懒汉模式（线程不安全）</h3><p>在内部声明静态变量，只在调用的时候做初始化；</p><p>缺点：多线程不能正常工作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、懒汉模式（线程安全）"><a href="#5、懒汉模式（线程安全）" class="headerlink" title="5、懒汉模式（线程安全）"></a>5、懒汉模式（线程安全）</h3><p>将获取实例方法变成同步块方法，保证线程安全。</p><p>缺点：每次调用都需要同步，造成不必要的同步开销；（不建议使用该方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、双重检查模式（DCL）"><a href="#6、双重检查模式（DCL）" class="headerlink" title="6、双重检查模式（DCL）"></a>6、双重检查模式（DCL）</h3><p>在获取实例方法中进行两次判空，第一次是避免不必要的同步，第二次是判断Singleton类为空时创建实例。</p><p>优点：资源利用率高，解决资源消耗、多余同步、线程安全问题；</p><p>缺点：在某些情况会出现失效的问题，也就是DCL失效；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式参考书籍和设计思想</title>
    <link href="http://yoursite.com/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2021/02/04/设计模式/设计模式参考书籍和设计思想/</id>
    <published>2021-02-04T02:20:42.000Z</published>
    <updated>2021-02-07T02:14:11.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式参考书籍和设计思想"><a href="#设计模式参考书籍和设计思想" class="headerlink" title="设计模式参考书籍和设计思想"></a>设计模式参考书籍和设计思想</h1><a id="more"></a><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h3><p>单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、迪米特原则、接口隔离原则</p><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p><strong>定义</strong>：一个类，应该有一个引起它变化的原因</p><p>松耦合，一个类只做一个事情。</p><h4 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h4><p><strong>定义</strong>：类、模块、函数等都应该是可拓展，但不可修改</p><p>一个对于拓展是开放的，一个对于修改是封闭的。传统方法，需求变化需要将类重新修改一遍；模式方法，如果需求更改，通过拓展的方式实现，而不是修改原有代码；</p><p>开放封闭原则解决方法：增加一个抽象的功能类，让添加、删除和查询等作为这个抽象类的子类。</p><p><strong>目的</strong>：如果新增功能，无须修改原有类，只需要添加一个功能类的子类实现原有功能类的方法就行了。</p><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p><strong>定义</strong>：所有引用基类（父类）的地方必须能透明地使用其子类的对象</p><p>在程序中将基类对象替换为子类对象，程序正常；反之，子类对象不一定能够使用基类对象；</p><p>由于使用基类对象的地方都可以使用子类对象，因此，在程序中尽量使用基类类型来进行对象定义，而在运行的时候再确定其子类的类型，用子类对象来替换父类对象。（向下转型？）</p><p>尽量将基类设计为抽象类或者接口，让子类继承父类实现父接口，并实现父类声明方法。</p><p><strong>目的</strong>：运行时，子类示例替换父类实例，可以方便拓展系统功能，同时无须修改原有子类代码；增加新功能可以通过增加一个新的子类来实现。</p><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p><strong>定义</strong>：高层模块不应该依赖底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><p>抽象：接口类或者抽象类；细节：实现类；高层模块：调用端；底层模块：具体实现类；</p><p>目的：模块之间依赖通过抽象发生，实现类不产生直接依赖关系，依赖关系通过接口或者抽象类产生；如果实现类与实现类直接依赖细节，则产生耦合关系。其目的也是为了松耦合。</p><h4 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h4><p><strong>定义</strong>：一个软件实体尽可能少于其它实体发生相互作用。</p><p>如果模块修改，尽可能少影响其它模块。如果其中一个对象需要调用另一个对象的方法，可以通过第三者转发这个调用。</p><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p><strong>定义</strong>：一个类对另一个类的依赖尽可能建立在最小接口上。</p><p>建立单一接口，不要建立庞大的臃肿的接口；尽可能细化接口，接口中方法尽量少。也就是为各个类建立专用的接口。</p><h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p>GoF提出23种</p><h4 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h4><p>单例模式</p><p>工厂方法模式</p><p>抽象工厂模式</p><p>创建者模式</p><p>原型模式</p><h4 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h4><p>设配器模式</p><p>装饰模式</p><p>代理模式</p><p>外观模式</p><p>桥接模式</p><p>组合模式</p><p>享元模式</p><h4 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h4><p>策略模式</p><p>模板方法模式</p><p>观察者模式</p><p>迭代器模式</p><p>责任链模式</p><p>命令模式</p><p>备忘录模式</p><p>状态模式</p><p>访问者模式</p><p>中介模式</p><p>解释器模式</p><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><p>《Android进阶之光》    刘望舒</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式参考书籍和设计思想&quot;&gt;&lt;a href=&quot;#设计模式参考书籍和设计思想&quot; class=&quot;headerlink&quot; title=&quot;设计模式参考书籍和设计思想&quot;&gt;&lt;/a&gt;设计模式参考书籍和设计思想&lt;/h1&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计思想" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/12/12/%E6%9D%82/hello-world/"/>
    <id>http://yoursite.com/2020/12/12/杂/hello-world/</id>
    <published>2020-12-12T12:43:57.000Z</published>
    <updated>2021-02-07T02:14:11.080Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my Blog.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my Blog.&lt;/p&gt;
    
    </summary>
    
      <category term="杂" scheme="http://yoursite.com/categories/%E6%9D%82/"/>
    
    
      <category term="杂" scheme="http://yoursite.com/tags/%E6%9D%82/"/>
    
  </entry>
  
</feed>
