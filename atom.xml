<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MingRong&#39;s Boat</title>
  
  <subtitle>O Captain! My Captain!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-25T08:42:38.949Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>MingRongChen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Opencv-python使用基础</title>
    <link href="http://yoursite.com/2021/02/25/Python/OpenCV-python%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/02/25/Python/OpenCV-python使用基础/</id>
    <published>2021-02-25T08:29:32.000Z</published>
    <updated>2021-02-25T08:42:38.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenCV-python使用基础"><a href="#OpenCV-python使用基础" class="headerlink" title="OpenCV-python使用基础"></a>OpenCV-python使用基础</h1><a id="more"></a><h2 id="基本图像处理"><a href="#基本图像处理" class="headerlink" title="基本图像处理"></a>基本图像处理</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>plt.imread和PIL.Image.open读入的都是RGB顺序，而opencv中cv2.imread读入的是BGR通道顺序 。cv2.imread会显示图片更蓝一些。</p><p>虽然python 很强大，而且也有自己的图像处理库PIL，但是相对于OpenCV 来讲，它还是弱小很多。跟很多开源软件一样OpenCV 也提供了完善的python 接口，非常便于调用。</p><p>Python 作为一种高效简洁的直译式语言非常适合我们用来解决日常工作的问题。而且它简单易学，初学者几个小时就可以基本入门。再加上Numpy 和matplotlib 这两个翅膀，Python 对数据分析的能力不逊于Matlab。Python 还被称为是胶水语言，有很多软件都提供了Python 接口。尤其是在linux 下，可以使用Python 将不同的软件组成一个工作流，发挥每一个软件自己最大的优势从而完成一个复杂的任务。比如我们可以使用Mysql 存储数据，使用R 分析数据，使用matplotlib 展示数据，使用OpenGL 进行3D 建模，使用Qt 构建漂亮的GUI。而Python 可以将他们联合在一起构建一个强大的工作流。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="读取显示图片"><a href="#读取显示图片" class="headerlink" title="读取显示图片"></a>读取显示图片</h4><p>opencv支持读取bmp、jpg、png、tiff等常用格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2    <span class="comment">#导入cv模块</span></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"11.jpg"</span>)<span class="comment">#读取图片</span></span><br><span class="line">cv2.namedWindow(<span class="string">"Image"</span>)<span class="comment">#创建窗口，并命名</span></span><br><span class="line">cv2.imshow(<span class="string">"Image"</span>, img)<span class="comment">#在窗口中显示图像</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)<span class="comment">#若不添加，串口会一闪而过</span></span><br><span class="line">cv2.destroyAllWindows() <span class="comment">#释放窗口</span></span><br><span class="line"><span class="comment">#cv2.destroyWindow(("Image")</span></span><br></pre></td></tr></table></figure><h4 id="创建图像"><a href="#创建图像" class="headerlink" title="创建图像"></a>创建图像</h4><p>opencv接口中没有直接创建图像的接口，若要创建图像，需要用到numpy函数。在新的opencv-python中，图像使用Numpy数据的属性来表示图像的尺寸和通道信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emptyImage = np.zeros(img.shape, np.uint8) </span><br><span class="line">emptyImage2 = img.copy();</span><br><span class="line"></span><br><span class="line">emptyImage3=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<span class="comment">#使用cvtColor函数获取原图像的副本</span></span><br></pre></td></tr></table></figure><h4 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h4><p>保存图像比较简单，直接使用cv2.imwrite即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"12.jpg"</span>)</span><br></pre></td></tr></table></figure><h4 id="图片操作"><a href="#图片操作" class="headerlink" title="图片操作"></a>图片操作</h4><h5 id="图片翻转"><a href="#图片翻转" class="headerlink" title="图片翻转"></a>图片翻转</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imgflip = cv2.flip(img, <span class="number">1</span>)    <span class="comment">#0:沿x轴翻转；1：沿y轴翻转；-1:沿x，y同时翻转</span></span><br></pre></td></tr></table></figure><h5 id="复制图片"><a href="#复制图片" class="headerlink" title="复制图片"></a>复制图片</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imgcopy = img.copy()</span><br></pre></td></tr></table></figure><h5 id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#彩色图像转为灰度图像</span></span><br><span class="line">img2 = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY) </span><br><span class="line"><span class="comment">#灰度图像转为彩色图像</span></span><br><span class="line">img3 = cv2.cvtColor(img,cv2.COLOR_GRAY2RGB)</span><br><span class="line"><span class="comment"># cv2.COLOR_X2Y，其中X,Y = RGB, BGR, GRAY, HSV, YCrCb, XYZ, Lab, Luv, HLS</span></span><br></pre></td></tr></table></figure><h5 id="图片画图"><a href="#图片画图" class="headerlink" title="图片画图"></a>图片画图</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">np.set_printoptions(threshold=<span class="string">'nan'</span>)</span><br><span class="line"><span class="comment"># 创建一个宽512高512的黑色画布，RGB(0,0,0)即黑色</span></span><br><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line"><span class="comment"># 画直线,图片对象，起始坐标(x轴,y轴)，结束坐标，颜色，宽度</span></span><br><span class="line">cv2.line(img,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">311</span>,<span class="number">511</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 画矩形，图片对象，左上角坐标，右下角坐标，颜色，宽度</span></span><br><span class="line">cv2.rectangle(img,(<span class="number">30</span>,<span class="number">166</span>),(<span class="number">130</span>,<span class="number">266</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 画圆形，图片对象，中心点坐标，半径大小，颜色，宽度</span></span><br><span class="line">cv2.circle(img,(<span class="number">222</span>,<span class="number">222</span>),<span class="number">50</span>,(<span class="number">255.111</span>,<span class="number">111</span>),<span class="number">-1</span>)</span><br><span class="line"><span class="comment"># 画椭圆形，图片对象，中心点坐标，长短轴，顺时针旋转度数，开始角度(右长轴表0度，上短轴表270度)，颜色，宽度</span></span><br><span class="line">cv2.ellipse(img,(<span class="number">333</span>,<span class="number">333</span>),(<span class="number">50</span>,<span class="number">20</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,(<span class="number">255</span>,<span class="number">222</span>,<span class="number">222</span>),<span class="number">-1</span>)</span><br><span class="line"><span class="comment"># 画多边形，指定各个点坐标,array必须是int32类型</span></span><br><span class="line">pts=np.array([[<span class="number">10</span>,<span class="number">5</span>],[<span class="number">20</span>,<span class="number">30</span>],[<span class="number">70</span>,<span class="number">20</span>],[<span class="number">50</span>,<span class="number">10</span>]], np.int32)</span><br><span class="line"><span class="comment"># -1表示该纬度靠后面的纬度自动计算出来，实际上是4</span></span><br><span class="line">pts = pts.reshape((<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,))</span><br><span class="line"><span class="comment"># 画多条线，False表不闭合，True表示闭合，闭合即多边形</span></span><br><span class="line">cv2.polylines(img,[pts],<span class="literal">True</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">5</span>)</span><br><span class="line"><span class="comment">#写字,字体选择</span></span><br><span class="line">font=cv2.FONT_HERSHEY_SCRIPT_COMPLEX</span><br><span class="line"><span class="comment"># 图片对象，要写的内容，左边距，字的底部到画布上端的距离，字体，大小，颜色，粗细</span></span><br><span class="line">cv2.putText(img,<span class="string">"OpenCV"</span>,(<span class="number">10</span>,<span class="number">400</span>),font,<span class="number">3.5</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="图片大小区域处理"><a href="#图片大小区域处理" class="headerlink" title="图片大小区域处理"></a>图片大小区域处理</h3><h4 id="图片缩放"><a href="#图片缩放" class="headerlink" title="图片缩放"></a>图片缩放</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">''</span>)</span><br><span class="line"><span class="comment"># 缩放成200x200的方形图像，没有指定插值方法，会失真</span></span><br><span class="line">img_200x200 = cv2.resize(img, (<span class="number">200</span>, <span class="number">200</span>))</span><br><span class="line"><span class="comment"># 不直接指定缩放后大小，通过fx和fy指定缩放比例，0.5则长宽都为原来一半</span></span><br><span class="line"><span class="comment"># 等效于img_200x300 = cv2.resize(img, (300, 200))，注意指定大小的格式是(宽度,高度)</span></span><br><span class="line"><span class="comment"># 插值方法默认是cv2.INTER_LINEAR，这里指定为最近邻插值</span></span><br><span class="line">img_200x300 = cv2.resize(img, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">0.5</span>, fy=<span class="number">0.5</span>, </span><br><span class="line">                              interpolation=cv2.INTER_NEAREST)</span><br></pre></td></tr></table></figure><h4 id="图片裁剪"><a href="#图片裁剪" class="headerlink" title="图片裁剪"></a>图片裁剪</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cropImg = img[<span class="number">20</span>:<span class="number">150</span>, <span class="number">-180</span>:<span class="number">-50</span>]</span><br></pre></td></tr></table></figure><h4 id="图片补边"><a href="#图片补边" class="headerlink" title="图片补边"></a>图片补边</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给图片上下各贴50像素的黑边，</span></span><br><span class="line">borderImg = cv2.copyMakeBorder(img, <span class="number">50</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>,cv2.BORDER_CONSTANT,value=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><h4 id="图片本身处理"><a href="#图片本身处理" class="headerlink" title="图片本身处理"></a>图片本身处理</h4><h5 id="HSV空间调节"><a href="#HSV空间调节" class="headerlink" title="HSV空间调节"></a>HSV空间调节</h5><p>图像本身的属性操作也非常多，比如可以通过HSV空间对色调和明暗进行调节。HSV空间是由美国的图形学专家A. R. Smith提出的一种颜色空间，HSV分别是色调（Hue），饱和度（Saturation）和明度（Value）。在HSV空间中进行调节就避免了直接在RGB空间中调节是还需要考虑三个通道的相关性。OpenCV中H的取值是[0, 180)，其他两个通道的取值都是[0, 256)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过cv2.cvtColor把图像从BGR转换到HSV</span></span><br><span class="line">img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span><br><span class="line"><span class="comment"># H空间中，绿色比黄色的值高一点，所以给每个像素+15，黄色的树叶就会变绿</span></span><br><span class="line">turn_green_hsv = img_hsv.copy()</span><br><span class="line">turn_green_hsv[:, :, <span class="number">0</span>] = (turn_green_hsv[:, :, <span class="number">0</span>]+<span class="number">15</span>) % <span class="number">180</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 减小饱和度会让图像损失鲜艳，变得更灰</span></span><br><span class="line">colorless_hsv = img_hsv.copy()</span><br><span class="line">colorless_hsv[:, :, <span class="number">1</span>] = <span class="number">0.5</span> * colorless_hsv[:, :, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减小明度为原来一半</span></span><br><span class="line">darker_hsv = img_hsv.copy()</span><br><span class="line">darker_hsv[:, :, <span class="number">2</span>] = <span class="number">0.5</span> * darker_hsv[:, :, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h5 id="直方图和Gamma变换"><a href="#直方图和Gamma变换" class="headerlink" title="直方图和Gamma变换"></a>直方图和Gamma变换</h5><p>我们都较难一眼就对像素中值的分布有细致的了解，这时候就需要直方图。如果直方图中的成分过于靠近0或者255，可能就出现了暗部细节不足或者亮部细节丢失的情况。当背景里的暗部细节非常弱的个时候，一个常用方法是考虑用Gamma变换来提升暗部细节。Gamma变换是矫正相机直接成像和人眼感受图像差别的一种常用手段，简单来说就是通过非线性变换让图像从对曝光强度的线性响应变得更接近人眼感受到的响应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分通道计算每个通道的直方图</span></span><br><span class="line">hist_b = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist_g = cv2.calcHist([img], [<span class="number">1</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist_r = cv2.calcHist([img], [<span class="number">2</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义Gamma矫正的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gamma_trans</span><span class="params">(img, gamma)</span>:</span></span><br><span class="line">    <span class="comment"># 具体做法是先归一化到1，然后gamma作为指数值求出新的像素值再还原</span></span><br><span class="line">    gamma_table = [np.power(x/<span class="number">255.0</span>, gamma)*<span class="number">255.0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">256</span>)]</span><br><span class="line">    gamma_table = np.round(np.array(gamma_table)).astype(np.uint8)</span><br><span class="line">    <span class="comment"># 实现这个映射用的是OpenCV的查表函数</span></span><br><span class="line">    <span class="keyword">return</span> cv2.LUT(img, gamma_table)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行Gamma矫正，小于1的值让暗部细节大量提升，同时亮部细节少量提升</span></span><br><span class="line">img_corrected = gamma_trans(img, <span class="number">0.5</span>)</span><br><span class="line">cv2.imwrite(<span class="string">'gamma_corrected.jpg'</span>, img_corrected)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分通道计算Gamma矫正后的直方图</span></span><br><span class="line">hist_b_corrected = cv2.calcHist([img_corrected], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist_g_corrected = cv2.calcHist([img_corrected], [<span class="number">1</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist_r_corrected = cv2.calcHist([img_corrected], [<span class="number">2</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将直方图进行可视化</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line">pix_hists = [</span><br><span class="line">    [hist_b, hist_g, hist_r],</span><br><span class="line">    [hist_b_corrected, hist_g_corrected, hist_r_corrected]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">pix_vals = range(<span class="number">256</span>)</span><br><span class="line"><span class="keyword">for</span> sub_plt, pix_hist <span class="keyword">in</span> zip([<span class="number">121</span>, <span class="number">122</span>], pix_hists):</span><br><span class="line">    ax = fig.add_subplot(sub_plt, projection=<span class="string">'3d'</span>)</span><br><span class="line">    <span class="keyword">for</span> c, z, channel_hist <span class="keyword">in</span> zip([<span class="string">'b'</span>, <span class="string">'g'</span>, <span class="string">'r'</span>], [<span class="number">20</span>, <span class="number">10</span>, <span class="number">0</span>], pix_hist):</span><br><span class="line">        cs = [c] * <span class="number">256</span></span><br><span class="line">        ax.bar(pix_vals, channel_hist, zs=z, zdir=<span class="string">'y'</span>, color=cs, alpha=<span class="number">0.618</span>, edgecolor=<span class="string">'none'</span>, lw=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    ax.set_xlabel(<span class="string">'Pixel Values'</span>)</span><br><span class="line">    ax.set_xlim([<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    ax.set_ylabel(<span class="string">'Channels'</span>)</span><br><span class="line">    ax.set_zlabel(<span class="string">'Counts'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="图片仿射变换"><a href="#图片仿射变换" class="headerlink" title="图片仿射变换"></a>图片仿射变换</h4><h5 id="仿射变换原理：略"><a href="#仿射变换原理：略" class="headerlink" title="仿射变换原理：略"></a>仿射变换原理：略</h5><p>在OpenCV中实现仿射变换是通过仿射变换矩阵和cv2.warpAffine()共同处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取一张斯里兰卡拍摄的大象照片</span></span><br><span class="line">img = cv2.imread(<span class="string">'lanka_safari.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿着横纵轴放大1.6倍，然后平移(-150,-240)，最后沿原图大小截取，等效于裁剪并放大</span></span><br><span class="line">M_crop_elephant = np.array([</span><br><span class="line">    [<span class="number">1.6</span>, <span class="number">0</span>, <span class="number">-150</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1.6</span>, <span class="number">-240</span>]</span><br><span class="line">], dtype=np.float32)</span><br><span class="line"></span><br><span class="line">img_elephant = cv2.warpAffine(img, M_crop_elephant, (<span class="number">400</span>, <span class="number">600</span>))</span><br><span class="line">cv2.imwrite(<span class="string">'lanka_elephant.jpg'</span>, img_elephant)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x轴的剪切变换，角度15°</span></span><br><span class="line">theta = <span class="number">15</span> * np.pi / <span class="number">180</span></span><br><span class="line">M_shear = np.array([</span><br><span class="line">    [<span class="number">1</span>, np.tan(theta), <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">], dtype=np.float32)</span><br><span class="line"></span><br><span class="line">img_sheared = cv2.warpAffine(img, M_shear, (<span class="number">400</span>, <span class="number">600</span>))</span><br><span class="line">cv2.imwrite(<span class="string">'lanka_safari_sheared.jpg'</span>, img_sheared)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺时针旋转，角度15°</span></span><br><span class="line">M_rotate = np.array([</span><br><span class="line">    [np.cos(theta), -np.sin(theta), <span class="number">0</span>],</span><br><span class="line">    [np.sin(theta), np.cos(theta), <span class="number">0</span>]</span><br><span class="line">], dtype=np.float32)</span><br><span class="line"></span><br><span class="line">img_rotated = cv2.warpAffine(img, M_rotate, (<span class="number">400</span>, <span class="number">600</span>))</span><br><span class="line">cv2.imwrite(<span class="string">'lanka_safari_rotated.jpg'</span>, img_rotated)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 某种变换，具体旋转+缩放+旋转组合可以通过SVD分解理解</span></span><br><span class="line">M = np.array([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">-400</span>],</span><br><span class="line">    [<span class="number">0.5</span>, <span class="number">2</span>, <span class="number">-100</span>]</span><br><span class="line">], dtype=np.float32)</span><br><span class="line"></span><br><span class="line">img_transformed = cv2.warpAffine(img, M, (<span class="number">400</span>, <span class="number">600</span>))</span><br><span class="line">cv2.imwrite(<span class="string">'lanka_safari_transformed.jpg'</span>, img_transformed)</span><br></pre></td></tr></table></figure><h2 id="opencv视频功能"><a href="#opencv视频功能" class="headerlink" title="opencv视频功能"></a>opencv视频功能</h2><p>视频中最常用的就是从视频设备采集图片或者视频，或者读取视频文件并从中采样。所以比较重要的也是两个模块，一个是VideoCapture，用于获取相机设备并捕获图像和视频，或是从文件中捕获。还有一个VideoWriter，用于生成视频。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">interval = <span class="number">60</span>           <span class="comment"># 捕获图像的间隔，单位：秒</span></span><br><span class="line">num_frames = <span class="number">500</span>        <span class="comment"># 捕获图像的总帧数</span></span><br><span class="line">out_fps = <span class="number">24</span>            <span class="comment"># 输出文件的帧率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VideoCapture(0)表示打开默认的相机</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取捕获的分辨率</span></span><br><span class="line">size =(int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)),</span><br><span class="line">       int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))</span><br><span class="line">       </span><br><span class="line"><span class="comment"># 设置要保存视频的编码，分辨率和帧率</span></span><br><span class="line">video = cv2.VideoWriter(</span><br><span class="line">    <span class="string">"time_lapse.avi"</span>, </span><br><span class="line">    cv2.VideoWriter_fourcc(<span class="string">'M'</span>,<span class="string">'P'</span>,<span class="string">'4'</span>,<span class="string">'2'</span>), </span><br><span class="line">    out_fps, </span><br><span class="line">    size</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于一些低画质的摄像头，前面的帧可能不稳定，略过</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">    cap.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始捕获，通过read()函数获取捕获的帧</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_frames):</span><br><span class="line">        _, frame = cap.read()</span><br><span class="line">        video.write(frame)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果希望把每一帧也存成文件，比如制作GIF，则取消下面的注释</span></span><br><span class="line">        <span class="comment"># filename = '&#123;:0&gt;6d&#125;.png'.format(i)</span></span><br><span class="line">        <span class="comment"># cv2.imwrite(filename, frame)</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">'Frame &#123;&#125; is captured.'</span>.format(i))</span><br><span class="line">        time.sleep(interval)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="comment"># 提前停止捕获</span></span><br><span class="line">    print(<span class="string">'Stopped! &#123;&#125;/&#123;&#125; frames captured!'</span>.format(i, num_frames))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放资源并写入视频文件</span></span><br><span class="line">video.release()</span><br><span class="line">cap.release()</span><br></pre></td></tr></table></figure><p>VideoWriter中的一个函数cv2.VideoWriter_fourcc()。这个函数指定了视频编码的格式，更多编码方式：<a href="http://www.fourcc.org/codecs.php" target="_blank" rel="noopener">http://www.fourcc.org/codecs.php</a></p><p>KeyboardInterrupt，这是一个常用的异常，用来获取用户Ctrl+C的中止，捕获这个异常后直接结束循环并释放VideoCapture和VideoWriter的资源，使已经捕获好的部分视频可以顺利生成。</p><h4 id="按照指定帧数截屏保存图片"><a href="#按照指定帧数截屏保存图片" class="headerlink" title="按照指定帧数截屏保存图片"></a>按照指定帧数截屏保存图片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个输入参数是包含视频片段的路径</span></span><br><span class="line">input_path = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个输入参数是设定每隔多少帧截取一帧</span></span><br><span class="line">frame_interval = int(sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出文件夹下所有的视频文件</span></span><br><span class="line">filenames = os.listdir(input_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文件夹名称</span></span><br><span class="line">video_prefix = input_path.split(os.sep)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立一个新的文件夹，名称为原文件夹名称后加上_frames</span></span><br><span class="line">frame_path = <span class="string">'&#123;&#125;_frames'</span>.format(input_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(frame_path):</span><br><span class="line">    os.mkdir(frame_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个VideoCapture对象</span></span><br><span class="line">cap = cv2.VideoCapture()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有文件</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">    filepath = os.sep.join([input_path, filename])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># VideoCapture::open函数可以从文件获取视频</span></span><br><span class="line">    cap.open(filepath)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取视频帧数</span></span><br><span class="line">    n_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 同样为了避免视频头几帧质量低下，黑屏或者无关等</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">        cap.read()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_frames):</span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每隔frame_interval帧进行一次截屏操作</span></span><br><span class="line">        <span class="keyword">if</span> i % frame_interval == <span class="number">0</span>:</span><br><span class="line">            imagename = <span class="string">'&#123;&#125;_&#123;&#125;_&#123;:0&gt;6d&#125;.jpg'</span>.format(video_prefix, filename.split(<span class="string">'.'</span>)[<span class="number">0</span>], i)</span><br><span class="line">            imagepath = os.sep.join([frame_path, imagename])</span><br><span class="line">            print(<span class="string">'exported &#123;&#125;!'</span>.format(imagepath))</span><br><span class="line">            cv2.imwrite(imagepath, frame)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结束释放资源</span></span><br><span class="line">cap.release()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OpenCV-python使用基础&quot;&gt;&lt;a href=&quot;#OpenCV-python使用基础&quot; class=&quot;headerlink&quot; title=&quot;OpenCV-python使用基础&quot;&gt;&lt;/a&gt;OpenCV-python使用基础&lt;/h1&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="OpenCV-python" scheme="http://yoursite.com/tags/OpenCV-python/"/>
    
  </entry>
  
  <entry>
    <title>Pandas使用基础</title>
    <link href="http://yoursite.com/2021/02/25/Python/Pandas%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/02/25/Python/Pandas使用基础/</id>
    <published>2021-02-25T08:18:58.000Z</published>
    <updated>2021-02-25T08:27:40.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pandas使用基础"><a href="#Pandas使用基础" class="headerlink" title="Pandas使用基础"></a>Pandas使用基础</h1><a id="more"></a><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h4><h5 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h5><p>Series类似一种一维数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">se2 = pd.Series(data=[<span class="number">4</span>, <span class="number">7</span>, <span class="number">-2</span>, <span class="number">8</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line">print(se2.values)    <span class="comment">#通过属性values获取内容</span></span><br><span class="line">print(se2.index)     <span class="comment">#通过index获取索引</span></span><br><span class="line">print(list(se2.iteritems()))    <span class="comment">#具有字典特性</span></span><br><span class="line"><span class="comment">#检测缺失数据</span></span><br><span class="line">pd.isnull(se2)  </span><br><span class="line">pd.notnull(se2)</span><br></pre></td></tr></table></figure><h5 id="Series对象存取"><a href="#Series对象存取" class="headerlink" title="Series对象存取"></a>Series对象存取</h5><p>Series对象下标运算可以同时支持位置和标签两种方式，同时支持位置切片和标签切片功能。</p><h5 id="Series运算"><a href="#Series运算" class="headerlink" title="Series运算"></a>Series运算</h5><p>支持Numpy数组运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(se2[se2&gt;<span class="number">0</span>])<span class="comment">#布尔数组过滤</span></span><br><span class="line">print(se2*<span class="number">2</span>)<span class="comment">#标量乘法</span></span><br><span class="line">print(np.exp(se2))<span class="comment">#数学运算</span></span><br><span class="line">print(se2+se3)<span class="comment">#操作符运算，前提相同标签元素才能运算，否则值为NaN</span></span><br></pre></td></tr></table></figure><h4 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h4><p>DataFrame是一个表格型的数据结构，既有行索引（保存在index），又有列索引（保存在columns）。</p><h5 id="常见属性方法"><a href="#常见属性方法" class="headerlink" title="常见属性方法"></a>常见属性方法</h5><p>调用DataFrame()可以将多种格式的数据转换为DataFrame对象，它的的三个参数data、index和columns分别为数据、行索引和列索引。data可以是，二维数组、字典、结构数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接传入一个等长列表或Numpy组成的字典。</span></span><br><span class="line">dict1=&#123;<span class="string">"Province"</span>:[<span class="string">"Guangdong"</span>,<span class="string">"Beijing"</span>,<span class="string">"Qinghai"</span>,<span class="string">"Fujiang"</span>],</span><br><span class="line">      <span class="string">"year"</span>:[<span class="number">2018</span>]*<span class="number">4</span>,</span><br><span class="line">      <span class="string">"pop"</span>:[<span class="number">1.3</span>,<span class="number">2.5</span>,<span class="number">1.1</span>,<span class="number">0.7</span>]&#125;</span><br><span class="line">df1=pd.DataFrame(dict1)</span><br><span class="line">print(df1)</span><br><span class="line"><span class="comment">#创建时指定序列</span></span><br><span class="line">df2=pd.DataFrame(dict1,columns=[<span class="string">'year'</span>,<span class="string">'Province'</span>,<span class="string">'pop'</span>,<span class="string">'debt'</span>],index=[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>])</span><br><span class="line">print(df2)</span><br><span class="line">print(df2.shape)    <span class="comment">#通过shape属性获取DataFrame的行数和列数</span></span><br><span class="line">print(df2.values)<span class="comment">#values属性通过ndarray形式返回DataFrame的数据</span></span><br></pre></td></tr></table></figure><h5 id="DataFrame转换为其他格式的数据"><a href="#DataFrame转换为其他格式的数据" class="headerlink" title="DataFrame转换为其他格式的数据"></a>DataFrame转换为其他格式的数据</h5><p>to_dict()转换为字典。</p><p>to_csv()转换为csv格式。</p><p>to_records()转换为记录格式。</p><h5 id="常见存取、赋值、删除"><a href="#常见存取、赋值、删除" class="headerlink" title="常见存取、赋值、删除"></a>常见存取、赋值、删除</h5><p><strong>DataFrame_object[ ]</strong> 能通过<strong>列索引</strong>来存取，当只有一个标签则返回Series，多于一个则返回DataFrame：</p><p><strong>DataFrame_object.loc[ ]</strong> 能通过<strong>行索引</strong>来获取指定行</p><h5 id="Index对象"><a href="#Index对象" class="headerlink" title="Index对象"></a>Index对象</h5><p>Index对象保存着索引标签数据，它可以快速找到标签对应的整数下标，其功能与Python的字典类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">col_index=df1.columns<span class="comment">#返回DataFrame对象所有的列索引</span></span><br><span class="line">col_index.values</span><br><span class="line">ind_index=df1.index<span class="comment">#返回DataFrame对象所有的列标签</span></span><br><span class="line">ind_index.values</span><br></pre></td></tr></table></figure><p>Index对象调用Index()来创建，可传递给DataFrame对象的参数index和columns。因为Index是不可变的，因此多个DataFrame对象的索引可以是同个Index对象。</p><p>Index对象可当做一维数组，适合Numpy数组的下标运算，但Index对象只是可读，创建后不可修改。</p><p>index对象具有字典的映射功能，<strong>.get_loc(value)</strong>获得单值得下标，<strong>.get_indexer(values)</strong>获得一组值得下标，当值不存在则返回-1：</p><h5 id="MultiIndex对象"><a href="#MultiIndex对象" class="headerlink" title="MultiIndex对象"></a>MultiIndex对象</h5><p>MultiIndex表示多级索引，从Index继承过来的，其中多级标签用元组对象来表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#元祖列表创建</span></span><br><span class="line">m_index1=pd.Index([(<span class="string">"A"</span>,<span class="string">"x1"</span>),(<span class="string">"A"</span>,<span class="string">"x2"</span>),(<span class="string">"B"</span>,<span class="string">"y1"</span>),(<span class="string">"B"</span>,<span class="string">"y2"</span>),(<span class="string">"B"</span>,<span class="string">"y3"</span>)],name=[<span class="string">"class1"</span>,<span class="string">"class2"</span>])</span><br><span class="line">print(m_index1)</span><br><span class="line">df1=pd.DataFrame(np.random.randint(<span class="number">1</span>,<span class="number">10</span>,(<span class="number">5</span>,<span class="number">4</span>)),index=m_index1)</span><br><span class="line">print(df1)</span><br><span class="line"><span class="comment">#特定结构创建</span></span><br><span class="line">class1=[<span class="string">"A"</span>,<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>]</span><br><span class="line">class2=[<span class="string">"x1"</span>,<span class="string">"x2"</span>,<span class="string">"y1"</span>,<span class="string">"y2"</span>]</span><br><span class="line">m_index2=pd.MultiIndex.from_arrays([class1,class2],names=[<span class="string">"class1"</span>,<span class="string">"class2"</span>])</span><br><span class="line">df2=DataFrame(np.random.randint(<span class="number">1</span>,<span class="number">10</span>,(<span class="number">4</span>,<span class="number">3</span>)),index=m_index2)</span><br><span class="line"><span class="comment">#笛卡尔积创建</span></span><br><span class="line">m_index3=pd.MultiIndex.from_product([[<span class="string">"A"</span>,<span class="string">"B"</span>],[<span class="string">'x1'</span>,<span class="string">'y1'</span>]],names=[<span class="string">"class1"</span>,<span class="string">"class2"</span>])</span><br><span class="line">df3=DataFrame(np.random.randint(<span class="number">1</span>,<span class="number">10</span>,(<span class="number">2</span>,<span class="number">4</span>)),columns=m_index3)</span><br></pre></td></tr></table></figure><p>MultiIndex对象属性，可通过get_loc()和get_indexer()获取标签的下标。</p><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h3 id="CSV文件处理"><a href="#CSV文件处理" class="headerlink" title="CSV文件处理"></a>CSV文件处理</h3><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pd.read_csv(filepath_or_buffer, sep=’,’, delimiter=<span class="literal">None</span>, header=’infer’, names=<span class="literal">None</span>, index_col=<span class="literal">None</span>, usecols=<span class="literal">None</span>, squeeze=<span class="literal">False</span>, converters=<span class="literal">None</span>, true_values=<span class="literal">None</span>, false_values=<span class="literal">None</span>, skiprows=<span class="literal">None</span>, nrows=<span class="literal">None</span>, na_values=<span class="literal">None</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">filepath_or_buffer：文件名、文件具体或相对路径、文件对象</span></span><br><span class="line"><span class="string">usecols：保留指定列</span></span><br><span class="line"><span class="string">sep、delimiter：俩者均为文件分割符号，或为正则表达式</span></span><br><span class="line"><span class="string">header：当文件中无列名需将其设为None</span></span><br><span class="line"><span class="string">names：结合header=None，读取时传入列名</span></span><br><span class="line"><span class="string">skiprows：忽略特定的行数</span></span><br><span class="line"><span class="string">nrows：读取一定行数</span></span><br><span class="line"><span class="string">na_values：一组将其值转换为NaN的特定值</span></span><br><span class="line"><span class="string">sueeze：返回Series对象</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">pd.read_csv(<span class="string">'test.csv'</span>,usecols=[<span class="number">0</span>,<span class="number">2</span>])<span class="comment">#保留指定列</span></span><br><span class="line"><span class="comment">#读取无列名文件，names为自行输入列名</span></span><br><span class="line">pd.read_csv(<span class="string">'test2.csv'</span>,header=<span class="literal">None</span>,names=[<span class="string">'k1'</span>,<span class="string">'k2'</span>,<span class="string">'value1'</span>,<span class="string">'value2'</span>])</span><br><span class="line"><span class="comment">#读入时，指定列为索引</span></span><br><span class="line">pd.read_csv(<span class="string">'test.csv'</span>,index_col=[<span class="string">'k1'</span>,<span class="string">'k2'</span>])</span><br><span class="line"><span class="comment">#从特定行读取，若第一行为列名，会被忽略</span></span><br><span class="line">pd.read_csv(<span class="string">'test2.csv'</span>,header=<span class="literal">None</span>,names=[<span class="string">'k1'</span>,<span class="string">'k2'</span>,<span class="string">'value1'</span>,<span class="string">'value2'</span>],skiprows=<span class="number">1</span>)</span><br><span class="line">pd.read_csv(<span class="string">'test.csv'</span>,nrows=<span class="number">3</span>)<span class="comment">#读取一定行数</span></span><br></pre></td></tr></table></figure><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">df1.to_csv(path_or_buf=<span class="literal">None</span>, sep=’,’, na_rep=”, float_format=<span class="literal">None</span>, columns=<span class="literal">None</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, mode=’w’, encoding=<span class="literal">None</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">path_or_buf：文件名、文件具体、相对路径、文件流等</span></span><br><span class="line"><span class="string">sep：文件分割符号</span></span><br><span class="line"><span class="string">na_rep：将NaN转换为特定值</span></span><br><span class="line"><span class="string">columns：选择部分列写入</span></span><br><span class="line"><span class="string">header：忽略列名</span></span><br><span class="line"><span class="string">index：False则选择不写入索引</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">df1.to_csv(sys.stdout,sep=<span class="string">'-'</span>)<span class="comment">#写入时指定分隔符</span></span><br><span class="line">df1.to_csv(sys.stdout,na_rep=<span class="string">'NULL'</span>)<span class="comment">#将NaN转为特定字符串</span></span><br><span class="line">df1.to_csv(sys.stdout,header=<span class="literal">None</span>)<span class="comment">#不写入列名</span></span><br><span class="line">df1.to_csv(sys.stdout,index=<span class="literal">False</span>)<span class="comment">#不写入索引</span></span><br><span class="line">df1.to_csv(sys.stdout,columns=[<span class="string">'B'</span>,<span class="string">'A'</span>])<span class="comment">#保留部分列且排序</span></span><br></pre></td></tr></table></figure><h3 id="Excel文件"><a href="#Excel文件" class="headerlink" title="Excel文件"></a>Excel文件</h3><h4 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pd.read_excel(io, sheet_name=<span class="number">0</span>, header=<span class="number">0</span>, skiprows=<span class="literal">None</span>, skip_footer=<span class="number">0</span>, index_col=<span class="literal">None</span>, names=<span class="literal">None</span>, usecols=<span class="literal">None</span>, parse_dates=<span class="literal">False</span>, date_parser=<span class="literal">None</span>, na_values=<span class="literal">None</span>, thousands=<span class="literal">None</span>, convert_float=<span class="literal">True</span>, converters=<span class="literal">None</span>, dtype=<span class="literal">None</span>, true_values=<span class="literal">None</span>, false_values=<span class="literal">None</span>, engine=<span class="literal">None</span>, squeeze=<span class="literal">False</span>, **kwds)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">filepath_or_buffer：文件名、文件具体或相对路径、文件流（open()函数打开等）</span></span><br><span class="line"><span class="string">usecols：保留指定列</span></span><br><span class="line"><span class="string">sep、delimiter：俩者均为文件分割符号，或为正则表达式</span></span><br><span class="line"><span class="string">header：当文件中无列名需将其设为None</span></span><br><span class="line"><span class="string">names：结合header=None，读取时传入列名</span></span><br><span class="line"><span class="string">skiprows：忽略特定的行数</span></span><br><span class="line"><span class="string">nrows：读取一定行数</span></span><br><span class="line"><span class="string">na_values：一组将其值转换为NaN的特定值</span></span><br><span class="line"><span class="string">sueeze：返回Series对象</span></span><br><span class="line"><span class="string">sheet_name：选择excel文件中的sheet表格，可为数值或string</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">pd.read_excel(<span class="string">'test4.xlsx'</span>)<span class="comment">#读取第一个sheet表格</span></span><br><span class="line"><span class="comment">#读取指定sheet表格</span></span><br><span class="line">pd.read_excel(<span class="string">'test4.xlsx'</span>,sheet_name=<span class="number">1</span>,header=<span class="literal">None</span>,names=[<span class="string">'k1'</span>,<span class="string">'k2'</span>,<span class="string">'value1'</span>,<span class="string">'value2'</span>])</span><br></pre></td></tr></table></figure><h4 id="写入-1"><a href="#写入-1" class="headerlink" title="写入"></a>写入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">df1.to_excel(excel_writer, sheet_name=’Sheet1’, na_rep=”, float_format=<span class="literal">None</span>, columns=<span class="literal">None</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, startrow=<span class="number">0</span>, startcol=<span class="number">0</span>, engine=<span class="literal">None</span>, merge_cells=<span class="literal">True</span>, encoding=<span class="literal">None</span>, inf_rep=’inf’, verbose=<span class="literal">True</span>, freeze_panes=<span class="literal">None</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">excel_writer：文件名、文件具体、相对路径、文件对象等</span></span><br><span class="line"><span class="string">sheet_name：写入时设定Sheetname，默认为’Sheet1’</span></span><br><span class="line"><span class="string">sep：文件分割符号</span></span><br><span class="line"><span class="string">na_rep：将NaN转换为特定值</span></span><br><span class="line"><span class="string">columns：选择部分列写入</span></span><br><span class="line"><span class="string">header：忽略列名</span></span><br><span class="line"><span class="string">index：False则选择不写入索引</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">df1.to_excel(<span class="string">'df1.xlsx'</span>)    <span class="comment"># 写入单个Sheet表格，只能写入一个Sheet表格，多次写入则会清除excel文件中的内容</span></span><br><span class="line">df1.to_excel(<span class="string">'df1.xlsx'</span>,sheet_name=<span class="string">'df1'</span>)    <span class="comment"># 指定Sheetname</span></span><br><span class="line"><span class="comment">#同一个Excel文件写入多个Sheet表格写入多个表时，需要用到pd.ExcelWriter()打开一个Excel文件</span></span><br><span class="line">work=pd.ExcelWriter(<span class="string">'df2.xlsx'</span>)</span><br><span class="line">df1.to_excel(work,sheet_name=<span class="string">'df2'</span>)</span><br><span class="line">df1[<span class="string">'A'</span>].to_excel(work,sheet_name=<span class="string">'df3'</span>)</span><br></pre></td></tr></table></figure><h2 id="pandas下标存取"><a href="#pandas下标存取" class="headerlink" title="pandas下标存取"></a>pandas下标存取</h2><h3 id="操作符"><a href="#操作符" class="headerlink" title="[ ]操作符"></a>[ ]操作符</h3><p>单列标签，多列标签，行、列索引整数切片</p><h3 id="loc-和-iloc-存取器"><a href="#loc-和-iloc-存取器" class="headerlink" title=".loc[ ]和.iloc[ ]存取器"></a>.loc[ ]和.iloc[ ]存取器</h3><p>.loc[y]/.iloc[y]：y可以是单个值，也可是多个值（列表），y代表行索引</p><p>.loc[y，x]/.iloc[y，x]：y代表行索引，x代表列索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df1.loc[<span class="string">'r1'</span>]<span class="comment">#单行</span></span><br><span class="line">df1.loc[[<span class="string">'r1'</span>,<span class="string">'r2'</span>]]<span class="comment">#多行</span></span><br><span class="line">df1.loc[[<span class="string">'r1'</span>,<span class="string">'r2'</span>],[<span class="string">'c1'</span>,<span class="string">'c3'</span>]]<span class="comment">#行列筛选</span></span><br></pre></td></tr></table></figure><p>.iloc[ ]与.loc[ ]相似，但不同的是，.iloc[ ]使用<strong>整数下标</strong>:</p><h3 id="ix-存取器"><a href="#ix-存取器" class="headerlink" title=".ix[ ]存取器"></a>.ix[ ]存取器</h3><p>.ix[ ]特点为综合了前面的，可以混用标签、位置下标存取。下标中，第一个为行索引，第二个为列索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1.ix[<span class="number">1</span>:<span class="number">3</span>,[<span class="string">'c1'</span>,<span class="string">'c3'</span>]]</span><br></pre></td></tr></table></figure><h3 id="获取单个值"><a href="#获取单个值" class="headerlink" title="获取单个值"></a>获取单个值</h3><p>.at[ ]和.iat[ ] 能使用标签和整数下标获取单个值。此外，推荐.get_value(),相比前面的更快。</p><h3 id="query-方法"><a href="#query-方法" class="headerlink" title="query()方法"></a>query()方法</h3><p>当需要筛选时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1[(df1.c1&gt;<span class="number">4</span>)&amp;(df1.c3&lt;<span class="number">5</span>)]</span><br><span class="line">df1.query(<span class="string">"c1&gt;4 and c3&lt;5"</span>)<span class="comment">#better</span></span><br></pre></td></tr></table></figure><h2 id="时间对象"><a href="#时间对象" class="headerlink" title="时间对象"></a>时间对象</h2><h3 id="时间点Timestamp"><a href="#时间点Timestamp" class="headerlink" title="时间点Timestamp"></a>时间点Timestamp</h3><p>Timestamp是从Python标准库的datetime类继承过来的，表示时间轴上的一个时刻。它提供了方便的时区转换功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">now=pd.Timestamp.now()</span><br><span class="line"><span class="comment">#2019-02-25 10:36:01.338081</span></span><br><span class="line">now_shanghai=now.tz_localize(<span class="string">"Asia/Shanghai"</span>)<span class="comment">#转换为指定的时区</span></span><br></pre></td></tr></table></figure><h3 id="时间段Period"><a href="#时间段Period" class="headerlink" title="时间段Period"></a>时间段Period</h3><p>Period表示一个标准的时间段。例如某年、某月、某日、某小时等。时间的长短由freq决定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">now_day=pd.Period.now(freq=<span class="string">"H"</span>)</span><br><span class="line">print(now_day)</span><br><span class="line">print(now_day.start_time)</span><br><span class="line">print(now_day.end_time)</span><br><span class="line"><span class="comment">#2019-02-25 10:00</span></span><br><span class="line"><span class="comment">#2019-02-25 10:00:00</span></span><br><span class="line"><span class="comment">#2019-02-25 10:59:59.999999999</span></span><br></pre></td></tr></table></figure><h3 id="时间间隔TImedetla"><a href="#时间间隔TImedetla" class="headerlink" title="时间间隔TImedetla"></a>时间间隔TImedetla</h3><p>通过调用<strong>pd.Timedelta()</strong>之间创建时间间隔Timedelta对象，Timedelta对象有属性：weeks、days、seconds、milliseconds、microseconds和nanoseconds等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">td=pd.Timedelta(weeks=<span class="number">2</span>,days=<span class="number">10</span>,hours=<span class="number">12</span>,minutes=<span class="number">2.4</span>,seconds=<span class="number">10.3</span>)</span><br><span class="line"><span class="comment">#24 days 12:02:34.300000</span></span><br></pre></td></tr></table></figure><h2 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h2><p>Timestamp、Period和Timedelta对象都是单个值，这些值都可以放在索引或数据中。作为索引的时间序列有：DatetimeIndex、PeriodIndex和TimedeltaIndex，它们都可以作为Series和DataFrame的索引。</p><h2 id="pandas其他方法"><a href="#pandas其他方法" class="headerlink" title="pandas其他方法"></a>pandas其他方法</h2><h3 id="ReIndex"><a href="#ReIndex" class="headerlink" title="ReIndex"></a>ReIndex</h3><p>reindex()作用是创建一个新索引的新对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1.reindex(index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>],columns=[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>],fill_value=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>传入<strong>method=” “</strong>重新索引时选择插值处理方式，传入<strong>fill_value=n</strong>用n代替缺失值。</p><h3 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h3><p>丢弃某轴上项，只要有一个索引表或者列表即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1.drop([<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">df1.drop([<span class="string">'x'</span>,<span class="string">'z'</span>],axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="Dropna"><a href="#Dropna" class="headerlink" title="Dropna"></a>Dropna</h3><p>pandas使用NaN作为缺失数据的标记。使用dropna使得滤除缺失数据更加容易。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df1=pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[NaN,NaN,<span class="number">2</span>],[NaN,NaN,NaN],[<span class="number">8</span>,<span class="number">8</span>,NaN]])</span><br><span class="line">df1.dropna(how=<span class="string">'all'</span>)<span class="comment">#清除全为NaN的行</span></span><br><span class="line">df1.dropna(axis=<span class="number">1</span>,how=<span class="string">"all"</span>)<span class="comment">#滤除列</span></span><br><span class="line">df1.dropna(thresh=<span class="number">1</span>)<span class="comment">#滤除n行</span></span><br></pre></td></tr></table></figure><h3 id="fillna"><a href="#fillna" class="headerlink" title="fillna"></a>fillna</h3><p>fillna()填充丢失数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df1.fillna(<span class="number">100</span>)<span class="comment">#使用常数</span></span><br><span class="line">df1.fillna(&#123;<span class="number">0</span>:<span class="number">10</span>,<span class="number">1</span>:<span class="number">20</span>,<span class="number">2</span>:<span class="number">30</span>&#125;)<span class="comment">#使用字典</span></span><br><span class="line">df1.fillna(<span class="number">0</span>,inplace=<span class="literal">True</span>)<span class="comment">#直接修改原对象</span></span><br><span class="line">df2.fillna(method=<span class="string">'ffill'</span>)<span class="comment">#用前面的值来填充，使用method插值方法</span></span><br><span class="line">df2.fillna(method=<span class="string">'bfill'</span>,limit=<span class="number">2</span>)<span class="comment">#limit限制填充个数</span></span><br><span class="line">df2.fillna(method=<span class="string">"ffill"</span>,limit=<span class="number">1</span>,axis=<span class="number">1</span>)<span class="comment">#axis修改填充方向</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>根据Series对象的<strong>索引</strong>、<strong>值</strong>排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">se1=pd.Series(np.arange(<span class="number">10</span>,<span class="number">13</span>),index=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>])<span class="comment">#数字索引</span></span><br><span class="line">se2=pd.Series(np.arange(<span class="number">0</span>,<span class="number">3</span>),index=[<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'a'</span>])<span class="comment">#字符索引</span></span><br><span class="line">se2.sort_index(ascending=<span class="literal">False</span>)<span class="comment">#降序</span></span><br><span class="line">se3=pd.Series([<span class="number">3</span>,<span class="number">-5</span>,<span class="number">7</span>])</span><br><span class="line">se3.sort_values()<span class="comment">#值排序</span></span><br></pre></td></tr></table></figure><p>DataFrame排序</p><p>通过<strong>axis参数</strong>可以对任意轴排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df1=pd.DataFrame(np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>),index=list(<span class="string">"bac"</span>),columns=list(<span class="string">"yzx"</span>))</span><br><span class="line">df1.sort_index(axis=<span class="number">1</span>)</span><br><span class="line">df2.sort_values(by=[<span class="string">'a'</span>,<span class="string">'b'</span>])</span><br></pre></td></tr></table></figure><h3 id="排名"><a href="#排名" class="headerlink" title="排名"></a>排名</h3><p>排名是根据Series对象或DataFrame的某几列的值进行排名，.rank(method=，ascending=,…)返回对值的排名。但需要十分注意如何处理出现相同的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">se5=pd.Series([<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>])<span class="comment">#平均排名</span></span><br><span class="line">se5.rank(method=<span class="string">"first"</span>)<span class="comment">#顺序排名</span></span><br><span class="line">se5.rank(method=<span class="string">"min"</span>,ascending=<span class="literal">False</span>)<span class="comment">#最小值排名</span></span><br><span class="line">se5.rank(method=<span class="string">"max"</span>,ascending=<span class="literal">False</span>)<span class="comment">#最大值排名</span></span><br><span class="line">se5.rank(method=<span class="string">"first"</span>,ascending=<span class="literal">False</span>)<span class="comment">#降序排名</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Pandas使用基础&quot;&gt;&lt;a href=&quot;#Pandas使用基础&quot; class=&quot;headerlink&quot; title=&quot;Pandas使用基础&quot;&gt;&lt;/a&gt;Pandas使用基础&lt;/h1&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Pandas" scheme="http://yoursite.com/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础概念</title>
    <link href="http://yoursite.com/2021/02/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2021/02/25/机器学习/机器学习基础概念/</id>
    <published>2021-02-25T07:09:28.000Z</published>
    <updated>2021-02-25T07:23:38.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习基础概念"><a href="#机器学习基础概念" class="headerlink" title="机器学习基础概念"></a>机器学习基础概念</h1><a id="more"></a><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><p>True Positive(真正，TP)：将正类预测为正类数</p><p>True Negative(真负，TN)：将负类预测为负类数</p><p>False Positive(假正，FP)：将负类预测为正类数误报 (Type I error)</p><p>False Negative(假负，FN)：将正类预测为负类数→漏报 (Type II error)</p><p><img src="/2021/02/25/机器学习/机器学习基础概念/20170426204227164.png" alt="img"></p><h3 id="Accuracy"><a href="#Accuracy" class="headerlink" title="Accuracy"></a>Accuracy</h3><p>准确率计算公式为：</p><p><img src="/2021/02/25/机器学习/机器学习基础概念/image-20210225150448670.png" alt="image-20210225150448670"></p><h3 id="Precision"><a href="#Precision" class="headerlink" title="Precision"></a>Precision</h3><p>精准率表示被分为正例的示例中实际为正例的比例。</p><p>在识别出来的图片中，True positives所占的比率。</p><p><img src="/2021/02/25/机器学习/机器学习基础概念/image-20210225150633442.png" alt="image-20210225150633442"></p><p>其中n代表的是（True positives + False positives），也就是系统一共识别出多少张照片。</p><h3 id="Recall"><a href="#Recall" class="headerlink" title="Recall"></a>Recall</h3><p>召回率是覆盖面的度量，度量有多少个正例被分为正例。</p><p>是被正确识别出来的飞机个数与测试集中所有飞机的个数的比值。</p><p><img src="/2021/02/25/机器学习/机器学习基础概念/image-20210225150510692.png" alt="image-20210225150510692"></p><p>Recall的分母是（true positives + False negatives），即可以理解为一共有多少张目标的总数。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>鲁棒性：处理缺失值和异常值的能力；</p><h2 id="向量点积、乘积"><a href="#向量点积、乘积" class="headerlink" title="向量点积、乘积"></a>向量点积、乘积</h2><h3 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h3><p>同线性代数中矩阵乘法的定义： A·B!=B·A。</p><p>计算方法：</p><p>1、np.dot()</p><p>2、A@B （python3）</p><h3 id="乘积"><a href="#乘积" class="headerlink" title="乘积"></a>乘积</h3><p>在Python中，实现对应元素相乘。</p><p>计算方法：</p><p>1、np.multiply()</p><p>2、A * B</p><h2 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h2><p>中心极限定理是统计学中比较重要的一个定理。 本文将通过实际模拟数据的形式，形象地展示中心极限定理是什么，是如何发挥作用的。</p><h3 id="什么是中心极限定理（Central-Limit-Theorem）"><a href="#什么是中心极限定理（Central-Limit-Theorem）" class="headerlink" title="什么是中心极限定理（Central Limit Theorem）"></a>什么是中心极限定理（Central Limit Theorem）</h3><p><strong>定义</strong>：中心极限定理指的是给定一个任意分布的总体。我每次从这些总体中随机抽取 n 个抽样，一共抽 m 次。 然后把这 m 组抽样分别求出平均值。 这些平均值的分布接近正态分布</p><p>举例：<em>现在我们要统计全国的人的体重，看看我国平均体重是多少。当然，我们把全国所有人的体重都调查一遍是不现实的。所以我们打算一共调查1000组，每组50个人。 然后，我们求出第一组的体重平均值、第二组的体重平均值，一直到最后一组的体重平均值。中心极限定理说：这些平均值是呈现正态分布的。并且，随着组数的增加，效果会越好。 最后，当我们再把1000组算出来的平均值加起来取个平均值，这个平均值会接近全国平均体重。</em></p><p>其中要注意的几点：</p><ol><li><strong>总体本身的分布不要求正态分布</strong><br>上面的例子中，人的体重是正态分布的。但如果我们的例子是掷一个骰子（平均分布），最后每组的平均值也会组成一个正态分布。（神奇！）</li><li><strong>样本每组要足够大，但也不需要太大</strong><br>取样本的时候，一般认为，每组大于等于30个，即可让中心极限定理发挥作用。</li></ol><h3 id="掷骰子Python示例"><a href="#掷骰子Python示例" class="headerlink" title="掷骰子Python示例"></a>掷骰子Python示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">random_data = np.random.randint(<span class="number">1</span>, <span class="number">7</span>, <span class="number">10000</span>)</span><br><span class="line">print(random_data.mean()) <span class="comment"># 打印平均值</span></span><br><span class="line">print(random_data.std())  <span class="comment"># 打印标准差</span></span><br><span class="line"></span><br><span class="line">samples = []</span><br><span class="line">samples_mean = []</span><br><span class="line">samples_std = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">1000</span>):</span><br><span class="line">    sample = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">50</span>):</span><br><span class="line">        sample.append(random_data[int(np.random.random() * len(random_data))])</span><br><span class="line">    sample_np = np.array(sample)</span><br><span class="line">    samples_mean.append(sample_np.mean())</span><br><span class="line">    samples_std.append(sample_np.std())</span><br><span class="line">    samples.append(sample_np)</span><br><span class="line"></span><br><span class="line">samples_mean_np = np.array(samples_mean)</span><br><span class="line">samples_std_np = np.array(samples_std)</span><br><span class="line"></span><br><span class="line">plt.hist(samples_mean_np, bins=<span class="number">40</span>, normed=<span class="number">0</span>, facecolor=<span class="string">"blue"</span>, edgecolor=<span class="string">"black"</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line"><span class="comment"># 显示横轴标签</span></span><br><span class="line">plt.xlabel(<span class="string">"X"</span>)</span><br><span class="line"><span class="comment"># 显示纵轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">"Y"</span>)</span><br><span class="line"><span class="comment"># 显示图标题</span></span><br><span class="line">plt.title(<span class="string">"X/Y"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;机器学习基础概念&quot;&gt;&lt;a href=&quot;#机器学习基础概念&quot; class=&quot;headerlink&quot; title=&quot;机器学习基础概念&quot;&gt;&lt;/a&gt;机器学习基础概念&lt;/h1&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Git使用基础</title>
    <link href="http://yoursite.com/2021/02/25/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3/Git%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/02/25/软件工程相关/Git使用基础/</id>
    <published>2021-02-25T03:03:15.000Z</published>
    <updated>2021-02-25T06:53:40.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git使用基础"><a href="#Git使用基础" class="headerlink" title="Git使用基础"></a>Git使用基础</h1><a id="more"></a><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>  什么是版本控制？我真的需要吗？版本控制是一种记录若干文件内容变化，以便将来查阅特定版本修订情况的系统。在本书所展示的例子中，我们仅对保存着软件源代码的文本文件作版本控制管理，但实际上，你可以对任何类型的文件进行版本控制。</p><p>  如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能）。采用版本控制系统 （VCS）是个明智的选择。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。你可以比较文件的变化细节，查出最 后是谁修改了哪个地方，从而导致出现怪异问题，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改 的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p><h4 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a>本地版本控制</h4><p>  许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。</p><p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p><p>其中最流行的一种叫做 rcs，现今许多计算机系统上都还看得到它的踪影。甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。它的工作原理基本上就是保存并管理文件补丁（patch）。文件补丁是一种特定格式的文本文件，记录着对应文件修订前后的内容变化。所以，根据每次 修订后的补丁，rcs 可以通过不断打补丁，计算出各个版本的文件内容。</p><p><img src="/2021/02/25/软件工程相关/Git使用基础/20120201121201_805.png" alt="Git详解之一 Git起步 "></p><h4 id="集中化的版本控制系统"><a href="#集中化的版本控制系统" class="headerlink" title="集中化的版本控制系统"></a>集中化的版本控制系统</h4><p>  人们又遇到一个问题，如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生。这类系统，诸如 CVS，Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法（见下图）。</p><p>  这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>  事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要 是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就还是会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端 提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。本地版本控制系统也存在类似问题，只要整个项 目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p><p><img src="/2021/02/25/软件工程相关/Git使用基础/20120201121201_94.png" alt="Git详解之一 Git起步 "></p><h4 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h4><p>  分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世了。在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜 像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份（见下图）。</p><p>  更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p><p><img src="/2021/02/25/软件工程相关/Git使用基础/20120201121202_798.png" alt="Git详解之一 Git起步 "></p><p>　　事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要 是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就还是会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端 提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。本地版本控制系统也存在类似问题，只要整个项 目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p><h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><h3 id="Git工作方式"><a href="#Git工作方式" class="headerlink" title="Git工作方式"></a>Git工作方式</h3><p>  Git 是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照 的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。Git 的工作方式如图所示。</p><p><img src="/2021/02/25/软件工程相关/Git使用基础/20120201121204_39.png" alt="Git详解之一 Git起步 "></p><h3 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h3><p>1、在工作目录中修改某些文件。</p><p>2、 对修改后的文件进行快照，然后保存到暂存区域。</p><p>3、 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</p><p>  所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就 是已修改状态。到第二章的时候，我们会进一步了解其中细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。</p><p>在正式使用前，我们还需要弄清楚Git的三种重要模式，分别是<strong>已提交、已修改、已暂存</strong>。</p><p><img src="/2021/02/25/软件工程相关/Git使用基础/20120201121205_151.png" alt="Git详解之一 Git起步 "></p><ul><li>已提交(committed):表示数据文件已经顺利提交到Git数据库中。</li><li>已修改(modified):表示数据文件已经被修改，但未被保存到Git数据库中。</li><li>已暂存(staged):表示数据文件已经被修改，并会在下次提交时提交到Git数据库中。</li></ul><h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><h3 id="Git初始化"><a href="#Git初始化" class="headerlink" title="Git初始化"></a>Git初始化</h3><p>  <strong>git clone</strong>: 这是较为简单的一种初始化方式，当你已经有一个远程的Git版本库，只需要在本地克隆一份，例如’git clone git://github.com/someone/some_project.git some_project’命令就是将’git://github.com/someone/some_project.git’这个URL地址的远程版 本库完全克隆到本地some_project目录下面</p><p>   <strong>git init</strong>和<strong>git remote</strong>：这种方式稍微复杂一些，当你本地创建了一个工作目录，你可以进入这个目录，使用 git init 命令进行初始化，Git以后就会对该目录下的文件进行版本控制，这时候如果你需要将它放到远程服务器上，可以在远程服务器上创建一个目录，并把 可访问的URL记录下来，此时你就可以利用 git remote add 命令来增加一个远程服务器端，例如’git remote add origin git://github.com/someone/another_project.git’这条命令就会增加URL地址为’git: //github.com/someone/another_project.git’，名称为origin的远程服务器，以后提交代码的时候只需要使用 origin别名即可。</p><h3 id="Git基本命令"><a href="#Git基本命令" class="headerlink" title="Git基本命令"></a>Git基本命令</h3><p>​        <strong>git pull</strong>：从版本库(既可以是远程的也可以是本地的)将<strong>代码更新到本地</strong>，例如：’git pull origin master’就是将origin这个版本库的代码更新到本地的master主枝，该功能类似于SVN的update</p><p>​        <strong>git add</strong>：将所有改动的文件（新增和有变动的）<strong>放在暂存区，由git进行管理</strong>。</p><p>​        <strong>git rm</strong>：从当前的工作空间中和索引中删除文件，例如’git rm app/model/user.rb’，<strong>移除暂存区</strong>。</p><p>​        <strong>git commit</strong>：提交当前工作空间的修改内容，类似于SVN的commit命令，例如’<strong>git commit -m</strong> “story #3, add user model”‘，提交的时候必须用-m来输入一条提交信息。</p><p>​        <strong>git push</strong>：将本地commit的代码更新到远程版本库中，例如’<strong>git push origin branchname</strong>‘就会将本地的代码更新到名为orgin的远程版本库中。</p><p>​        <strong>git log</strong>：查看历史日志。</p><p>​        <strong>git revert</strong>：<strong>还原一个版本的修改</strong>，必须提供一个具体的Git版本号，例如’git revert bbaf6fb5060b4875b18ff9ff637ce118256d6f20’，Git的版本号都是生成的一个哈希值。</p><h3 id="Git-独有命令"><a href="#Git-独有命令" class="headerlink" title="Git 独有命令"></a>Git 独有命令</h3><p>​         <strong>git branch</strong>：对分支的增、删、查等操作，例如 git branch new_branch 会从当前的工作版本创建一个叫做new_branch的新分支，git branch -D new_branch 就会强制删除叫做new_branch的分支，git branch 就会列出本地所有的分支。</p><p>​          <strong>git checkout</strong>：Git的checkout有两个作用，其一是在 不同的branch之间进行切换，例如 ‘git checkout new_branch’就会切换到new_branch的分支上去;另一个功能是 还原代码的作用，例如git checkout app/model/user.rb 就会将user.rb文件从上一个已提交的版本中更新回来，未提交的内容全部会回滚</p><p>​          <strong>git rebase</strong>：用下面两幅图解释会比较清楚一些，rebase命令执行后，实际上是将分支点从C移到了G，这样分支也就具有了从C到G的功能 （使历史更加简洁明了）</p><p>​                       <img src="/2021/02/25/软件工程相关/Git使用基础/20120328111440_202.png" alt="Git使用基础篇 "></p><p>​          <strong>git reset</strong>：回滚到指定的版本号，我们有A-G提交的版本，其中C 的版本号是 bbaf6fb，我们执行了’git reset bbaf6fb’那么结果就只剩下了A-C三个提交的版本</p><p>​                        <img src="/2021/02/25/软件工程相关/Git使用基础/20120328111443_111.png" alt="Git使用基础篇 "></p><p>​          <strong>git stash</strong>：将当前未提交的工作存入Git工作栈中，时机成熟的时候再应用回来，这里暂时提一下这个命令的用法，后面在技巧篇会重点讲解</p><p>​          <strong>git config</strong>：新增、更改Git的各种设置，例如：git config branch.master.remote origin 就将master的远程版本库设置为别名叫做origin版本库</p><p>​          <strong>git tag</strong>：将某个版本打上一个标签，例如：git tag revert_version bbaf6fb50 来标记这个被你还原的版本，那么以后你想查看该版本时，就可以使用 revert_version标签名，而不是哈希值。</p><h3 id="Git其它命令"><a href="#Git其它命令" class="headerlink" title="Git其它命令"></a>Git其它命令</h3><p>​        <strong>add</strong>         #添加文件内容至索引</p><p>　　<strong>branch</strong>      #列出、创建或删除分支</p><p>　　<strong>checkout</strong>     #检出一个分支或路径到工作区</p><p>　　<strong>clone</strong>       #克隆一个版本库到一个新目录</p><p>　　<strong>commit</strong>  　#最近一次的提交，–amend修改最近一次提交说明</p><p>　　<strong>diff</strong>        #显示提交之间、提交和工作区之间等的差异　　</p><p>　　<strong>fetch</strong>       #从另外一个版本库下载对象和引用　</p><p>　　<strong>init</strong>        #创建一个空的 Git 版本库或重新初始化一个已存在的版本库</p><p>　　<strong>log</strong>         #显示提交日志 –stat 具体文件的改动</p><p>　　<strong>reflog</strong>　　　　#记录丢失的历史</p><p>　　<strong>merge</strong>      #合并两个或更多开发历史，–squash 把分支所有提交合并成一个提交</p><p>　　<strong>mv</strong>         #移动或重命名一个文件、目录或符号链接</p><p>　　<strong>pull</strong>        #获取并合并另外的版本库或一个本地分支（相当于git fetch和git merge）</p><p>　　<strong>push</strong>         #更新远程引用和相关的对象　　</p><p>　　<strong>rebase</strong>       #本地提交转移至更新后的上游分支中</p><p>　　<strong>reset</strong>         #重置当前HEAD到指定状态</p><p>　　<strong>rm</strong>         #从工作区和索引中删除文件</p><p>　　<strong>show</strong>        #显示各种类型的对象</p><p>　　<strong>status</strong>        #显示工作区状态</p><p>　　<strong>tag</strong>         #创建、列出、删除或校验一个GPG签名的 tag 对象 </p><p>　　<strong>cherry-pick</strong> #从其他分支复制指定的提交，然后导入到现在的分支</p><h3 id="git目录结构"><a href="#git目录结构" class="headerlink" title=".git目录结构"></a>.git目录结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HEAD</span><br><span class="line">branches/</span><br><span class="line">config</span><br><span class="line">description</span><br><span class="line">hooks/</span><br><span class="line">index</span><br><span class="line">info/</span><br><span class="line">objects/</span><br><span class="line">refs/</span><br></pre></td></tr></table></figure><p>重要的文件和目录需要解释如下：</p><p>　　 <strong>HEAD</strong>：文件存放根节点的信息，其实目录结构就表示一个树型结构，Git采用这种树形结构来存储版本信息， 那么HEAD就表示根;</p><p>　　 <strong>refs</strong>：目录存储了你在当前版本控制目录下的各种不同引用(引用指的是你本地和远程所用到的各个树分支的信息)，它有heads、 remotes、stash、tags四个子目录，分别存储对不同的根、远程版本库、Git栈和标签的四种引用，你可以通过命令’git show-ref’更清晰地查看引用信息;</p><p>　　 <strong>logs</strong>：目录根据不同的引用存储了日志信息。因此，Git只需要代码根目录下的这一个.git目录就可以记录完 整的版本控制信息，而不是像SVN那样根目录和子目录下都有.svn目录。那么下面就来看一下Git与SVN的区别吧</p><p>　　 <strong>.gitigmore:</strong> 放一些不需要git管理的文件（例：IDE的工作目录 .idea）</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir myfile</span><br><span class="line"><span class="built_in">cd</span> myfile</span><br><span class="line">git init</span><br><span class="line">git add codefile</span><br><span class="line">git commit -m <span class="string">"your description"</span></span><br></pre></td></tr></table></figure><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">git reset --hard commit_code</span><br><span class="line">git reflog <span class="comment">#查看历史操作记录</span></span><br></pre></td></tr></table></figure><h4 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h4><p>工作区（Working directory）：工作目录文件夹</p><p>版本库（Repository）：隐藏目录<code>.git</code>是<code>Git</code>版本库，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p>版本添加，1、先通过<code>add</code>将文件添加到暂存区，2、再通过<code>commit</code>往当前<code>master</code>分区上提交更改</p><p><img src="/2021/02/25/软件工程相关/Git使用基础/0.jpg" alt="git-repo"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status<span class="comment"># 查看当前状态</span></span><br></pre></td></tr></table></figure><h4 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h4><p>如果修改文件<code>add</code>后，再次修改文件，然后<code>commit</code>提交，后面修改的文件未被添加到当前版本库，需要再次添加提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD -- readme.txt <span class="comment">#查看工作区和版本库里面最新版本区别</span></span><br></pre></td></tr></table></figure><h4 id="撤消修改"><a href="#撤消修改" class="headerlink" title="撤消修改"></a>撤消修改</h4><p>让文件回到最近一次<code>add</code>或则<code>commit</code>的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git check -- filename <span class="comment">#使文件复原，撤销修改</span></span><br><span class="line">git reset HEAD filename <span class="comment">#文件add后，重新放回工作区</span></span><br></pre></td></tr></table></figure><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p><p><code>git checkout</code><strong>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm filename</span><br><span class="line">git rm filename</span><br><span class="line">git checkout -- filename <span class="comment">#撤销删除</span></span><br></pre></td></tr></table></figure><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="从本地关联远程库"><a href="#从本地关联远程库" class="headerlink" title="从本地关联远程库"></a>从本地关联远程库</h4><p>将本地git仓库与远程github仓库同步，关联一个远程库。</p><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。只要本地作了提交，都可以通过以下命令将本地仓库推送到远程端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@server-name:path/repo-name.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h4 id="从远程库克隆代码库"><a href="#从远程库克隆代码库" class="headerlink" title="从远程库克隆代码库"></a>从远程库克隆代码库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:mingrongchen/Algorithm.git</span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>时间线串成一条分支,用<code>git log --graph</code>命令可以看到分支合并图，使用<code>Fast forward</code>策略，合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并。若分支存在冲突不能快速合并，则解决冲突后再合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b newbranch</span><br><span class="line"><span class="comment">#-b代表创建并切换到当前分支，相当于</span></span><br><span class="line"><span class="comment">#git branch newbranch ，创建分支</span></span><br><span class="line"><span class="comment">#git checkout newbranch， 切换分支</span></span><br><span class="line">git branch <span class="comment">#查看分支</span></span><br><span class="line"><span class="comment"># 切换到主分支</span></span><br><span class="line">git merge newbranch<span class="comment">#在主分支合并新的分支</span></span><br><span class="line">git branch -d newbranch<span class="comment">#合并后删除分支</span></span><br></pre></td></tr></table></figure><h4 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h4><p>若当前工作未完成，需要解决一个bug分支，可以使用<code>stash</code>功能，将当前工作区隐藏，解决完bug分支后，再恢复现场继续工作。如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git stash  <span class="comment">#隐藏当前分支</span></span><br><span class="line"><span class="comment">#解决bug</span></span><br><span class="line">git checkout master <span class="comment">#在主分支上创建bug分支</span></span><br><span class="line">git checkout -b issue-101<span class="comment">#创建bug分支，一系列代码提交</span></span><br><span class="line">git checkout master <span class="comment">#切换回主分支，合并bug分支</span></span><br><span class="line">git merge --no-ff -m <span class="string">"merge bug fix 101"</span> issue-101</span><br><span class="line"></span><br><span class="line">git checkout myworkstation<span class="comment">#切换回自己当前分支</span></span><br><span class="line">git stash apply <span class="comment">#恢复当前内容or git stash pop 恢复后删除stash内容</span></span><br><span class="line">git stash list <span class="comment"># 查看stash内容</span></span><br><span class="line">git stash apply stash@&#123;0&#125; <span class="comment">#恢复指定stash，工作区</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git使用基础&quot;&gt;&lt;a href=&quot;#Git使用基础&quot; class=&quot;headerlink&quot; title=&quot;Git使用基础&quot;&gt;&lt;/a&gt;Git使用基础&lt;/h1&gt;
    
    </summary>
    
      <category term="软件工程相关" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux之Shell脚本基础</title>
    <link href="http://yoursite.com/2021/02/23/Linux%E7%9B%B8%E5%85%B3/Linux%E4%B9%8BShell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/02/23/Linux相关/Linux之Shell脚本基础/</id>
    <published>2021-02-23T05:35:04.000Z</published>
    <updated>2021-02-23T07:03:01.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux之Shell脚本基础"><a href="#Linux之Shell脚本基础" class="headerlink" title="Linux之Shell脚本基础"></a>Linux之Shell脚本基础</h1><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Shell脚本（Shell script），是一种为shell编写的脚本程序 ，是一种解释器语言，与JavaScript、python、php类似。</p><h2 id="Shell脚本编程"><a href="#Shell脚本编程" class="headerlink" title="Shell脚本编程"></a>Shell脚本编程</h2><h3 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi script.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 内容</span><br><span class="line">echo "My first script ..."</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 运行脚本</span><br><span class="line">chmod a+x script.sh</span><br><span class="line">./script.sh</span><br></pre></td></tr></table></figure><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 注释：使用#开头</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 变量使用</span><br><span class="line">VAR="test"</span><br><span class="line">echo "$VAR"</span><br><span class="line">echo "$&#123;VAR&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 可以把命令执行后的输入结果赋值给一个变量</span><br><span class="line">LIST=$(ls)</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试主要用于条件判断。<code>[ condition-to-test-for ]</code> ，如<code>[ -e /etc/passwd ]</code>，注意的是<code>[]</code><strong>前后必须有空格</strong>，如<code>[-e /etc/passwd]</code>是错误的写法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 文件测试</span><br><span class="line">-d FILE_NAM  # True if FILE_NAM is a directory 是否目录</span><br><span class="line">-e FILE_NAM  # True if FILE_NAM exists 文件是否存在</span><br><span class="line">-f FILE_NAM  # True if FILE_NAM exists and is a regular file 文件是否存在且是普通文件</span><br><span class="line">-r FILE_NAM  # True if FILE_NAM is readable 文件是否可读</span><br><span class="line">-s FILE_NAM  # True if FILE_NAM exists and is not empty 文件是否存在且不为空</span><br><span class="line">-w FILE_NAM  # True if FILE_NAM has write permission 文件是否有可写权限</span><br><span class="line">-x FILE_NAM  # True if FILE_NAM is executable 文件是否可执行</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 字符串测试</span><br><span class="line">-z STRING  # True if STRING is empty</span><br><span class="line">-n STRING  # True if STRING is not empty</span><br><span class="line">STRING1 = STRIN2 # True if strings are equal</span><br><span class="line">STRING1 != STRIN2 # True if strings are not equal</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 算术测试</span><br><span class="line">var1 -eq var2  # True if var1 is equal to var2 等于</span><br><span class="line">var1 -ne var2  # True if var1 not equal to var2 不等于</span><br><span class="line">var1 -lt var2  # True if var1 is less than var2 小于</span><br><span class="line">var1 -le var2  # True if var1 is less than or equal to var2 小于等于</span><br><span class="line">var1 -gt var2  # True if var1 is greater than var2 大于</span><br><span class="line">var1 -ge var2  # True if var1 is greater than or equal to var2 大于等于</span><br></pre></td></tr></table></figure><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>注意：判断语句中[]两边仅左右空格，且中间语句不要有空格。</p><h4 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if-elif-else语句"></a>if-elif-else语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if [ condition-is-true ]</span><br><span class="line">then</span><br><span class="line">  command 1</span><br><span class="line">elif [ condition-is-true ]</span><br><span class="line">then</span><br><span class="line">  command 2</span><br><span class="line">elif [ condition-is-true ]</span><br><span class="line">then</span><br><span class="line">  command 3</span><br><span class="line">else</span><br><span class="line">  command 4</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 示例</span><br><span class="line">if [ $1="one" ]</span><br><span class="line">then</span><br><span class="line">        echo "one"</span><br><span class="line">elif [ $1="two" ]</span><br><span class="line">then</span><br><span class="line">        echo "two"</span><br><span class="line">else</span><br><span class="line">        echo "none"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">case "$VAR" in</span><br><span class="line">  pattern_1)</span><br><span class="line">    # commands when $VAR matches pattern 1</span><br><span class="line">    ;;</span><br><span class="line">  pattern_2)</span><br><span class="line">    # commands when $VAR matches pattern 2</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    # This will run if $VAR doesnt match any of the given patterns</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 示例</span><br><span class="line">case "$1" in</span><br><span class="line">        [yY] | [yY][eE][sS])</span><br><span class="line">                echo "Yes"</span><br><span class="line">                ;;</span><br><span class="line">        [nN] | [nN][oO])</span><br><span class="line">                echo "No"</span><br><span class="line">                ;;</span><br><span class="line">        *)</span><br><span class="line">                echo "none"</span><br><span class="line">                ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>((表达;条件;末尾循环))，注意是两个括号，否则会报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">for VARIABLE_NAME in ITEM_1 ITEM_N</span><br><span class="line">do</span><br><span class="line">  command 1</span><br><span class="line">  command 2</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  command N</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for (( VAR=1;VAR&lt;N;VAR++ ))</span><br><span class="line">do</span><br><span class="line">  command 1</span><br><span class="line">  command 2</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  command N</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 示例一</span><br><span class="line">COLORS="red green blue"</span><br><span class="line">for COLOR in $COLORS</span><br><span class="line">do</span><br><span class="line">        echo "The color is: $&#123;COLOR&#125;"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>示例二</span><br><span class="line">for (( VAR=0;VAR&lt;3;VAR++ ))</span><br><span class="line">do</span><br><span class="line">        echo "VAR is : $&#123;VAR&#125;"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">while [ CONNDITION_IS_TRUE ]</span><br><span class="line">do</span><br><span class="line"><span class="meta">  #</span> Commands will change he entry condition</span><br><span class="line">  command 1</span><br><span class="line">  command 2</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  command N</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 示例</span><br><span class="line">VAR_TWO=0</span><br><span class="line">while [ $VAR_TWO -le 3 ]</span><br><span class="line">do</span><br><span class="line">        echo "VAR_TWO is : $&#123;VAR_TWO&#125;"</span><br><span class="line">        ((VAR_TWO++))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>当我们运行脚本的时候，可以传递参数供脚本内部使用<code>$ ./script.sh param1 param2 param3 param4</code>这些参数将被存储在特殊的变量中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>0 -- "script.sh"</span><br><span class="line"><span class="meta">$</span>1 -- "param1"</span><br><span class="line"><span class="meta">$</span>2 -- "param2"</span><br><span class="line"><span class="meta">$</span>3 -- "param3"</span><br><span class="line"><span class="meta">$</span>4 -- "param4"</span><br><span class="line"><span class="meta">$</span># -- 代表参数个数</span><br><span class="line"><span class="meta">$</span>@ -- array of all positional parameters "param1""param2""param3""param4"</span><br><span class="line"><span class="meta">$</span>* -- 代表"param1 param2 param3 param4"，整体中间以空格分开</span><br></pre></td></tr></table></figure><h4 id="退出码"><a href="#退出码" class="headerlink" title="退出码"></a>退出码</h4><p>可以自定义</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exit 0</span><br><span class="line">exit 1</span><br><span class="line">exit 2</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">exit 255</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>可以把一些列的命令或语句定义在一个函数内，从程序的其他地方调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function function_name() &#123;</span><br><span class="line">    command 1</span><br><span class="line">    command 2</span><br><span class="line">    command 3</span><br><span class="line">      ...</span><br><span class="line">      ...</span><br><span class="line">    command N</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 示例</span><br><span class="line">function myFunc () &#123;</span><br><span class="line">        echo "My function ..."</span><br><span class="line">        if [ $# -eq 1 ]</span><br><span class="line">        then</span><br><span class="line">                echo "My function one"</span><br><span class="line">                return $[$#]</span><br><span class="line">        elif [ $# -eq 2 ]</span><br><span class="line">        then</span><br><span class="line">                echo "My function two"</span><br><span class="line">                return $[$#]</span><br><span class="line">        else</span><br><span class="line">                echo "My function none"</span><br><span class="line">                return $[$#]</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line">myFunc</span><br><span class="line">echo "one is : $?"</span><br><span class="line">myFunc one</span><br><span class="line">echo "two is : $?"</span><br><span class="line">myFunc one two</span><br><span class="line">echo "three is : $?"</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux之Shell脚本基础&quot;&gt;&lt;a href=&quot;#Linux之Shell脚本基础&quot; class=&quot;headerlink&quot; title=&quot;Linux之Shell脚本基础&quot;&gt;&lt;/a&gt;Linux之Shell脚本基础&lt;/h1&gt;
    
    </summary>
    
      <category term="Linux相关" scheme="http://yoursite.com/categories/Linux%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Shell脚本" scheme="http://yoursite.com/tags/Shell%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Linux之ps命令</title>
    <link href="http://yoursite.com/2021/02/23/Linux%E7%9B%B8%E5%85%B3/Linux%E4%B9%8Bps%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2021/02/23/Linux相关/Linux之ps命令/</id>
    <published>2021-02-23T02:41:48.000Z</published>
    <updated>2021-02-23T02:49:19.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux之ps命令"><a href="#Linux之ps命令" class="headerlink" title="Linux之ps命令"></a>Linux之ps命令</h1><a id="more"></a><p>ps命令为我们提供了一次性的查看进程结果，它所提供的查看结果不是动态连续的；如果想对进程时间监控，应该用top工具</p><p>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p><p><strong>linux上进程有5种状态:</strong> </p><p>1、运行(正在运行或在运行队列中等待) </p><p>2、中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) </p><p>3、不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) </p><p>4、僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) </p><p>5、停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) </p><p><strong>ps工具标识进程的5种状态码:</strong> </p><p>1、D 不可中断 uninterruptible sleep (usually IO) </p><p>2、R 运行 runnable (on run queue) </p><p>3、S 中断 sleeping </p><p>4、T 停止 traced or stopped </p><p>5、Z 僵死 a defunct (”zombie”) process</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 3．命令参数：</span><br><span class="line">a  显示所有进程</span><br><span class="line">-a 显示同一终端下的所有程序</span><br><span class="line">-A 显示所有进程</span><br><span class="line">c  显示进程的真实名称</span><br><span class="line">-N 反向选择</span><br><span class="line">-e 等于“-A”</span><br><span class="line">e  显示环境变量</span><br><span class="line">f  显示程序间的关系</span><br><span class="line">-H 显示树状结构</span><br><span class="line">r  显示当前终端的进程</span><br><span class="line">T  显示当前终端的所有程序</span><br><span class="line">u  指定用户的所有进程</span><br><span class="line">-au 显示较详细的资讯</span><br><span class="line">-aux 显示所有包含其他使用者的行程 </span><br><span class="line">-C&lt;命令&gt; 列出指定命令的状况</span><br><span class="line">--lines&lt;行数&gt; 每页显示的行数</span><br><span class="line">--width&lt;字符数&gt; 每页显示的字符数</span><br><span class="line">--help 显示帮助信息</span><br><span class="line">--version 显示版本显示</span><br><span class="line">-o 自定义输出字段 我们设定显示字段为 stat（状态）, ppid（进程父id）, pid(进程id)，cmd（命令）这四个参数</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 用例</span><br><span class="line">ps -A    # 显示所有进程信息</span><br><span class="line">ps -u root    # 显示指定用户信息</span><br><span class="line">ps -ef    # 显示所有进程信息</span><br><span class="line">ps -ef | grep ssh    # ps与grep常用组合用法，查找指定进程</span><br><span class="line">ps -l    # 将目前属于您自己这次登入的PID与相关信息列出来</span><br><span class="line">ps -aux    # 列出目前所有正在内存中的程序</span><br><span class="line">ps -axjf    # 列出类似程序树的程序显示</span><br><span class="line">ps -aux |more    # 可以用管道| 和 more连接起来分页查看</span><br><span class="line">ps -aux &gt; ps001.txt    # 将所有进程信息重定向输出到指定文件中</span><br><span class="line">ps -A -o stat,ppid,pid,cmd | grep -e '^[Zz]'</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux之ps命令&quot;&gt;&lt;a href=&quot;#Linux之ps命令&quot; class=&quot;headerlink&quot; title=&quot;Linux之ps命令&quot;&gt;&lt;/a&gt;Linux之ps命令&lt;/h1&gt;
    
    </summary>
    
      <category term="Linux相关" scheme="http://yoursite.com/categories/Linux%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux之用户态和内核态</title>
    <link href="http://yoursite.com/2021/02/23/Linux%E7%9B%B8%E5%85%B3/Linux%E4%B9%8B%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"/>
    <id>http://yoursite.com/2021/02/23/Linux相关/Linux之用户态和内核态/</id>
    <published>2021-02-23T02:38:41.000Z</published>
    <updated>2021-02-23T02:40:14.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux之用户态和内核态"><a href="#Linux之用户态和内核态" class="headerlink" title="Linux之用户态和内核态"></a>Linux之用户态和内核态</h1><a id="more"></a><h2 id="一、Linux的体系结构"><a href="#一、Linux的体系结构" class="headerlink" title="一、Linux的体系结构"></a>一、Linux的体系结构</h2><p><img src="/2021/02/23/Linux相关/Linux之用户态和内核态/linux%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.png" alt="linux体系架构"></p><h3 id="内核态访问方式"><a href="#内核态访问方式" class="headerlink" title="内核态访问方式"></a>内核态访问方式</h3><p>用户态可以访问内核态资源可以通过一下三种方式访问。</p><p>1）系统调用</p><p>2）库函数</p><p>3）Shell脚本</p><p><strong>系统调用</strong>：如上图所示，从宏观上来看，Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p><p>系统调用是操作系统的最小功能单位，这些系统调用根据不同的应用场景可以进行扩展和裁剪，现在各种版本的Unix实现都提供了不同数量的系统调用，如Linux的不同版本提供了240-260个系统调用，FreeBSD大约提供了320个（reference：UNIX环境高级编程）。我们可以把系统调用看成是一种不能再化简的操作（类似于原子操作，但是不同概念），有人把它比作一个汉字的一个“笔画”，而一个“汉字”就代表一个上层应用，我觉得这个比喻非常贴切。因此，有时候如果要实现一个完整的汉字（给某个变量分配内存空间），就必须调用很多的系统调用。如果从实现者（程序员）的角度来看，这势必会加重程序员的负担，良好的程序设计方法是：重视上层的业务逻辑操作，而尽可能避免底层复杂的实现细节。</p><p> <strong>库函数</strong>：正是为了将程序员从复杂的细节中解脱出来而提出的一种有效方法。它实现对系统调用的封装，将简单的业务逻辑接口呈现给用户，方便用户调用，从这个角度上看，库函数就像是组成汉字的“偏旁”。这样的一种组成方式极大增强了程序设计的灵活性，对于简单的操作，我们可以直接调用系统调用来访问资源，如“人”，对于复杂操作，我们借助于库函数来实现，如“仁”。显然，这样的库函数依据不同的标准也可以有不同的实现版本，如ISO C 标准库，POSIX标准库等。</p><p><strong>Shell</strong>：是一个特殊的应用程序，俗称命令行，本质上是一个命令解释器，它下通系统调用，上通各种应用，通常充当着一种“胶水”的角色，来连接各个小功能程序，让不同程序能够以一个清晰的接口协同工作，从而增强各个程序的功能。同时，Shell是可编程的，它可以执行符合Shell语法的文本，这样的文本称为Shell脚本，通常短短的几行Shell脚本就可以实现一个非常大的功能，原因就是这些Shell语句通常都对系统调用做了一层封装。为了方便用户和系统交互，一般，一个Shell对应一个终端，终端是一个硬件设备，呈现给用户的是一个图形化窗口。我们可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。</p><h3 id="Linux体系细分结构"><a href="#Linux体系细分结构" class="headerlink" title="Linux体系细分结构"></a>Linux体系细分结构</h3><p><img src="/2021/02/23/Linux相关/Linux之用户态和内核态/Linux%E4%BD%93%E7%B3%BB%E7%BB%86%E5%88%86%E7%BB%93%E6%9E%84.jpg" alt="Linux体系细分结构"> </p><p>上图是对Linux体系结构的一个细分结构，从这个图上可以更进一步对内核所做的事有一个“全景式”的印象。主要表现为：向下控制硬件资源，向内管理操作系统资源：包括进程的调度和管理、内存的管理、文件系统的管理、设备驱动程序的管理以及网络资源的管理，向上则向应用程序提供系统调用的接口。从整体上来看，整个操作系统分为两层：用户态和内核态，这种分层的架构极大地提高了资源管理的可扩展性和灵活性，而且方便用户对资源的调用和集中式的管理，带来一定的安全性。</p><h2 id="二、用户态和内核态的切换"><a href="#二、用户态和内核态的切换" class="headerlink" title="二、用户态和内核态的切换"></a>二、用户态和内核态的切换</h2><p>因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。所以，为了减少有限资源的访问和使用冲突，Unix/Linux的设计哲学之一就是：对不同的操作赋予不同的执行等级，就是所谓特权的概念。简单说就是有多大能力做多大的事，与系统相关的一些特别关键的操作必须由最高特权的程序来完成。Intel的X86架构的CPU提供了0到3四个特权级，数字越小，特权越高，Linux操作系统中主要采用了0和3两个特权级，分别对应的就是内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存，当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换，类似的函数还有printf()，调用的是wirte()系统调用来输出字符串，等等。</p><p><img src="/2021/02/23/Linux相关/Linux之用户态和内核态/%E7%94%A8%E6%88%B7%E6%80%81%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2.gif" alt="用户态内核态的切换"></p><p>　到底在什么情况下会发生从用户态到内核态的切换，一般存在以下三种情况：</p><p>1）当然就是系统调用：原因如上的分析。</p><p>2）异常事件： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</p><p>3）外围设备的中断：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</p><p>　　注意：系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断，这是操作系统为用户特别开放的一种中断，如Linux int 80h中断。所以，从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本文仅是从宏观的角度去理解Linux用户态和内核态的设计，并没有去深究它们的具体实现方式。从实现上来看，必须要考虑到的一点我想就是性能问题，因为用户态和内核态之间的切换也会消耗大量资源。关于实现的细节，目前学艺不精不敢乱说，等日后补上。但知道了这一点，我相信对很多问题也就很容易理解了，比如说基于缓冲区的IO和无缓冲的IO，用户进程和内核进程之间的切换，IO复用中的读写内核事件表，等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux之用户态和内核态&quot;&gt;&lt;a href=&quot;#Linux之用户态和内核态&quot; class=&quot;headerlink&quot; title=&quot;Linux之用户态和内核态&quot;&gt;&lt;/a&gt;Linux之用户态和内核态&lt;/h1&gt;
    
    </summary>
    
      <category term="Linux相关" scheme="http://yoursite.com/categories/Linux%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Linux系统" scheme="http://yoursite.com/tags/Linux%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux之find命令</title>
    <link href="http://yoursite.com/2021/02/23/Linux%E7%9B%B8%E5%85%B3/Linux%E4%B9%8Bfind%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2021/02/23/Linux相关/Linux之find命令/</id>
    <published>2021-02-23T02:13:51.000Z</published>
    <updated>2021-02-23T02:37:02.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux之find命令"><a href="#Linux之find命令" class="headerlink" title="Linux之find命令"></a>Linux之find命令</h1><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>find pathname -options [-print -exec -ok …]</p><p>补充一下：</p><p>1.在这行中有个”|”,表示将前面命令的输出结果让后面的命令去执行，如果有时间大家也可以学学shell，是一个很容易上手的脚本语言；</p><p>2.”wc -l”统计文件的行数，包括空格行都统计的哟；</p><p>3.wc的语法：wc [参数] 文件</p><p>参数   含义</p><p>-c        显示文件的Bytes数(字节数)及文件名输出到屏幕上<br>-l        将每个文件的行数及文件名输出到屏幕上<br>-m      将每个文件的字符数及文件名输出到屏幕上，如果当前系统不支持多字节字符其将显示与-c参数相同的结果<br>-w      将每个文件含有多少个词及文件名输出到屏幕上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 统计文件数目</span><br><span class="line"><span class="meta">#</span> Total number of .jpg files</span><br><span class="line"><span class="meta">$</span> find . -type f -name '*.jpg' | wc -l</span><br><span class="line">165501</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Number of photos for male</span><br><span class="line"><span class="meta">$</span> find . -type f -path '*/111/*' | wc -l</span><br><span class="line">101526</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>eg：</span><br><span class="line"><span class="meta">#</span>统计当前目录下所有jpg文件数目</span><br><span class="line">find . -type f -name '*.jpg' | wc -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件</span><br><span class="line">find ./ -type f</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找目录</span><br><span class="line">find ./ -type d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找名字为test的文件或目录</span><br><span class="line">find ./ -name test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找名字符合正则表达式的文件,注意前面的‘.*’(查找到的文件带有目录)</span><br><span class="line">find ./ -regex .*so.*\.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找目录并列出目录下的文件(为找到的每一个目录单独执行ls命令，没有选项-print时文件列表前一行不会显示目录名称)</span><br><span class="line">find ./ -type d -print -exec ls &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找目录并列出目录下的文件(为找到的每一个目录单独执行ls命令,执行命令前需要确认)</span><br><span class="line">find ./ -type d -ok ls &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找目录并列出目录下的文件(将找到的目录添加到ls命令后一次执行，参数过长时会分多次执行)</span><br><span class="line">find ./ -type d -exec ls &#123;&#125; +</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件名匹配*.c的文件</span><br><span class="line">find ./ -name \*.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>打印test文件名后，打印test文件的内容</span><br><span class="line">find ./ -name test -print -exec cat &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>不打印test文件名，只打印test文件的内容</span><br><span class="line">find ./ -name test -exec cat &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新日时在距现在时刻二天以内的文件</span><br><span class="line">find ./ -mtime -2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新日时在距现在时刻二天以上的文件</span><br><span class="line">find ./ -mtime +2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新日时在距现在时刻一天以上二天以内的文件</span><br><span class="line">find ./ -mtime 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新日时在距现在时刻二分以内的文件</span><br><span class="line">find ./ -mmin -2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新日时在距现在时刻二分以上的文件</span><br><span class="line">find ./ -mmin +2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新日时在距现在时刻一分以上二分以内的文件</span><br><span class="line">find ./ -mmin 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新时间比文件abc的内容更新时间新的文件</span><br><span class="line">find ./ -newer abc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件访问时间比文件abc的内容更新时间新的文件</span><br><span class="line">find ./ -anewer abc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找空文件或空目录</span><br><span class="line">find ./ -empty</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找空文件并删除</span><br><span class="line">find ./ -empty -type f -print -delete</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找权限为644的文件或目录(需完全符合)</span><br><span class="line">find ./ -perm 664</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找用户/组权限为读写，其他用户权限为读(其他权限不限)的文件或目录</span><br><span class="line">find ./ -perm -664</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找用户有写权限或者组用户有写权限的文件或目录</span><br><span class="line">find ./ -perm /220</span><br><span class="line">find ./ -perm /u+w,g+w</span><br><span class="line">find ./ -perm /u=w,g=w</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找所有者权限有读权限的目录或文件</span><br><span class="line">find ./ -perm -u=r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找用户组权限有读权限的目录或文件</span><br><span class="line">find ./ -perm -g=r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找其它用户权限有读权限的目录或文件</span><br><span class="line">find ./ -perm -o=r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找所有者为lzj的文件或目录</span><br><span class="line">find ./ -user lzj</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找组名为gname的文件或目录</span><br><span class="line">find ./ -group gname</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件的用户ID不存在的文件</span><br><span class="line">find ./ -nouser</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件的组ID不存在的文件</span><br><span class="line">find ./ -nogroup</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找有执行权限但没有可读权限的文件</span><br><span class="line">find ./ -executable \! -readable</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件size小于10个字节的文件或目录</span><br><span class="line">find ./ -size -10c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件size等于10个字节的文件或目录</span><br><span class="line">find ./ -size 10c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件size大于10个字节的文件或目录</span><br><span class="line">find ./ -size +10c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件size小于10k的文件或目录</span><br><span class="line">find ./ -size -10k</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件size小于10M的文件或目录</span><br><span class="line">find ./ -size -10M</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件size小于10G的文件或目录</span><br><span class="line">find ./ -size -10G</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux之find命令&quot;&gt;&lt;a href=&quot;#Linux之find命令&quot; class=&quot;headerlink&quot; title=&quot;Linux之find命令&quot;&gt;&lt;/a&gt;Linux之find命令&lt;/h1&gt;
    
    </summary>
    
      <category term="Linux相关" scheme="http://yoursite.com/categories/Linux%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux之vim使用详解</title>
    <link href="http://yoursite.com/2021/02/22/Linux%E7%9B%B8%E5%85%B3/Linux%E4%B9%8Bvim%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2021/02/22/Linux相关/Linux之vim使用详解/</id>
    <published>2021-02-22T09:34:53.000Z</published>
    <updated>2021-02-23T03:03:52.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux之vim使用详解"><a href="#Linux之vim使用详解" class="headerlink" title="Linux之vim使用详解"></a>Linux之vim使用详解</h1><a id="more"></a><h2 id="vim简介"><a href="#vim简介" class="headerlink" title="vim简介"></a>vim简介</h2><p>Vim是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，和Emacs并列成为类Unix系统用户最喜欢的文本编辑器。</p><p>vim的设计理念是命令的组合。用户学习了各种各样的文本间移动/跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效的进行文本编辑。同时VIM与很多快捷键设置和正则表达式类似,可以辅助记忆。并且vim针对程序员做了优化。</p><h3 id="vim模式"><a href="#vim模式" class="headerlink" title="vim模式"></a>vim模式</h3><p>打开文件方法：vim filename，默认为编辑模式。</p><p>vim是模块化的编辑器，包含三种基本模式：</p><p>1、一般指令模式：Normal，默认模式，移动光标，剪切/粘贴文本。</p><p>2、编辑模式：Insert，插入模式，用于修改文本。</p><p>3、命令行命令模式：内置命令接口（extended command），用于保存、退出等。</p><h3 id="vim模式替换"><a href="#vim模式替换" class="headerlink" title="vim模式替换"></a>vim模式替换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">一般指令模式 --&gt; 编辑模式：</span><br><span class="line">i：insert, 在光标所在处输入</span><br><span class="line">a: append，在光标在处后方输入</span><br><span class="line">o：在光标所在处的下方打开一个新行</span><br><span class="line">I：在光标所在行的行首输入</span><br><span class="line">A：在光标所在行的行尾输入</span><br><span class="line">O：在光标所在处的上方打开一个新行</span><br><span class="line"></span><br><span class="line">编辑模式 --&gt; 一般指令模式</span><br><span class="line">ESC</span><br><span class="line"></span><br><span class="line">一般指令模式 --&gt; 命令行命令模式</span><br><span class="line">:</span><br><span class="line"></span><br><span class="line">命令行命令模式 --&gt; 一般指令模式模式</span><br><span class="line">ESC，Enter</span><br></pre></td></tr></table></figure><h2 id="常用vim指令"><a href="#常用vim指令" class="headerlink" title="常用vim指令"></a>常用vim指令</h2><h3 id="一般指令模式"><a href="#一般指令模式" class="headerlink" title="一般指令模式"></a>一般指令模式</h3><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZZ                     # 保存并退出</span><br><span class="line">ZQ                     # 不保存退出</span><br></pre></td></tr></table></figure><h4 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 字符间跳转</span><br><span class="line">h                          # 左</span><br><span class="line">j                          # 下</span><br><span class="line">k                          # 上</span><br><span class="line">l                          # 右</span><br><span class="line"><span class="meta">#</span>COMMAND                   # 跳转由#指定的个数的字符</span><br><span class="line">5k                         # 向上跳转5个字符</span><br><span class="line">3l                         # 向右跳转3个字符</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 单词间跳转</span><br><span class="line">w                          # 下一个单词的词首</span><br><span class="line">e                          # 当前或后一个单词的词尾</span><br><span class="line">b                          # 当前或前一个单词的词首</span><br><span class="line"><span class="meta">#</span>COMMAND                   # 跳转由#指定的个数的单词</span><br><span class="line">3w                         # 跳转到下三个单词的词首</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 行首行尾跳转</span><br><span class="line">^                          # 跳转至行首的第一个非空白字符</span><br><span class="line">0                          # 跳转至行首，数字 0 ，字母 O 和 o 是由编辑模式进入到输入模式</span><br><span class="line"><span class="meta">$</span>                          # 跳转至行尾</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 当前页跳转</span><br><span class="line">H                          # 页首</span><br><span class="line">M                          # 页中间行</span><br><span class="line">L                          # 页底</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 行间跳转</span><br><span class="line"><span class="meta">#</span>G                         # 跳转至由#指定的行</span><br><span class="line">1G, gg                     # 第一行</span><br><span class="line">G                          # 最后一行</span><br><span class="line">5G                         # 跳转至第5行</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 句间跳转</span><br><span class="line">)                          # 下一句</span><br><span class="line">(                          # 上一句</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 段间跳转</span><br><span class="line">&#125;                          # 下一段</span><br><span class="line">&#123;                          # 上一段</span><br></pre></td></tr></table></figure><h4 id="翻屏"><a href="#翻屏" class="headerlink" title="翻屏"></a>翻屏</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+f                     # 向文件尾翻一屏</span><br><span class="line">Ctrl+b                     # 向文件首部翻一屏</span><br><span class="line">Ctrl+d                     # 向文件尾部翻半屏</span><br><span class="line">Ctrl+u                     # 向文件首部翻半屏</span><br><span class="line">Enter                      # 按行向后翻</span><br></pre></td></tr></table></figure><h4 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 字符编辑</span><br><span class="line">x                          # 删除光标所在处的字符</span><br><span class="line"><span class="meta">#</span>x                         # 删除光标所在处起始的#个字符</span><br><span class="line"></span><br><span class="line">xp                         # 交换光标所在处的字符与其后面的字符的位置</span><br><span class="line">~                          # 转换大小写</span><br><span class="line">J                          # 删除当前行后的换行符</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 替换命令</span><br><span class="line">r                          # 替换光标所在处的字符</span><br><span class="line">R                          # 切换成 REPLACE 模式，可以输入任意字符进行更换</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除命令 delete</span><br><span class="line">d                          # 删除命令，可结合光标跳转字符，实现范围删除</span><br><span class="line"><span class="meta">d$</span>                     # 删除到行尾</span><br><span class="line">d^                     # 删除到非空行首 </span><br><span class="line">d0                     # 删除到行首</span><br><span class="line">dw                     # 删除光标所在处的单词或符号</span><br><span class="line">d3w                    # 删除光标所在处的三个单词</span><br><span class="line">de                     # 删除当前或下一个单词</span><br><span class="line">db                     # 删除当前或前一个单词</span><br><span class="line"><span class="meta">#</span>COMMAND               # 支持使用数字</span><br><span class="line"></span><br><span class="line">dd                     # 删除光标所在处的行</span><br><span class="line"><span class="meta">#</span>dd                    # 删除光标所处的行起始的共#行</span><br><span class="line">3dd                    # 删除光标所处的行起始的3行</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 复制命令</span><br><span class="line">y                          # 复制，工作行为相似于d命令</span><br><span class="line"><span class="meta">y$</span>                     # 复制当前光标处到行尾</span><br><span class="line">y^                     # 复制当前光标处到非空行首</span><br><span class="line">y0                     # 复制当前光标处到行首</span><br><span class="line"></span><br><span class="line">ye                     # 复制当前或下一个单词</span><br><span class="line">yw                     # 复制光标所在处的单词</span><br><span class="line">yb                     # 复制当前或前一个单词</span><br><span class="line"><span class="meta">#</span>COMMAND</span><br><span class="line"></span><br><span class="line">yy                     # 复制一整行</span><br><span class="line"><span class="meta">#</span>yy                    # 复制#行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 粘贴命令</span><br><span class="line">p           # 缓冲区中的内容如果为整行，则粘贴在当前光标所在行的下方</span><br><span class="line">        # 否则，则粘贴至当前光标所在处的后方</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 改变命令 （相当于移动光标，删除，并进入输入模式）</span><br><span class="line"><span class="meta">c$</span>                         # 删除光标所在处至行尾，并切换到输入模式 </span><br><span class="line">c^                         # 非空行首</span><br><span class="line">c0                         # 行首</span><br><span class="line"></span><br><span class="line">cb                         # 当前或前一个单词</span><br><span class="line">ce                         # 当前或下一个单词</span><br><span class="line">cw                         # 当前单词</span><br><span class="line"><span class="meta">#</span>COMMAND</span><br><span class="line"></span><br><span class="line">cc                         # 删除光标所在的行，并转换为输入模式</span><br><span class="line"><span class="meta">#</span>cc                        # 删除光标所在行为起始行3行，并转换为输入模式</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 撤销模式</span><br><span class="line">撤销(undo)操作：</span><br><span class="line">u                      # 撤销此前的操作；</span><br><span class="line"><span class="meta">#</span>u                     # 撤销此前的#个操作；</span><br><span class="line"></span><br><span class="line">Ctrl+r                   # 撤销此前的撤销</span><br><span class="line"></span><br><span class="line">.                      # 重复执行前一个编辑操作</span><br></pre></td></tr></table></figure><h3 id="命令行命令模式"><a href="#命令行命令模式" class="headerlink" title="命令行命令模式"></a>命令行命令模式</h3><h4 id="文件操作-1"><a href="#文件操作-1" class="headerlink" title="文件操作"></a>文件操作</h4><p>在编辑模式下，输入“:”进入末行模式，会创建一个命令提示符，处于屏幕底部左侧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">:q                     # 退出</span><br><span class="line">:q!                    # 强制退出，不保存此前的编辑操作</span><br><span class="line">:wq                    # 保存并退出</span><br><span class="line">:w, :q                 # 保存并退出</span><br><span class="line">:x                     # 保存并退出</span><br><span class="line">:w /PATH/TO/SOMEFILE   # 保存文件至指定的路径</span><br><span class="line">r filename             # 读文件内容到当前文件中</span><br><span class="line">w filename             # 将当前文件内容写入另一个文件</span><br><span class="line">!command               # 执行命令</span><br><span class="line">r!command              # 读入命令的输出</span><br></pre></td></tr></table></figure><h4 id="地址定界"><a href="#地址定界" class="headerlink" title="地址定界"></a>地址定界</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">:start_pos[,end_pos]</span><br><span class="line"><span class="meta">#</span>                           # 特定的第#行，例如5即第5行</span><br><span class="line">.                           # 当前行</span><br><span class="line"><span class="meta">$</span>                           # 最后一行</span><br><span class="line"><span class="meta">#</span>,#                         # 指定行范围，左侧为起始行，右侧为结束行</span><br><span class="line"><span class="meta">#</span>,+#                        # 指定行范围，左侧为超始行绝对编号，右侧为相对左侧行号的偏移量；例如：3,+7</span><br><span class="line">.,$-1</span><br><span class="line">1,$</span><br><span class="line"><span class="meta">%</span>                           # 全文 </span><br><span class="line">/pattern/                   # 从光标所在处起始向文件尾部第一次被模式所匹配到的行</span><br><span class="line">/first/,$</span><br><span class="line">/pat1/,/pat2/               # 从光标所在处起始，第一次由pat1匹配到的行开始，至第一次由pat2匹配到的行结束之间的所有行</span><br><span class="line"></span><br><span class="line">可同编辑命令一同使用，实现编辑操作：</span><br><span class="line">d</span><br><span class="line">y</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">w /PATH/TO/SOMEFILE          # 将范围内的文本保存至指定的文件中；</span><br><span class="line">r  /PATH/FROM/SOMEFILE       # 将指定的文件中的文本读取并插入至指定位置；</span><br></pre></td></tr></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/PATTERN：#从当前光标所在处向文件尾部查找能够被当前模式匹配到的所有字符串；</span><br><span class="line">?PATTERN：#从当前光标所在处向文件首部查找能够被当前模式匹配到的所有字符串；</span><br><span class="line">n：#下一个，与命令方向相同；</span><br><span class="line">N：#上一个，与命令方向相反；</span><br><span class="line"></span><br><span class="line">s：末行模式的命令；使用格式：</span><br><span class="line">s/要查找的内容/替换为的内容/修饰符</span><br><span class="line">要查找的内容：可使用正则表达式；</span><br><span class="line">替换为的内容：不能使用下则表达式，但可以引用；</span><br><span class="line">如果“要查找的内容”部分在模式中使用分组符号：在“替换为的内容”中使用后向引用；</span><br><span class="line">直接引用查找模式匹配到的全部文本，要使用&amp;符号；</span><br><span class="line">修饰符：</span><br><span class="line">i：忽略大小写；</span><br><span class="line">g：全局替换，意味着一行中如果匹配到多次，则均替换；</span><br><span class="line"></span><br><span class="line">可把分隔符替换为其它非常用字符：</span><br><span class="line">s@@@</span><br><span class="line"><span class="meta">s#</span>##</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">1、复制/etc/grub2.cfg文件至/tmp目录中，用查找替换命令删除/tmp/grub2.cfg文件中以空白字符开头的行的行首的空白字符；</span><br><span class="line"><span class="meta">%</span>s@^[[:space:]]\+@@</span><br><span class="line">2、复制/etc/rc.d/init.d/functions文件至/tmp目录中，用查找替换命令为/tmp/functions文件的每个以空白字符开头的行的行首加上#；</span><br><span class="line"><span class="meta">%</span>s@^[[:space:]]\+[^[:space:]]@#&amp;@g</span><br><span class="line">3、为/tmp/grub2.cfg文件的前三行的行首加上#号；</span><br><span class="line">1,3s@^@#@</span><br><span class="line">4、将/etc/yum.repos.d/CentOS-Base.repo文件中所有的enabled=0替换为enabled=1，所有gpgcheck=0替换为gpgcheck=1；</span><br><span class="line"><span class="meta">%</span>s@\(enabled\|gpgcheck\)=0@\1=1@g</span><br></pre></td></tr></table></figure><h2 id="vim其它功能"><a href="#vim其它功能" class="headerlink" title="vim其它功能"></a>vim其它功能</h2><h3 id="多文件功能"><a href="#多文件功能" class="headerlink" title="多文件功能"></a>多文件功能</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">多文件命令格式：</span><br><span class="line"><span class="meta">#</span> vim FILE1 FILE2 ...</span><br><span class="line">在文件间切换：</span><br><span class="line">:next  下一个</span><br><span class="line">:prev  上一个</span><br><span class="line">:first   第一个 </span><br><span class="line">:last   最后一个</span><br><span class="line"></span><br><span class="line">退出所有文件：</span><br><span class="line">:wqall 保存所有文件并退出；</span><br><span class="line">:wall</span><br><span class="line">:qall</span><br></pre></td></tr></table></figure><h3 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-o：水平分割窗口</span><br><span class="line">-O：垂直分割窗口</span><br><span class="line"></span><br><span class="line">在窗口间切换：Ctrl+w, ARROW</span><br><span class="line"></span><br><span class="line">注意：单个文件也可以分割为多个窗口进行查看：</span><br><span class="line">Ctrl+w, s：水平分割窗口</span><br><span class="line">Ctrl+w, v：垂直分割窗口</span><br></pre></td></tr></table></figure><h3 id="定制vim工作特性"><a href="#定制vim工作特性" class="headerlink" title="定制vim工作特性"></a>定制vim工作特性</h3><p>1、临时有效：在末行模式下的设定，仅对当前vim进程有效</p><p>2、永久有效：需要修改相应的配置文件，全局配置文件（/etc/vimrc）；用户个人配置文件（～/.vimrc，需要首先创建此文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 行号</span><br><span class="line">显示：set number, 简写为set nu</span><br><span class="line">取消显示：set nomber, set nonu</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>  括号匹配高亮</span><br><span class="line">匹配：set showmatch, set sm</span><br><span class="line">取消：set nosm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 自动缩进</span><br><span class="line">启用：set ai</span><br><span class="line">禁用：set noai</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 高亮搜索</span><br><span class="line">启用：set  hlsearch</span><br><span class="line">禁用：set nohlsearch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 语法高亮</span><br><span class="line">启用：syntax on</span><br><span class="line">禁用：syntax off </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>忽略字符大小写</span><br><span class="line">启用：set ic</span><br><span class="line">禁用：set noic</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取帮助</span><br><span class="line">:help</span><br><span class="line">:help subject</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按TAB产生4个空格</span><br><span class="line">set ts=4        # 注：ts是tabstop的缩写，设TAB宽4个空格</span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">对于已保存的文件，可以使用下面的方法进行空格和TAB的替换：</span><br><span class="line">TAB替换为空格：</span><br><span class="line">:set ts=4</span><br><span class="line">:set expandtab</span><br><span class="line">:%retab!</span><br><span class="line"></span><br><span class="line">空格替换为TAB：</span><br><span class="line">:set ts=4</span><br><span class="line">:set noexpandtab</span><br><span class="line">:%retab!</span><br><span class="line"></span><br><span class="line">加!是用于处理非空白字符之后的TAB，即所有的TAB，若不加!，则只处理行首的TAB。</span><br></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>图片引自网络（侵删）</p><p><img src="/2021/02/22/Linux相关/Linux之vim使用详解/image-20210223100320707.png" alt="image-20210223100320707"></p><p>来自鸟哥私房菜基础篇：</p><p><strong>第一部分</strong>：</p><p><img src="/2021/02/22/Linux相关/Linux之vim使用详解/image-20210223105458430.png" alt="image-20210223105458430"></p><p><img src="/2021/02/22/Linux相关/Linux之vim使用详解/image-20210223105516589.png" alt="image-20210223105516589"></p><p><img src="/2021/02/22/Linux相关/Linux之vim使用详解/image-20210223105529558.png" alt="image-20210223105529558"></p><p><strong>第二部分</strong>：</p><p><img src="/2021/02/22/Linux相关/Linux之vim使用详解/image-20210223105607302.png" alt="image-20210223105607302"></p><p><strong>第三部分</strong>：</p><p><img src="/2021/02/22/Linux相关/Linux之vim使用详解/image-20210223105625388.png" alt="image-20210223105625388"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux之vim使用详解&quot;&gt;&lt;a href=&quot;#Linux之vim使用详解&quot; class=&quot;headerlink&quot; title=&quot;Linux之vim使用详解&quot;&gt;&lt;/a&gt;Linux之vim使用详解&lt;/h1&gt;
    
    </summary>
    
      <category term="Linux相关" scheme="http://yoursite.com/categories/Linux%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="vim使用详解" scheme="http://yoursite.com/tags/vim%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java八大排序算法</title>
    <link href="http://yoursite.com/2021/02/20/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/02/20/Java数据结构与算法/Java八大排序算法/</id>
    <published>2021-02-20T09:41:53.000Z</published>
    <updated>2021-02-20T09:43:30.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java八大排序算法"><a href="#Java八大排序算法" class="headerlink" title="Java八大排序算法"></a>Java八大排序算法</h1><a id="more"></a><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>八大排序算法：直接插入排序（Insertion Sort）、希尔排序（Shell Sort）、选择排序（Selection Sort）、堆排序（Heap Sort）、冒泡排序（Bubble Sort）、快速排序（Quick Sort）、归并排序（Merging Sort）、基数排序（Radix Sort），基数排序也称桶排序。</p><p>都属于内部排序算法，其中直接插入排序和希尔排序属于<strong>插入排序</strong>，简单选择排序和堆排序属于<strong>选择排序</strong>，冒泡排序和快速排序属于<strong>交换排序</strong>。</p><h2 id="直接插入排序算法"><a href="#直接插入排序算法" class="headerlink" title="直接插入排序算法"></a>直接插入排序算法</h2><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。插入排序非常类似于整扑克牌。在开始摸牌时，左手是空的，牌面朝下放在桌上。接着，一次从桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将它与手中已有的牌从右到左地进行比较。无论什么时候，左手中的牌都是排好序的。<br>如果输入数组已经是排好序的话，插入排序出现最佳情况，其运行时间是输入规模的一个线性函数。如果输入数组是逆序排列的，将出现最坏情况。平均情况与最坏情况一样，其时间代价是(n2)。</p><p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。</p><p>通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了要给插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><p>1、从第一个元素开始，该元素可以认为已经被排序。</p><p>2、取出下一个元素，在已经排序的元素序列中从后向前扫描。</p><p>3、如果该元素（已排序）大于新元素，将该元素移到下一位置。</p><p>4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。</p><p>5、将新元素插入到该位置后。</p><p>6、重复步骤2~5。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过将较大的元素都向右移动而不总是交换两个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 装载临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">temp = data[i];</span><br><span class="line"><span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果前一位比当前数据要大，那么进入循环比较</span></span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; data[j] &gt; temp; j--) &#123;</span><br><span class="line"><span class="comment">// 往后退一个位置，让当前数据与之前前位进行比较</span></span><br><span class="line">data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出内层循环，则说明找到了合适的位置，并将当前数据插入合适的位置中</span></span><br><span class="line">data[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过交换进行插入排序，借鉴冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 装载临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"><span class="comment">// 如果前一位比当前数据要大，那么进入循环比较，并两两交换，参考冒泡排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; data[j] &gt; data[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">temp = data[j + <span class="number">1</span>];</span><br><span class="line">data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sortTwo end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>插入排序所需的时间取决于输入元素的初始顺序。例如，对一个很大且其中的元素已经有序(或接近有序)的数组进行排序将会比随机顺序的数组或是逆序数组进行排序要快得多。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell 于1959 年提出而得名。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。<br>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是初次取数组长度的一半为增量，之后每次再减半，直到增量为1。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>1、选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1。</p><p>2、按增量序列个数 k，对序列进行 k 趟排序。</p><p>3、每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><p>引用自网上一张图（侵删）：</p><p><img src="/2021/02/20/Java数据结构与算法/Java八大排序算法/image-20210220134535850.png" alt="image-20210220134535850"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">// 增量每次都/2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> step = data.length / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 从增量那组开始进行插入排序，直至完毕</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; data.length; i++) &#123;</span><br><span class="line">temp = data[i];</span><br><span class="line"><span class="keyword">int</span> j = i - step;</span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; data[j] &gt; temp; j -= step) &#123;</span><br><span class="line"><span class="comment">// 往后退一个step位置，让当前数据与之前前位进行比较</span></span><br><span class="line">data[j + step] = data[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出内层循环，则说明找到了合适的位置，并将当前数据插入合适的位置中</span></span><br><span class="line">data[j + step] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td></tr></tbody></table><p>希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始(末尾)位置，直到全部待排序的数据元素排完。选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5 挪动到第二个5 后面）。</p><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n个元素的表进行排序总共进行至多 n-1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><h3 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h3><p>1、从未排序序列中，找到关键字最小的元素。</p><p>2、如果最小元素不是未排序序列的第一个元素，将其和未排序序列第一个元素互换。</p><p>3、重复1、2步，直到排序结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 记录当前趟数的最小值的角标</span></span><br><span class="line"><span class="keyword">int</span> minPos;</span><br><span class="line"><span class="comment">// 交换的变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"><span class="comment">// 新的趟数的起点</span></span><br><span class="line">minPos = i;</span><br><span class="line"><span class="comment">// 选出之后排序中值最小的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; data.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (data[j] &lt; data[i]) &#123;</span><br><span class="line">minPos = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最小值不等于当前值时进行交换</span></span><br><span class="line"><span class="keyword">if</span> (minPos != i) &#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">data[i] = data[minPos];</span><br><span class="line">data[minPos] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。</p><h3 id="算法描述：-1"><a href="#算法描述：-1" class="headerlink" title="算法描述："></a>算法描述：</h3><p>描述一：</p><p>1、i从0开始，i与i+1比较，如果后面的数（i+1）小于前面的数（i），则交换。<br>2、i不断增加，直到i&lt;n-1（数组长度减一），一趟下来，可以让数组元素中的最大值排在数组的最后，直到完成。</p><p>描述二：</p><p>1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><p>3、针对所有的元素重复以上的步骤，除了最后一个。</p><p>4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试用，记录执行了多少趟</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 装载临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">// 外层是排序的趟数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 内层循环是当前趟数需要比较的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="comment">// 前一位与后一位相比较，如果前一位比后一位要大，则交换</span></span><br><span class="line"><span class="keyword">if</span> (data[j + <span class="number">1</span>] &lt; data[j]) &#123;</span><br><span class="line">temp = data[j + <span class="number">1</span>];</span><br><span class="line">data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"Sort run frequency is : "</span> + num);</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p><h3 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h3><p>如果数据足够乱的情况下，例如反序，需要数据长度-1趟才能将数据完整排好序。</p><p>但是在部分有序情况下，例如在第3趟比较后就已经得到了排好序的数组，就没有必要执行后面的计算了。我们可以做如下优化：</p><ul><li>如果在某趟排序中没有发生交换位置，那么我们可以认为该数组已经排好顺序了。（我们每趟排序的目的就是为了将当前趟最大的数置换到对应的位置上，如果没有发生置换说明已经是排好序的了）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">betterSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试用，记录执行了多少趟</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 装载临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">// 记录是否发生了置换，0代表没有发生置换，1代表发生了置换</span></span><br><span class="line"><span class="keyword">int</span> isChange;</span><br><span class="line"><span class="comment">// 外层是排序的趟数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 每比较一趟就重新初始化为0</span></span><br><span class="line">isChange = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 内层循环是当前趟数需要比较的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="comment">// 前一位与后一位相比较，如果前一位比后一位要大，则交换</span></span><br><span class="line"><span class="keyword">if</span> (data[j + <span class="number">1</span>] &lt; data[j]) &#123;</span><br><span class="line">temp = data[j + <span class="number">1</span>];</span><br><span class="line">data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果进到这里面了，说明发生了置换</span></span><br><span class="line">isChange = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果比较完一趟没有发生置换，那么说明已经排好序了，不需要再执行下去了</span></span><br><span class="line"><span class="keyword">if</span> (isChange == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"betterSort run frequency is : "</span> + num);</span><br><span class="line">&#125; <span class="comment">// better sort end</span></span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序由C. A. R. Hoare 在1962 年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>一次循环：从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。找到这个值之后，又从前往后开始比较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的值才交换。直到从前往后的比较索引&gt;从后往前比较的索引，结束第一次循环，此时，对于基准值来说，左右两边就是有序的了。</p><h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好。</p><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists），算法步骤：</p><p>1、从数列中挑出一个元素，称为”基准”（pivot）。</p><p>2、重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p><p>3、递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"sort start, L : "</span> + L + <span class="string">" ,R : "</span> + R);</span><br><span class="line"><span class="keyword">int</span> i = L;</span><br><span class="line"><span class="keyword">int</span> j = R;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换的变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">// 支点</span></span><br><span class="line"><span class="keyword">int</span> pivot = data[L + (R - L) / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左右两端进行扫描，只要两端没有交替，就一直扫描</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line"><span class="comment">// 左边寻找直到比支点大的数</span></span><br><span class="line"><span class="keyword">while</span> (pivot &gt; data[i]) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边寻找直到比支点小的数</span></span><br><span class="line"><span class="keyword">while</span> (pivot &lt; data[j]) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时已经分别找到了比支点小的数（右边）、比支点大的数（左边），它们进行交换</span></span><br><span class="line"><span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">data[i] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line"><span class="comment">// 左边右移一位</span></span><br><span class="line">i++;</span><br><span class="line"><span class="comment">// 右边左移一位</span></span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面一个while保证了第一趟排序支点的左边比支点小，支点的右边比支点大了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左边再做排序，直到左边剩下一个数（递归出口）</span></span><br><span class="line"><span class="keyword">if</span> (L &lt; j) &#123;</span><br><span class="line">System.out.println(<span class="string">"sort left before, L : "</span> + L + <span class="string">" ,j : "</span> + j);</span><br><span class="line">sort(data, L, j);</span><br><span class="line">System.out.println(<span class="string">"sort left end, L : "</span> + L + <span class="string">" ,j : "</span> + j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右边再做排序，直到右边剩下一个数（递归出口）</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; R) &#123;</span><br><span class="line">System.out.println(<span class="string">"sort right before, i : "</span> + i + <span class="string">" ,R : "</span> + R);</span><br><span class="line">sort(data, i, R);</span><br><span class="line">System.out.println(<span class="string">"sort right end, i : "</span> + i + <span class="string">" ,R : "</span> + R);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用<strong>分治法（Divide and Conquer）</strong>的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>归并排序可通过两种方式实现:</p><ul><li>自上而下的递归</li><li>自下而上的迭代</li></ul><p>递归法（假设序列共有n个元素）：</p><p>1、将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</p><p>2、将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</p><p>3、重复步骤2，直到所有元素排序完毕。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>迭代法归并操作的工作原理如下：</p><p>1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。</p><p>2、设定两个指针，最初位置分别为两个已经排序序列的起始位置。</p><p>3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。</p><p>4、重复步骤3 直到某一指针超出序列尾。</p><p>5、将另一序列剩下的所有元素直接复制到合并序列尾。</p><p>归并排序其实要做两件事：</p><ul><li>分解：将序列每次折半拆分</li><li>合并：将划分后的序列段两两排序合并</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果只有一个元素，那就不用排序了</span></span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 取中间的数，进行拆分</span></span><br><span class="line"><span class="keyword">int</span> M = L + (R - L) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"sort left before, L : "</span> + L + <span class="string">" ,M : "</span> + M);</span><br><span class="line"><span class="comment">// 左边的数不断进行拆分</span></span><br><span class="line">sort(data, L, M);</span><br><span class="line">System.out.println(<span class="string">"sort left end, L : "</span> + L + <span class="string">" ,M : "</span> + M);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"sort right before, M+1 : "</span> + (M + <span class="number">1</span>) + <span class="string">" ,R : "</span> + R);</span><br><span class="line"><span class="comment">// 右边的数不断进行拆分</span></span><br><span class="line">sort(data, M + <span class="number">1</span>, R);</span><br><span class="line">System.out.println(<span class="string">"sort right end, M+1 : "</span> + (M + <span class="number">1</span>) + <span class="string">" ,R : "</span> + R);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"merge before, L: "</span> + L + <span class="string">", M+1 : "</span> + (M + <span class="number">1</span>) + <span class="string">" ,R : "</span> + R);</span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">merge(data, L, M + <span class="number">1</span>, R);</span><br><span class="line">System.out.println(<span class="string">"merge end, L: "</span> + L + <span class="string">", M+1 : "</span> + (M + <span class="number">1</span>) + <span class="string">" ,R : "</span> + R);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 左边数组的大小</span></span><br><span class="line"><span class="keyword">int</span>[] leftData = <span class="keyword">new</span> <span class="keyword">int</span>[M - L];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边数组的大小</span></span><br><span class="line"><span class="keyword">int</span>[] rightData = <span class="keyword">new</span> <span class="keyword">int</span>[R - M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往这两个数组填充数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; M; i++) &#123;</span><br><span class="line">leftData[i - L] = data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt;= R; i++) &#123;</span><br><span class="line">rightData[i - M] = data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// data数组的第一个元素</span></span><br><span class="line"><span class="keyword">int</span> k = L;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个数组的值，哪个小，就往数组上放</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; leftData.length &amp;&amp; j &lt; rightData.length) &#123;</span><br><span class="line"><span class="comment">// 谁比较小，谁将元素放入大数组中，移动指针，继续比较下一个</span></span><br><span class="line"><span class="keyword">if</span> (leftData[i] &lt; rightData[j]) &#123;</span><br><span class="line">data[k] = leftData[i];</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">data[k] = rightData[j];</span><br><span class="line"></span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果左边数组没有比较完，右边数组已经完了，那么将左边数组复制到大数组中（剩下的都是大数字）</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; leftData.length) &#123;</span><br><span class="line">data[k] = leftData[i];</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果右边数组没有比较完，左边数组已经完了，那么将右边数组复制到大数组中（剩下的都是大数字）</span></span><br><span class="line"><span class="keyword">while</span> (j &lt; rightData.length) &#123;</span><br><span class="line">data[k] = rightData[j];</span><br><span class="line"></span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// merge end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(1)</td></tr></tbody></table><p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p><p>归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比，它的主要缺点则是他所需的额外空间和N成正比。</p><h2 id="基数排序（桶排序）"><a href="#基数排序（桶排序）" class="headerlink" title="基数排序（桶排序）"></a>基数排序（桶排序）</h2><p>基数排序(radix sort)属于”分配式排序”(distribution sort)，又称”桶子法”(bucket sort)或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些”桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r 为所采取的基数，而m 为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。基数排序不同与其他的7种排序，其他7 种排序本质上都是按照交换或者比较来进行排序，但是基数排序并不是，它是按照分配，回收(分配到不同的位置上，然后回收)..不断分配..回收来进行排序，直到有序。</p><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p><p><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</p><p><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</p><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>基数排序按照优先从高位或低位来排序有两种实现方案：</p><ul><li><p>MSD（Most significant digital） 从最左侧高位开始进行排序。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。MSD方式适用于位数多的序列。</p></li><li><p>LSD （Least significant digital）从最右侧低位开始进行排序。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。LSD方式适用于位数少的序列。</p></li></ul><p>以LSD为例，从最低位开始，算法步骤：</p><p>1、取得数组中的最大数，并取得位数；</p><p>2、arr为原始数组，从最低位开始取每个位组成radix数组；</p><p>3、对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (data.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得数组中最大的数，并取得位数</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; data[i]) &#123;</span><br><span class="line">max = data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 位数计算</span></span><br><span class="line"><span class="keyword">int</span> maxDigit = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (max / <span class="number">10</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">maxDigit++;</span><br><span class="line">max = max / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请一个桶空间，二维数组</span></span><br><span class="line"><span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][data.length];</span><br><span class="line"><span class="keyword">int</span> base = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从低位到高位，对每一位遍历，将所有元素分配到桶中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++) &#123;</span><br><span class="line"><span class="comment">// 存储各个桶中存储元素的数量</span></span><br><span class="line"><span class="keyword">int</span>[] bktLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配，将所有元素分配到桶中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> whichBucket = (data[j] % base) / (base / <span class="number">10</span>);</span><br><span class="line">buckets[whichBucket][bktLen[whichBucket]] = data[j];</span><br><span class="line">bktLen[whichBucket]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集，将不同桶里的数据挨个捞出来，为下一轮高位排序做准备，由于靠近桶底的元素排名靠前，因此从桶底先捞</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; buckets.length; b++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; bktLen[b]; p++) &#123;</span><br><span class="line">data[k++] = buckets[b][p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">base *= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(d*(n + r))</td><td>O(d*(n + r))</td><td>O(d*(n + r))</td><td>O(n+r)</td></tr></tbody></table><p>其中，d 为位数，r 为基数，n 为原数组个数。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d*(n + r))。</p><p>备注：</p><p>基数排序更适合用于对时间, 字符串等这些 整体权值未知的数据 进行排序。</p><p>基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p>基数排序 vs 计数排序 vs 桶排序</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><p>1、基数排序：根据键值的每位数字来分配桶</p><p>2、计数排序：每个桶只存储单一键值</p><p>3、桶排序：每个桶存储一定范围的数值</p><h2 id="八大排序算法总结"><a href="#八大排序算法总结" class="headerlink" title="八大排序算法总结"></a>八大排序算法总结</h2><p>从时间复杂度来说：</p><p>1、平方阶O(n²)排序：<strong>各类简单排序：直接插入、直接选择和冒泡排序</strong></p><p>2、线性对数阶O(nlog₂n)排序：<strong>快速排序、堆排序和归并排序</strong></p><p>3、O(n1+§))排序，§是介于0和1之间的常数：<strong>希尔排序</strong></p><p>4、线性阶O(n)排序：<strong>基数排序，此外还有桶、箱排序</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java八大排序算法&quot;&gt;&lt;a href=&quot;#Java八大排序算法&quot; class=&quot;headerlink&quot; title=&quot;Java八大排序算法&quot;&gt;&lt;/a&gt;Java八大排序算法&lt;/h1&gt;
    
    </summary>
    
      <category term="Java数据结构与算法" scheme="http://yoursite.com/categories/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java数据结构与算法概览</title>
    <link href="http://yoursite.com/2021/02/19/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2021/02/19/Java数据结构与算法/Java数据结构与算法概览/</id>
    <published>2021-02-19T08:04:53.000Z</published>
    <updated>2021-02-19T08:08:29.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java数据结构与算法概览"><a href="#Java数据结构与算法概览" class="headerlink" title="Java数据结构与算法概览"></a>Java数据结构与算法概览</h1><a id="more"></a><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>1、数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。</p><p>2、数据元素之间的相互关系包括：数据的逻辑结构、数据的存储结构、数据的运算结构。</p><p>3、数据结构的设计过程分为：抽象层、数据结构层、实现层。</p><h3 id="逻辑结构分类"><a href="#逻辑结构分类" class="headerlink" title="逻辑结构分类"></a>逻辑结构分类</h3><p>线性数据结构：数组，线性表，栈，队列，串等。</p><p>非线性数据结构：多维数组，集合，树，图，散列表(hash)。</p><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>定义：树形结构，作者觉得它是一种特殊的链形数据结构。最少有一个根节点组成，可以有多个子节点。树，显然是由递归算法组成。</p><p>种类：</p><p>（1）二叉树：每个节点最多含有两个子节点的树称为二叉树。</p><ul><li>1）一般二叉树：无限制，每个子节点的父亲节点不一定有两个子节点的二叉树成为一般二叉树。</li><li>2）完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</li><li>3）满二叉树：所有的节点都是二叉的二叉树成为满二叉树。</li></ul><p>（2）二叉搜索树/BST：二叉排序树、二叉查找树。是有序的。要点：如果不为空，那么其左子树节点的值都小于根节点的值；右子树节点的值都大于根节点的值。</p><ul><li>1）二叉平衡树：二叉搜索树，是有序的排序树，但左右两边包括子节点不一定平衡，而二叉平衡树是排序树的一种，并且加点条件，就是任意一个节点的两个叉的深度差不多（比如差值的绝对值小于某个常数，或者一个不能比另一个深出去一倍之类的）。这样的树可以保证二分搜索任意元素都是O(log n)的，一般还附带带有插入或者删除某个元素也是O(log n)的的性质。</li><li>2）AVL树：最早的平衡二叉树之一。windows对进程地址空间的管理用到了AVL树。</li><li>3）红黑树：通过制定了一些红黑标记和左右旋转规则来保证二叉树平衡。</li></ul><p>（3）B树/B-tree：又叫平衡(balance)多路查找树。树中每个结点最多含有m个孩子（m&gt;=2）。它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。</p><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系，通常记为，G=(V,E)。</p><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><p>分为无向图和有向图。</p><p>无向图G1：</p><p><img src="/2021/02/19/Java数据结构与算法/Java数据结构与算法概览/image-20210210105538609.png" alt="image-20210210105538609"></p><p>上面的图是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V1,{E1})。其中，</p><p>（1）V1={A,C,B,F,D,E}。 V2表示由”A,B,C,D,E,F”几个顶点组成的集合。</p><p>（2）E1={&lt;A,B&gt;,&lt;A,C&gt;,&lt;A,D&gt;,&lt;C,D&gt;,&lt;C,E&gt;,&lt;C,F&gt;,&lt;D,C&gt;,&lt;E,D&gt;}。 E1是由矢量&lt;A,B&gt;,矢量&lt;A,C&gt;…等等组成的集合。其中，矢量&lt;A,B)表示由”顶点A”指向”顶点B”的有向边。</p><p>无向图G2：</p><p><img src="/2021/02/19/Java数据结构与算法/Java数据结构与算法概览/image-20210210105554780.png" alt="image-20210210105554780"></p><p>上面的图是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中，</p><p>（1）V1={A,B,C,D,E,F}。 V1表示由”A,B,C,D,E,F”几个顶点组成的集合。</p><p>（2）E1={(A,C),(A,D),(B,C),(D,E),(E,F)}。 E1是由边(A,C),边(A,D)…等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。</p><h5 id="邻接点"><a href="#邻接点" class="headerlink" title="邻接点"></a>邻接点</h5><p>一条边上的两个顶点叫做邻接点。<br>例如，上面无向图中的顶点A和顶点C就是邻接点。<br>在有向图中，除了邻接点之外；还有”入边”和”出边”的概念。<br>顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。<br>例如，上面有向图中的A和C是邻接点；&lt;A,C&gt;是A的出边，还是C的入边。</p><h5 id="度"><a href="#度" class="headerlink" title="度"></a>度</h5><p>在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。<br>例如，上面无向图G2中顶点A的度是2。<br>在有向图中，度还有”入度”和”出度”之分。<br>某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。<br>顶点的度=入度+出度。<br>例如，上面有向图G1中，顶点C的入度是2，出度是3；顶点B的度=2+3=5。</p><h5 id="路径和回路"><a href="#路径和回路" class="headerlink" title="路径和回路"></a>路径和回路</h5><p>路径：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。<br>路径长度：路径中”边的数量”。<br>简单路径：若一条路径上顶点不重复出现，则是简单路径。<br>回路：若路径的第一个顶点和最后一个顶点相同，则是回路。<br>简单回路：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。</p><h5 id="连通图和连通分量"><a href="#连通图和连通分量" class="headerlink" title="连通图和连通分量"></a>连通图和连通分量</h5><p>连通图：对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。 对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。<br>连通分量：非连通图中的各个连通子图称为该图的连通分量。</p><h5 id="权"><a href="#权" class="headerlink" title="权"></a>权</h5><p>带权图如下：</p><p><img src="/2021/02/19/Java数据结构与算法/Java数据结构与算法概览/image-20210210110001284.png" alt="image-20210210110001284"></p><h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><p>图的存储结构，常用的是<strong>邻接矩阵</strong>和<strong>邻接表</strong></p><h5 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h5><p>深度优先搜索（DFS）：递归实现；或者定义栈，使用非递归方法。</p><p>广度优先搜索（BFS）：队列实现，自动查找从一个顶点到另一个相邻顶点的最短路径。</p><h5 id="图的算法"><a href="#图的算法" class="headerlink" title="图的算法"></a>图的算法</h5><p>（1）最短路径问题：Dijkstra算法，算法的思路如下，Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。 然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点， 然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。</p><p>（2）拓扑排序：拓扑排序（Topological Sorting）是一个<strong>有向无环图</strong>（DAG, Directed Acyclic Graph）的所有顶点的线性序列。序列必须满足下面两个条件：一个是每个顶点出现且只出现一次，另一个是若存在一条从顶点A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</p><p>计算方法：</p><ul><li>从DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</li><li>从图中删除该顶点和所有以它为起点的有向边。</li><li>重复1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</li></ul><p>（3）最小生成树：</p><ul><li>Kruskal算法：此算法可以称为 “加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。</li><li>Prime算法：此算法可以称为 “加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点 s 开始，逐渐长大覆盖整个连通网的所有顶点。</li></ul><h5 id="现实应用"><a href="#现实应用" class="headerlink" title="现实应用"></a>现实应用</h5><p>（1）交通流量建模：顶点可以表示街道的十字路口，边表示街道。加权的边可以表示限速或者车道的数量。建模人员可以用这个系统来判断最佳路线及最有可能堵车的街道。</p><p>（2）运输系统：比如，航空公司可以用图来为其飞行系统建模。将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。加权的边可以看作从一个机场到另一个机场的航班成本，或两个机场之间的距离，这取决与建模的对象是什么。</p><p>（3）局域网、广域网等计算机网络</p><p>（4）消费市场：顶点可以用来表示供应商和消费者。</p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>定义：</p><p>（1）Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。</p><p>（2）所谓的Hash算法都是散列算法，把任意长度的输入，变换成固定长度的输出，该输出就是散列值.（如：MD5,SHA1,加解密算法等）</p><p>（3）简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><h5 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h5><p>Java中数据存储方式最底层的两种结构，一种是数组，另一种就是链表。而Hash表就是综合了这两种数据结构。</p><p>例如：HashTable,HashMap，哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。</p><h5 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h5><p>Hash很好的解决了单体应用情况下的数据查找和插入的速度问题。但是毕竟单体应用的储存空间是有限的，所有在分布式环境下，应运而生了一致性Hash算法。</p><p>用意和hashCode的用意一样，只不过它是取模放在不同的IP机器上而已。</p><p>一致性Hash需要注意的就是默认分配的桶比较多些，而当其中一台机器挂了，影响的面比较小一些。</p><p>需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。</p><h3 id="评定"><a href="#评定" class="headerlink" title="评定"></a>评定</h3><p>时间复杂度：算法的时间复杂度是指执行算法所需要的计算工作量。简单理解，算法在规模为n的情况下，一个算法语句执行的次数。</p><p>空间复杂度：算法的空间复杂度是指算法需要消耗的内存空间。简单理解，算法在规模为n的情况下额外消耗的存储空间。</p><h3 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h3><p>查找：顺序查找、二分查找、插值查找、</p><p>排序（八大排序算法）：直接插入排序（Insertion Sort）、希尔排序（Shell Sort）、选择排序（Selection Sort）、堆排序（Heap Sort）、冒泡排序（Bubble Sort）、快速排序（Quick Sort）、归并排序（Merging Sort）、基数排序（Radix Sort）</p><p>其它：分治法、贪心算法、动态规划算法、回溯法、分支限界法</p><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>对称加密算法、非对称加密算法、签名</p><p>常见算法：AES、RSA、CRC、MD5</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java数据结构与算法概览&quot;&gt;&lt;a href=&quot;#Java数据结构与算法概览&quot; class=&quot;headerlink&quot; title=&quot;Java数据结构与算法概览&quot;&gt;&lt;/a&gt;Java数据结构与算法概览&lt;/h1&gt;
    
    </summary>
    
      <category term="Java数据结构与算法" scheme="http://yoursite.com/categories/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法概览" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse的环境配置</title>
    <link href="http://yoursite.com/2021/02/09/%E6%9D%82/Eclipse%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2021/02/09/杂/Eclipse的环境配置/</id>
    <published>2021-02-09T12:11:20.000Z</published>
    <updated>2021-02-10T01:12:51.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Eclipse环境配置"><a href="#Eclipse环境配置" class="headerlink" title="Eclipse环境配置"></a>Eclipse环境配置</h1><a id="more"></a><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="1、修改Eclipse默认工作空间编码集，修改成UTF-8"><a href="#1、修改Eclipse默认工作空间编码集，修改成UTF-8" class="headerlink" title="1、修改Eclipse默认工作空间编码集，修改成UTF-8"></a>1、修改Eclipse默认工作空间编码集，修改成UTF-8</h3><p>路径： Window → Preferences →  General →  Workspace，修改编码集为 UTF-8。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209201308485.png" alt="image-20210209201308485"></p><h3 id="2、修改Eclipse的资源文件编码集，修改成UTF-8"><a href="#2、修改Eclipse的资源文件编码集，修改成UTF-8" class="headerlink" title="2、修改Eclipse的资源文件编码集，修改成UTF-8"></a>2、修改Eclipse的资源文件编码集，修改成UTF-8</h3><p>路径：Window → Preferences →  General →  Content Types，并点击打开Content Types：中的Text下面的Java Properties File。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209201547784.png" alt="image-20210209201547784"></p><h3 id="3、自动化格式所有行"><a href="#3、自动化格式所有行" class="headerlink" title="3、自动化格式所有行"></a>3、自动化格式所有行</h3><p>路径：Window → Preferences →  Java→  Editor  →  Save Actions。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209201742842.png" alt="image-20210209201742842"></p><h3 id="4、设置内容自动提示"><a href="#4、设置内容自动提示" class="headerlink" title="4、设置内容自动提示"></a>4、设置内容自动提示</h3><p>路径：Window → Preferences →  Java→  Editor  →  Content Assist。</p><p>在Auto activation triggers for java对应输入框中输入“.qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM”。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209201922362.png" alt="image-20210209201922362"></p><h3 id="5、修改默认浏览器"><a href="#5、修改默认浏览器" class="headerlink" title="5、修改默认浏览器"></a>5、修改默认浏览器</h3><p>路径：Window → Preferences →  General →  Web Browser。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202043441.png" alt="image-20210209202043441"></p><h3 id="6、Eclipse代码模板的构建"><a href="#6、Eclipse代码模板的构建" class="headerlink" title="6、Eclipse代码模板的构建"></a>6、Eclipse代码模板的构建</h3><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径：Window → Preferences →  Java→  Editor  →  Templates。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202209208.png" alt="image-20210209202209208"></p><p>  代码模板构建操作如下图：</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202251247.png" alt="image-20210209202251247"></p><h3 id="7、Eclipse配置类注释模板和方法注释模板"><a href="#7、Eclipse配置类注释模板和方法注释模板" class="headerlink" title="7、Eclipse配置类注释模板和方法注释模板"></a>7、Eclipse配置类注释模板和方法注释模板</h3><p>路径：Window → Preferences →  Java→ Code Style → Code Templates。</p><p>备注：</p><p>1、将光标放到类名上，按下快捷键 alt+shift+j 会添加类的注释。</p><p>2、将光标放到方法名上，按下快捷键 alt+shift+j 会添加方法的注释。</p><p>配置类的注释模板内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @版权 : Copyright (c) 2020-2021 *********公司技术开发部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 作者姓名(一般是写姓名的拼音)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@E</span>-mail: 邮箱</span></span><br><span class="line"><span class="comment"> * @版本: 1.0</span></span><br><span class="line"><span class="comment"> * @创建日期: $&#123;date&#125; $&#123;time&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> $&#123;type_name&#125;</span></span><br><span class="line"><span class="comment"> * @类描述-Description:  $&#123;todo&#125;(这里用一句话描述这个方法的作用)</span></span><br><span class="line"><span class="comment"> * @修改记录:</span></span><br><span class="line"><span class="comment"> * @版本: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>配置方法的注释模板内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: $&#123;enclosing_method&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $&#123;todo&#125;(这里用一句话描述这个方法的作用)</span></span><br><span class="line"><span class="comment"> * $&#123;tags&#125;    參數描述</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> $&#123;return_type&#125;  返回类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>操作如下图：</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202613197.png" alt="image-20210209202613197"></p><p>配置创建类时的注释模板：</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202928859.png" alt="image-20210209202928859"></p><h3 id="8、Eclipse字体大小设置"><a href="#8、Eclipse字体大小设置" class="headerlink" title="8、Eclipse字体大小设置"></a>8、Eclipse字体大小设置</h3><p>路径：Window → Preferences →  General → Appearance → Colors and Fonts。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209203054240.png" alt="image-20210209203054240"></p><h2 id="环境配置保存"><a href="#环境配置保存" class="headerlink" title="环境配置保存"></a>环境配置保存</h2><p>右键点击Package Explorer，点击Export，导出Perferences。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209203629604.png" alt="image-20210209203629604"></p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209203727742.png" alt="image-20210209203727742"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Eclipse环境配置&quot;&gt;&lt;a href=&quot;#Eclipse环境配置&quot; class=&quot;headerlink&quot; title=&quot;Eclipse环境配置&quot;&gt;&lt;/a&gt;Eclipse环境配置&lt;/h1&gt;
    
    </summary>
    
      <category term="杂" scheme="http://yoursite.com/categories/%E6%9D%82/"/>
    
    
      <category term="杂" scheme="http://yoursite.com/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>递归算法</title>
    <link href="http://yoursite.com/2021/02/09/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/02/09/Java数据结构与算法/递归算法/</id>
    <published>2021-02-09T03:26:25.000Z</published>
    <updated>2021-02-09T08:02:00.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><a id="more"></a><h2 id="尾递归的数学理解"><a href="#尾递归的数学理解" class="headerlink" title="尾递归的数学理解"></a>尾递归的数学理解</h2><p>示例：阶乘f(n) = n * f(n-1)</p><p>以计算f(5)为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f(5)</span><br><span class="line">=&gt;5 * f(4)</span><br><span class="line">=&gt;5 * (4 * f(3))</span><br><span class="line">=&gt;5 * (4 * (3 * f(2)))</span><br><span class="line">=&gt;5 * (4 * (3 * (2 * f(1))))</span><br><span class="line">&lt;=5 * (4 * (3 * (2 * 1))) </span><br><span class="line">&lt;=5 * (4 * (3 * 2)) </span><br><span class="line">&lt;=5 * (4 * 6) </span><br><span class="line">&lt;=5 * 24</span><br><span class="line">&lt;=120</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>备注：=&gt;是一个递进的过程，&lt;=是回归的过程，这就是尾递归的逻辑</span><br><span class="line"><span class="meta">#</span>递归是一个入栈出栈的过程</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归定义：程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有<strong>边界条件</strong>、<strong>递归前进段</strong>和<strong>递归返回段</strong>。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p><p>通俗来讲，递归是函数调用自身函数的一种现象，函数不断引用自身，直到引用对象已知。</p><p>递归三大要素为：<strong>递归前进段</strong>，<strong>边界条件</strong>，<strong>递归返回段</strong></p><p>递归可以总结以下三点：</p><p>（1）明确函数的功能，即需要解决什么样的问题。</p><p>（2）具备边界调节，否则一直递归下去。</p><p>（3）函数的等价关系，则可以理解如何前进，如何返回。</p><p>例如阶乘的函数等价关系为f(n) = n * f(n-1)，这种跟数学归纳法有点类似，但是递归是有限处理并得到最终结果，而数学归纳法是归纳一种现象，且可以无限延生。</p><p>优缺点：</p><p>（1）优点：思路清晰，代码简单；将复杂大问题分解为小问题解决。</p><p>（2）缺点：基于栈内存运气，占空间。</p><p>备注：明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节。千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。</p><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p>边界条件：当n为1的时候结束返回数值1</p><p>函数等价关系：f(n) = n * f(n-1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorialRecursion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 边界条件</span></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数等价关系</span></span><br><span class="line"><span class="keyword">return</span> n * factorialRecursion(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>问题描述：斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34….，即第一项 f(1) = 1,第二项 f(2) = 1…..,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。</p><p>边界条件：当n为1或者2的时候结束返回数值1</p><p>函数等价关系：f(n) = f(n-1) + f(n-2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacciRecursion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 边界条件</span></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数等价关系</span></span><br><span class="line"><span class="keyword">return</span> fibonacciRecursion(n - <span class="number">1</span>) + fibonacciRecursion(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上知乎的理解（侵删）：</p><p><img src="/2021/02/09/Java数据结构与算法/递归算法/image-20210209143340154.png" alt="image-20210209143340154"></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="循环与递归"><a href="#循环与递归" class="headerlink" title="循环与递归"></a>循环与递归</h4><p>循环是有去无回，而递归则是有去有回(因为存在终止条件)。</p><p>例如：</p><p>（1）你用你手中的钥匙打开一扇门，结果去发现前方还有一扇门，紧接着你又用钥匙打开了这扇门，然后你又看到一扇们…但是当你开到某扇门时，发现前方是一堵墙无路可走了，你选择原路返回——这就是递归。</p><p>（2）但是如果你打开一扇门后，同样发现前方也有一扇们，紧接着你又打开下一扇门…直到打开最后一扇门出去，或者一直没有碰到尽头 （死循环）——这就是循环。</p><h4 id="分治算法与递归"><a href="#分治算法与递归" class="headerlink" title="分治算法与递归"></a>分治算法与递归</h4><p>分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。</p><p>分治算法是用迭代的方法将每一次的过程不断重复，每次迭代的结果会作为下次迭代的初始值。分治算法典型案例为二分查找。</p><ul><li>递归能写的，迭代不一定能写。</li><li>迭代能写的，递归一定能完成。</li></ul><h4 id="回溯算法与递归"><a href="#回溯算法与递归" class="headerlink" title="回溯算法与递归"></a>回溯算法与递归</h4><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。</p><p><strong>回溯的思路</strong>基本如下：当前局面下，我们有若干种选择，所以我们对每一种选择进行尝试。如果发现某种选择违反了某些限定条件，此时 return；如果尝试某种选择到了最后，发现该选择是正确解，那么就将其加入到解集中。<br>在这种思想下，我们需要清晰的找出三个要素：<strong>选择 (Options)</strong>，<strong>限制 (Restraints)</strong>，<strong>结束条件 (Termination)</strong>。</p><p>用回溯算法解决问题的一般步骤为:<br>1、定义一个解空间，它包含问题的解。<br>2、利用适于搜索的方法组织解空间。<br>3、利用深度优先法搜索解空间。<br>4、利用限界函数避免移动到不可能产生解的子空间。<br>问题的解空间通常是在搜索问题的解的过程中动态产生的，这是回溯算法的一个重要特性。</p><p>例如探索迷宫问题。</p><p>回溯算法的基本框架如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><h5 id="回溯算法与递归的区别"><a href="#回溯算法与递归的区别" class="headerlink" title="回溯算法与递归的区别"></a>回溯算法与递归的区别</h5><p>递归是一种算法结构。递归会出现在子程序中，形式上表现为直接或间接的自己调用自己。典型的例子是阶乘，计算规律为：n!=n×(n−1)!<br>回溯是一种算法思想，它是用递归实现的。回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。例如有求和问题，给定有 7 个元素的组合 [1, 2, 3, 4, 5, 6, 7]，求加和为 7 的子集。累加计算中，选择 1+2+3+4 时，判断得到结果为 10 大于 7，那么后面的 5, 6, 7 就没有必要计算了。这种方法属于搜索过程中的优化，即“剪枝”功能。<br>用一个比较通俗的说法来解释递归和回溯：<br>我们在路上走着，前面是一个多岔路口，因为我们并不知道应该走哪条路，所以我们需要尝试。尝试的过程就是一个函数。<br>我们选择了一个方向，后来发现又有一个多岔路口，这时候又需要进行一次选择。所以我们需要在上一次尝试结果的基础上，再做一次尝试，即在函数内部再调用一次函数，这就是递归的过程。<br>这样重复了若干次之后，发现这次选择的这条路走不通，这时候我们知道我们上一个路口选错了，所以我们要回到上一个路口重新选择其他路，这就是回溯的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;递归算法&quot;&gt;&lt;a href=&quot;#递归算法&quot; class=&quot;headerlink&quot; title=&quot;递归算法&quot;&gt;&lt;/a&gt;递归算法&lt;/h1&gt;
    
    </summary>
    
      <category term="Java数据结构与算法" scheme="http://yoursite.com/categories/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归算法" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找算法</title>
    <link href="http://yoursite.com/2021/02/08/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/02/08/Java数据结构与算法/二分查找算法/</id>
    <published>2021-02-08T13:44:06.000Z</published>
    <updated>2021-02-09T09:43:54.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h1><a id="more"></a><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>定义：二分查找（binary search）算法又叫折半查找算法，是一种在<strong>有序数组</strong>中，查找某一特定元素的搜索算法。</p><p>使用条件：必须是有序。</p><p>大致流程：搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><p>算法复杂度分析：</p><table><thead><tr><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(logN)</td><td>O(1)</td></tr></tbody></table><p>解决方法：非递归方法、递归方法</p><h2 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化左右指针, [left, right]</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历</span></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line"><span class="comment">// (right + left) / 2</span></span><br><span class="line"><span class="comment">// 目的:防止溢出</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line"><span class="comment">// 返回该数值的位置</span></span><br><span class="line"><span class="keyword">return</span> mid;    </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line"><span class="comment">// 目标值在右边,移动左指针</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line"><span class="comment">// 目标值在左边,移动右指针</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// whild end</span></span><br><span class="line"><span class="comment">// 未找到这个值</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="comment">// binarySearch end</span></span><br></pre></td></tr></table></figure><p>需要注意一下几点：</p><p>1、为什么while循环的条件中是&lt;=，而不是&lt;？</p><p>回答：因为初始化 right 的赋值是 nums.length - 1 ，即最后⼀个元素的索引，⽽不是 nums.length。可以理解为每次搜索空间两端都为闭区间[left， right]；</p><p>while退出条件：</p><p>（1）当找到目标的时候，即mid索引的值等于target的值就返回索引。</p><p>（2）当没有该目标的时候，终止条件为left==right + 1。</p><p>例如数组[1,2,4]，开始查找left和right相邻且指向1、4两个值，我们需要查找的值为3。第一次查找没找到，mid索引为1，则移动左指针mid+1为2；此时跟右指针相等都指向4这个值，进行逻辑判断，此时目标值在该值的左边，则移动右指针mid-1；此时right索引为3，left索引为4，没找到该值，则退出循环返回-1。</p><p>语言描述不够形象，后续补上动图。</p><p>2、为什么要写成left = mid +1，right = mid -1。而不是left = mid，right = mid。</p><p>由于我们的<strong>搜索区间</strong>左右都是闭区间[left，right]，当我们发现mid不是需要找的target时，我们下一步则需要去找[left，mid-1]或者[mid+1，right]。当然我们也可以写成left = mid，right = mid的形式，则需要修改相应的代码。</p><p>3、算法缺陷</p><p>如果有序数组[1,2,2,2,3]，target为2，算法返回的索引是2，结果正确，但是如果我们想得到target的左边界或者右边界的索引（1或者3），这种方法无法处理。</p><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchRecursion</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="comment">// 目的:防止溢出</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line"><span class="comment">// 目标值在右边,向右递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearchRecursion(nums, mid + <span class="number">1</span>, right, target);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line"><span class="comment">// 目标值在左边,向左递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearchRecursion(nums, left, mid - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：判断条件left &lt;= right与left &lt; right的区别。</p><h2 id="二分查找使用场景及优缺点"><a href="#二分查找使用场景及优缺点" class="headerlink" title="二分查找使用场景及优缺点"></a>二分查找使用场景及优缺点</h2><p>二分查找的时间复杂度为O(logN)，具有非常高效的查找算法。除了二分查找，在堆、二叉树的操作时间复杂度也可以为O(logN)。</p><p><strong>优点</strong>：时间复杂度低，用来查找数据效率很高。</p><p><strong>局限性</strong>：</p><p>（1）依赖顺序表结构，例如数组支持的下标随机访问，如果为链表，查找索引的值得时间复杂度为O(N)。</p><p>（2）数据有序，无序数据需要在二分查找之前进行排序，所以二分查找不适合频繁插入删除操作的数据。</p><p>（3）数据量小不适合二分查找，时间复杂度O(logN)是指的时间开销趋势，如果数据量小，顺序遍历的查找跟二分查找速度基本相差不大。</p><p>（4）数据量大也不适合二分查找，由于二分查找底层依赖于数组这类数据结构，如果几个G以上的数据，用数组存储需要连续内存空间，这种是不符合实际的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二分查找算法&quot;&gt;&lt;a href=&quot;#二分查找算法&quot; class=&quot;headerlink&quot; title=&quot;二分查找算法&quot;&gt;&lt;/a&gt;二分查找算法&lt;/h1&gt;
    
    </summary>
    
      <category term="Java数据结构与算法" scheme="http://yoursite.com/categories/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找算法" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java抽象类和接口</title>
    <link href="http://yoursite.com/2021/02/08/Java/%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2021/02/08/Java/基础/深入理解Java抽象类和接口/</id>
    <published>2021-02-08T03:17:36.000Z</published>
    <updated>2021-02-09T01:21:33.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Java抽象类和接口"><a href="#深入理解Java抽象类和接口" class="headerlink" title="深入理解Java抽象类和接口"></a>深入理解Java抽象类和接口</h1><a id="more"></a><p>对于面向对象编程来说，抽象是它的一大特征之一。在Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。</p><h2 id="一、抽象类"><a href="#一、抽象类" class="headerlink" title="一、抽象类"></a>一、抽象类</h2><p>抽象类和抽象方法必须使用abstract关键字进行修饰。</p><p>使用方法：使用extends关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstractDoor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含抽象方法的类称为抽象类，除了定义抽象方法，其它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：</p><p>  1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</p><p>  2）抽象类可以理解成在普通类的基础上拓展定义抽象方法，提供一种模板，由于抽象类是“半成品”，所以不能用来创建对象，即不能被实例化；但可以通过向上转型实例化，参考代理模式。</p><p>  3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。若子类没有完全实现父类所有抽象方法，则该子类也必须定为抽象类。</p><p>  在其他方面，抽象类和普通的类并没有区别。</p><h2 id="二、接口"><a href="#二、接口" class="headerlink" title="二、接口"></a>二、接口</h2><p>接口泛指指供别人调用的方法或者函数，它是对行为的抽象。</p><p>使用方法：使用implements关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeHandle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dealHandle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterHandle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口可以含有变量和方法（且方法不能有具体实现），变量会被隐式地指定为public static final变量（只能是public static final变量，否则编译报错），方法会被隐式地指定为public abstract方法且只能是public abstract方法，即接口中的方法必须全为抽象方法。允许一个类遵循多个特定的接口。</p><ul><li>非抽象类遵循了某个接口，就必须实现该接口中的所有方法。</li><li>抽象类遵循了某个接口，可以不实现该接口中的抽象方法。</li></ul><h2 id="三、抽象类和接口的区别"><a href="#三、抽象类和接口的区别" class="headerlink" title="三、抽象类和接口的区别"></a>三、抽象类和接口的区别</h2><h3 id="1、语法层面的区别"><a href="#1、语法层面的区别" class="headerlink" title="1、语法层面的区别"></a>1、语法层面的区别</h3><p>1）方法：抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法<br>2）成员变量：抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的<br>3）静态代码块和静态方法：接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><h3 id="2、设计层面的区别"><a href="#2、设计层面的区别" class="headerlink" title="2、设计层面的区别"></a>2、设计层面的区别</h3><p>1）抽象类是对一种事物的抽象、对类抽象，而接口是对行为的抽象。<strong>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象</strong>。</p><p>eg：例如，飞机和鸟都具有飞的属性，可以设计一个接口Fly，包含Fly()方法。如果有不同类别的战斗机，可以继承飞机抽象类。</p><p>总结：<strong>继承是一个“是不是”的关系，而接口是“有没有”的关系</strong>。如果一个类继承了一个抽象类，那么子类也是属于这个抽象类的一种。而接口只是约束行为（方法）。</p><p>2）抽象类可以作为很多子类的父类，它是一种模板式设计；而接口是一种行为规范，它是一种辐射式设计。</p><p>模板式设计：如果两个B、C子类继承C抽象类，B、C子类公共部分就是模板A，如果公共部分需要改动，只需要改动模板A了，不需要重新改动B、C子类。</p><p>辐射式设计：比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstractDoor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterfaceDoor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p><p>　　1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p><p>　　2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p><p>​    从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类衍生接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterfaceAlarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAlarmDoor</span> <span class="keyword">extends</span> <span class="title">TestAbstractDoor</span> <span class="keyword">implements</span> <span class="title">TestInterfaceAlarm</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深入理解Java抽象类和接口&quot;&gt;&lt;a href=&quot;#深入理解Java抽象类和接口&quot; class=&quot;headerlink&quot; title=&quot;深入理解Java抽象类和接口&quot;&gt;&lt;/a&gt;深入理解Java抽象类和接口&lt;/h1&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java面向对象" scheme="http://yoursite.com/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>UML类图的使用</title>
    <link href="http://yoursite.com/2021/02/07/%E6%9D%82/UML%E7%B1%BB%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2021/02/07/杂/UML类图的使用/</id>
    <published>2021-02-07T07:14:36.000Z</published>
    <updated>2021-02-07T07:15:20.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UML类图的使用"><a href="#UML类图的使用" class="headerlink" title="UML类图的使用"></a>UML类图的使用</h1><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>UML类图包含6种关系：继承关系、实现关系、依赖关系、关联关系、聚合关系、组合关系</p><h2 id="1、继承关系"><a href="#1、继承关系" class="headerlink" title="1、继承关系"></a>1、继承关系</h2><p>一个类（子类、子接口）继承另外一个类（称为父类、父接口）的功能，并可以增加自己新功能的能力。在Java继承关系中通过关键字<strong>extends</strong>标识。</p><p>图形表示：<strong>空心三角箭头，实线</strong>表示，从子类指向父类，或者子接口指向父接口；</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204163339948.png" alt="image-20210204163339948"></p><h3 id="2、实现关系"><a href="#2、实现关系" class="headerlink" title="2、实现关系"></a>2、实现关系</h3><p>一个Class类实现interface接口（可以多个）的功能，是类与接口之间的关系。在Java中实现关系通过<strong>implements</strong>明确标识。</p><p>图形表示：<strong>空心三角箭头，虚线</strong>表示。从类指向接口。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204163735026.png" alt="image-20210204163735026"></p><h3 id="3、依赖关系"><a href="#3、依赖关系" class="headerlink" title="3、依赖关系"></a>3、依赖关系</h3><p>依赖是一个类A使用到了另一个类B，关系较弱，偶尔调用另一对象或者临时调用，类B的改动会影响到类A。在代码层面为，类B作为参数被类A中的某个method方法中使用。</p><p>图形表示：<strong>箭头，虚线</strong>。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204172535428.png" alt="image-20210204172535428"></p><h3 id="4、关联关系"><a href="#4、关联关系" class="headerlink" title="4、关联关系"></a>4、关联关系</h3><p>关联体现两个类之间有强依赖关系，这种关系比依赖更强，不存在偶然性或者临时性，一般是长期性质的，并且两个类之间的关系是平等的。关联可以是单向、双向的，在代码层面，被关联类B以类的属性存在于关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。</p><p>图形表示：<strong>箭头，实线</strong>。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204173144804.png" alt="image-20210204173144804"></p><h3 id="5、聚合关系"><a href="#5、聚合关系" class="headerlink" title="5、聚合关系"></a>5、聚合关系</h3><p>聚合是关联关系的一种特例，体现整体与部分的关系，即has-a的关系。聚合关系整体与部分可以分离，可以跟组合关系做对比。</p><p>例如：家庭和孩子的关系，一个家庭里面可以没有孩子，可以有也可以没有。</p><p>图形表示：<strong>空心棱形，实线</strong>。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204173444209.png" alt="image-20210204173444209"></p><h3 id="6、组合关系"><a href="#6、组合关系" class="headerlink" title="6、组合关系"></a>6、组合关系</h3><p>组合是关联关系的一种特例，体现contains-a的关系，比聚合更强。整体与部分不可分。</p><p>例如：人和大脑的关系，人必须有大脑。</p><p>图形表示：<strong>实心棱形，实线</strong>。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204174510211.png" alt="image-20210204174510211"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UML类图的使用&quot;&gt;&lt;a href=&quot;#UML类图的使用&quot; class=&quot;headerlink&quot; title=&quot;UML类图的使用&quot;&gt;&lt;/a&gt;UML类图的使用&lt;/h1&gt;
    
    </summary>
    
      <category term="杂" scheme="http://yoursite.com/categories/%E6%9D%82/"/>
    
    
      <category term="UML" scheme="http://yoursite.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://yoursite.com/2021/02/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/02/05/设计模式/工厂模式/</id>
    <published>2021-02-05T12:45:12.000Z</published>
    <updated>2021-02-07T02:14:11.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><a id="more"></a><p>介绍简单工厂模式和工厂方法模式。</p><h2 id="1、简单工厂模式（静态工厂方法模式）"><a href="#1、简单工厂模式（静态工厂方法模式）" class="headerlink" title="1、简单工厂模式（静态工厂方法模式）"></a>1、简单工厂模式（静态工厂方法模式）</h2><p><strong>定义</strong>：简单工厂模式属于创建型模式，又被称为静态工厂方法模式，这是一个工厂对象决定创建出哪一种产品类的实例。</p><p><img src="/2021/02/05/设计模式/工厂模式/image-20210204213840439.png" alt="image-20210204213840439"></p><p>（1）抽象产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"><span class="comment">// 产品的抽象方法,由具体的产品类实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）具体产品类</p><p>继承抽象类，具体实现三种产品类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体产品类,联想计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"联想计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类,惠普计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"惠普计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类,华硕计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"华硕计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）工厂类</p><p>通过传入具体产品类别来实例化对应对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title">createComputer</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">Computer mComputer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"lenovo"</span>:</span><br><span class="line">mComputer = <span class="keyword">new</span> LenovoComputer();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"hp"</span>:</span><br><span class="line">mComputer = <span class="keyword">new</span> HpComputer();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"asus"</span>:</span><br><span class="line">mComputer = <span class="keyword">new</span> AsusComputer();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mComputer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）客户端调用工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端调用工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatComputer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ComputerFactory.createComputer(<span class="string">"hp"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单工厂模式优缺点</strong></p><p>优点：根据参数获取对应的类实例，避免类的直接实例化。</p><p>缺点：可实例化对象在编译期间就确定。如果需要新增加类型，则需要重新修改工厂类方法。简单工厂需要知道所有要生成的类型，当子类过多或者层次过多时候不宜使用。</p><h2 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h2><p><strong>定义</strong>：定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到子类。</p><p><img src="/2021/02/05/设计模式/工厂模式/image-20210204220304332.png" alt="image-20210204220304332"></p><p>（1）抽象产品类（同上、重复内容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"><span class="comment">// 产品的抽象方法,由具体的产品类实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）具体产品类（同上、重复内容）</p><p>继承抽象类，具体实现三种产品类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体产品类,联想计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"联想计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类,惠普计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"惠普计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类,华硕计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"华硕计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）抽象工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Computer&gt; <span class="function">T <span class="title">createComputer</span><span class="params">(Class&lt;T&gt; clz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）具体工厂</p><p>具体工厂继承抽象工厂，通过反射来生产不同厂家的计算机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComputerFactor</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Computer&gt; <span class="function">T <span class="title">creatComputer</span><span class="params">(Class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">Computer computer = <span class="keyword">null</span>;</span><br><span class="line">String className = clz.getName();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 通过反射来实例化不同厂家的计算机</span></span><br><span class="line">computer = (Computer) Class.forName(className).newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T)computer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）客户端调用</p><p>通过反射和抽象工厂来实例化不同厂家计算机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 抽象工厂实例化</span></span><br><span class="line">ComputerFactory computerFactory = <span class="keyword">new</span> MyComputerFactor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射和抽象工厂来实例化不同厂家计算机</span></span><br><span class="line">LenovoComputer mLenovoComputer = computerFactory.createComputer(LenovoComputer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">mLenovoComputer.start();</span><br><span class="line"></span><br><span class="line">HpComputer mHpComputer = computerFactory.createComputer(HpComputer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">mHpComputer.start();</span><br><span class="line"></span><br><span class="line">AsusComputer mAsusComputer = computerFactory.createComputer(AsusComputer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">mAsusComputer.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工厂方法模式优缺点</strong></p><p>解决需求更改后不用修改工厂类，而是直接创建具体产品类，通过抽象工厂模式来实例化具体产品对象，解决了与具体产品的依赖，符合开放封闭原则。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h1&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="工厂模式" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客迁移记录</title>
    <link href="http://yoursite.com/2021/02/05/%E6%9D%82/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2021/02/05/杂/hexo博客迁移记录/</id>
    <published>2021-02-05T12:43:57.000Z</published>
    <updated>2021-02-07T02:14:11.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo博客迁移记录"><a href="#hexo博客迁移记录" class="headerlink" title="hexo博客迁移记录"></a>hexo博客迁移记录</h1><a id="more"></a><p>1、新建hexo分支</p><p>git checkout -b hexo</p><p>并将推送分支并merge到远程分支</p><p>git push origin hexo:hexo</p><p>2、删除hexo下面除了.git所有内容</p><p>3、将现有hexo目录拷贝到hexo分支下</p><p><img src="/2021/02/05/杂/hexo博客迁移记录/image-20210205105140194.png" alt="image-20210205105140194"></p><p>修改.gitgnore里的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><p>清除npm缓存</p><p>删除node_model文件夹，删除package.lock.json文件</p><p>npm cache clean –force</p><p>使用淘宝npm镜像</p><p>npm install cnpm -g –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><p>然后使用cnpm安装模块</p><p>cnpm install hexo</p><p>cnpm install</p><p>cnpm install hexo-deployer-git</p><p>hexo c &amp; hexo g &amp; hexo s</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hexo博客迁移记录&quot;&gt;&lt;a href=&quot;#hexo博客迁移记录&quot; class=&quot;headerlink&quot; title=&quot;hexo博客迁移记录&quot;&gt;&lt;/a&gt;hexo博客迁移记录&lt;/h1&gt;
    
    </summary>
    
      <category term="杂" scheme="http://yoursite.com/categories/%E6%9D%82/"/>
    
    
      <category term="杂" scheme="http://yoursite.com/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/02/04/设计模式/单例模式/</id>
    <published>2021-02-04T02:40:49.000Z</published>
    <updated>2021-02-07T02:14:11.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><a id="more"></a><p>定义：保证一个类只有一个实例，并提供访问它的全局访问点。</p><p><img src="/2021/02/04/设计模式/单例模式/image-20210204091623224.png" alt="image-20210204091623224"></p><p>Client为客户端，Singleton为单例类，通过调用getInstance()方法获取实例对象</p><p>以下介绍单例模式的6种写法，其中第一种静态内部类单例模式是常用方法，后面5种介绍其他方法，并分析其优缺点。</p><h2 id="6种写法"><a href="#6种写法" class="headerlink" title="6种写法"></a>6种写法</h2><h3 id="1、静态内部类单例模式"><a href="#1、静态内部类单例模式" class="headerlink" title="1、静态内部类单例模式"></a>1、静态内部类单例模式</h3><p>静态内部类单例模式是推荐使用方法，在第一次加载Singleton类不会初始化sInstance，只有第一次调用getInstance()方法时JVM虚拟机加载SingletonHolder内部类并初始化sInstance。</p><p>优点：既能保证线程安全，也能保证Singleton的唯一性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHolder.sInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、枚举单例"><a href="#2、枚举单例" class="headerlink" title="2、枚举单例"></a>2、枚举单例</h3><p>默认枚举实例是线程安全的，并且在任何情况都是单例模式。普通类在反序列化的时候，会重新创建对象。由于枚举枚举默认继承Enum类，在枚举类中禁用了readObject方法，不会因为序列化的时候破坏单例，并且在反序列化的时候不会去重新创建对象。</p><p>优点：杜绝在反序列化的时候重新创建对象。</p><p>确定：使用较少，可读性不高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义枚举单例</span></span><br><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举单例方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、饿汉模式"><a href="#3、饿汉模式" class="headerlink" title="3、饿汉模式"></a>3、饿汉模式</h3><p>优点：基于类加载机制，避免多线程问题；获取对象较快。</p><p>缺点：在类加载时进行初始化，加载较慢；如果从未获取该实例，造成内存浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、懒汉模式（线程不安全）"><a href="#4、懒汉模式（线程不安全）" class="headerlink" title="4、懒汉模式（线程不安全）"></a>4、懒汉模式（线程不安全）</h3><p>在内部声明静态变量，只在调用的时候做初始化；</p><p>缺点：多线程不能正常工作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、懒汉模式（线程安全）"><a href="#5、懒汉模式（线程安全）" class="headerlink" title="5、懒汉模式（线程安全）"></a>5、懒汉模式（线程安全）</h3><p>将获取实例方法变成同步块方法，保证线程安全。</p><p>缺点：每次调用都需要同步，造成不必要的同步开销；（不建议使用该方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、双重检查模式（DCL）"><a href="#6、双重检查模式（DCL）" class="headerlink" title="6、双重检查模式（DCL）"></a>6、双重检查模式（DCL）</h3><p>在获取实例方法中进行两次判空，第一次是避免不必要的同步，第二次是判断Singleton类为空时创建实例。</p><p>优点：资源利用率高，解决资源消耗、多余同步、线程安全问题；</p><p>缺点：在某些情况会出现失效的问题，也就是DCL失效；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式参考书籍和设计思想</title>
    <link href="http://yoursite.com/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2021/02/04/设计模式/设计模式参考书籍和设计思想/</id>
    <published>2021-02-04T02:20:42.000Z</published>
    <updated>2021-02-07T02:14:11.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式参考书籍和设计思想"><a href="#设计模式参考书籍和设计思想" class="headerlink" title="设计模式参考书籍和设计思想"></a>设计模式参考书籍和设计思想</h1><a id="more"></a><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h3><p>单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、迪米特原则、接口隔离原则</p><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p><strong>定义</strong>：一个类，应该有一个引起它变化的原因</p><p>松耦合，一个类只做一个事情。</p><h4 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h4><p><strong>定义</strong>：类、模块、函数等都应该是可拓展，但不可修改</p><p>一个对于拓展是开放的，一个对于修改是封闭的。传统方法，需求变化需要将类重新修改一遍；模式方法，如果需求更改，通过拓展的方式实现，而不是修改原有代码；</p><p>开放封闭原则解决方法：增加一个抽象的功能类，让添加、删除和查询等作为这个抽象类的子类。</p><p><strong>目的</strong>：如果新增功能，无须修改原有类，只需要添加一个功能类的子类实现原有功能类的方法就行了。</p><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p><strong>定义</strong>：所有引用基类（父类）的地方必须能透明地使用其子类的对象</p><p>在程序中将基类对象替换为子类对象，程序正常；反之，子类对象不一定能够使用基类对象；</p><p>由于使用基类对象的地方都可以使用子类对象，因此，在程序中尽量使用基类类型来进行对象定义，而在运行的时候再确定其子类的类型，用子类对象来替换父类对象。（向下转型？）</p><p>尽量将基类设计为抽象类或者接口，让子类继承父类实现父接口，并实现父类声明方法。</p><p><strong>目的</strong>：运行时，子类示例替换父类实例，可以方便拓展系统功能，同时无须修改原有子类代码；增加新功能可以通过增加一个新的子类来实现。</p><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p><strong>定义</strong>：高层模块不应该依赖底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><p>抽象：接口类或者抽象类；细节：实现类；高层模块：调用端；底层模块：具体实现类；</p><p>目的：模块之间依赖通过抽象发生，实现类不产生直接依赖关系，依赖关系通过接口或者抽象类产生；如果实现类与实现类直接依赖细节，则产生耦合关系。其目的也是为了松耦合。</p><h4 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h4><p><strong>定义</strong>：一个软件实体尽可能少于其它实体发生相互作用。</p><p>如果模块修改，尽可能少影响其它模块。如果其中一个对象需要调用另一个对象的方法，可以通过第三者转发这个调用。</p><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p><strong>定义</strong>：一个类对另一个类的依赖尽可能建立在最小接口上。</p><p>建立单一接口，不要建立庞大的臃肿的接口；尽可能细化接口，接口中方法尽量少。也就是为各个类建立专用的接口。</p><h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p>GoF提出23种</p><h4 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h4><p>单例模式</p><p>工厂方法模式</p><p>抽象工厂模式</p><p>创建者模式</p><p>原型模式</p><h4 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h4><p>设配器模式</p><p>装饰模式</p><p>代理模式</p><p>外观模式</p><p>桥接模式</p><p>组合模式</p><p>享元模式</p><h4 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h4><p>策略模式</p><p>模板方法模式</p><p>观察者模式</p><p>迭代器模式</p><p>责任链模式</p><p>命令模式</p><p>备忘录模式</p><p>状态模式</p><p>访问者模式</p><p>中介模式</p><p>解释器模式</p><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><p>《Android进阶之光》    刘望舒</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式参考书籍和设计思想&quot;&gt;&lt;a href=&quot;#设计模式参考书籍和设计思想&quot; class=&quot;headerlink&quot; title=&quot;设计模式参考书籍和设计思想&quot;&gt;&lt;/a&gt;设计模式参考书籍和设计思想&lt;/h1&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计思想" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
</feed>
