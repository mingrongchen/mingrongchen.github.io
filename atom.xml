<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MingRong&#39;s Boat</title>
  
  <subtitle>O Captain! My Captain!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-23T07:03:01.475Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>MingRongChen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux之Shell脚本基础</title>
    <link href="http://yoursite.com/2021/02/23/Linux%E7%9B%B8%E5%85%B3/Linux%E4%B9%8BShell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/02/23/Linux相关/Linux之Shell脚本基础/</id>
    <published>2021-02-23T05:35:04.000Z</published>
    <updated>2021-02-23T07:03:01.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux之Shell脚本基础"><a href="#Linux之Shell脚本基础" class="headerlink" title="Linux之Shell脚本基础"></a>Linux之Shell脚本基础</h1><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Shell脚本（Shell script），是一种为shell编写的脚本程序 ，是一种解释器语言，与JavaScript、python、php类似。</p><h2 id="Shell脚本编程"><a href="#Shell脚本编程" class="headerlink" title="Shell脚本编程"></a>Shell脚本编程</h2><h3 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi script.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 内容</span><br><span class="line">echo "My first script ..."</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 运行脚本</span><br><span class="line">chmod a+x script.sh</span><br><span class="line">./script.sh</span><br></pre></td></tr></table></figure><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 注释：使用#开头</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 变量使用</span><br><span class="line">VAR="test"</span><br><span class="line">echo "$VAR"</span><br><span class="line">echo "$&#123;VAR&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 可以把命令执行后的输入结果赋值给一个变量</span><br><span class="line">LIST=$(ls)</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试主要用于条件判断。<code>[ condition-to-test-for ]</code> ，如<code>[ -e /etc/passwd ]</code>，注意的是<code>[]</code><strong>前后必须有空格</strong>，如<code>[-e /etc/passwd]</code>是错误的写法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 文件测试</span><br><span class="line">-d FILE_NAM  # True if FILE_NAM is a directory 是否目录</span><br><span class="line">-e FILE_NAM  # True if FILE_NAM exists 文件是否存在</span><br><span class="line">-f FILE_NAM  # True if FILE_NAM exists and is a regular file 文件是否存在且是普通文件</span><br><span class="line">-r FILE_NAM  # True if FILE_NAM is readable 文件是否可读</span><br><span class="line">-s FILE_NAM  # True if FILE_NAM exists and is not empty 文件是否存在且不为空</span><br><span class="line">-w FILE_NAM  # True if FILE_NAM has write permission 文件是否有可写权限</span><br><span class="line">-x FILE_NAM  # True if FILE_NAM is executable 文件是否可执行</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 字符串测试</span><br><span class="line">-z STRING  # True if STRING is empty</span><br><span class="line">-n STRING  # True if STRING is not empty</span><br><span class="line">STRING1 = STRIN2 # True if strings are equal</span><br><span class="line">STRING1 != STRIN2 # True if strings are not equal</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 算术测试</span><br><span class="line">var1 -eq var2  # True if var1 is equal to var2 等于</span><br><span class="line">var1 -ne var2  # True if var1 not equal to var2 不等于</span><br><span class="line">var1 -lt var2  # True if var1 is less than var2 小于</span><br><span class="line">var1 -le var2  # True if var1 is less than or equal to var2 小于等于</span><br><span class="line">var1 -gt var2  # True if var1 is greater than var2 大于</span><br><span class="line">var1 -ge var2  # True if var1 is greater than or equal to var2 大于等于</span><br></pre></td></tr></table></figure><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>注意：判断语句中[]两边仅左右空格，且中间语句不要有空格。</p><h4 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if-elif-else语句"></a>if-elif-else语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if [ condition-is-true ]</span><br><span class="line">then</span><br><span class="line">  command 1</span><br><span class="line">elif [ condition-is-true ]</span><br><span class="line">then</span><br><span class="line">  command 2</span><br><span class="line">elif [ condition-is-true ]</span><br><span class="line">then</span><br><span class="line">  command 3</span><br><span class="line">else</span><br><span class="line">  command 4</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 示例</span><br><span class="line">if [ $1="one" ]</span><br><span class="line">then</span><br><span class="line">        echo "one"</span><br><span class="line">elif [ $1="two" ]</span><br><span class="line">then</span><br><span class="line">        echo "two"</span><br><span class="line">else</span><br><span class="line">        echo "none"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">case "$VAR" in</span><br><span class="line">  pattern_1)</span><br><span class="line">    # commands when $VAR matches pattern 1</span><br><span class="line">    ;;</span><br><span class="line">  pattern_2)</span><br><span class="line">    # commands when $VAR matches pattern 2</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    # This will run if $VAR doesnt match any of the given patterns</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 示例</span><br><span class="line">case "$1" in</span><br><span class="line">        [yY] | [yY][eE][sS])</span><br><span class="line">                echo "Yes"</span><br><span class="line">                ;;</span><br><span class="line">        [nN] | [nN][oO])</span><br><span class="line">                echo "No"</span><br><span class="line">                ;;</span><br><span class="line">        *)</span><br><span class="line">                echo "none"</span><br><span class="line">                ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>((表达;条件;末尾循环))，注意是两个括号，否则会报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">for VARIABLE_NAME in ITEM_1 ITEM_N</span><br><span class="line">do</span><br><span class="line">  command 1</span><br><span class="line">  command 2</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  command N</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for (( VAR=1;VAR&lt;N;VAR++ ))</span><br><span class="line">do</span><br><span class="line">  command 1</span><br><span class="line">  command 2</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  command N</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 示例一</span><br><span class="line">COLORS="red green blue"</span><br><span class="line">for COLOR in $COLORS</span><br><span class="line">do</span><br><span class="line">        echo "The color is: $&#123;COLOR&#125;"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>示例二</span><br><span class="line">for (( VAR=0;VAR&lt;3;VAR++ ))</span><br><span class="line">do</span><br><span class="line">        echo "VAR is : $&#123;VAR&#125;"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">while [ CONNDITION_IS_TRUE ]</span><br><span class="line">do</span><br><span class="line"><span class="meta">  #</span> Commands will change he entry condition</span><br><span class="line">  command 1</span><br><span class="line">  command 2</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  command N</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 示例</span><br><span class="line">VAR_TWO=0</span><br><span class="line">while [ $VAR_TWO -le 3 ]</span><br><span class="line">do</span><br><span class="line">        echo "VAR_TWO is : $&#123;VAR_TWO&#125;"</span><br><span class="line">        ((VAR_TWO++))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>当我们运行脚本的时候，可以传递参数供脚本内部使用<code>$ ./script.sh param1 param2 param3 param4</code>这些参数将被存储在特殊的变量中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>0 -- "script.sh"</span><br><span class="line"><span class="meta">$</span>1 -- "param1"</span><br><span class="line"><span class="meta">$</span>2 -- "param2"</span><br><span class="line"><span class="meta">$</span>3 -- "param3"</span><br><span class="line"><span class="meta">$</span>4 -- "param4"</span><br><span class="line"><span class="meta">$</span># -- 代表参数个数</span><br><span class="line"><span class="meta">$</span>@ -- array of all positional parameters "param1""param2""param3""param4"</span><br><span class="line"><span class="meta">$</span>* -- 代表"param1 param2 param3 param4"，整体中间以空格分开</span><br></pre></td></tr></table></figure><h4 id="退出码"><a href="#退出码" class="headerlink" title="退出码"></a>退出码</h4><p>可以自定义</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exit 0</span><br><span class="line">exit 1</span><br><span class="line">exit 2</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">exit 255</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>可以把一些列的命令或语句定义在一个函数内，从程序的其他地方调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function function_name() &#123;</span><br><span class="line">    command 1</span><br><span class="line">    command 2</span><br><span class="line">    command 3</span><br><span class="line">      ...</span><br><span class="line">      ...</span><br><span class="line">    command N</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 示例</span><br><span class="line">function myFunc () &#123;</span><br><span class="line">        echo "My function ..."</span><br><span class="line">        if [ $# -eq 1 ]</span><br><span class="line">        then</span><br><span class="line">                echo "My function one"</span><br><span class="line">                return $[$#]</span><br><span class="line">        elif [ $# -eq 2 ]</span><br><span class="line">        then</span><br><span class="line">                echo "My function two"</span><br><span class="line">                return $[$#]</span><br><span class="line">        else</span><br><span class="line">                echo "My function none"</span><br><span class="line">                return $[$#]</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line">myFunc</span><br><span class="line">echo "one is : $?"</span><br><span class="line">myFunc one</span><br><span class="line">echo "two is : $?"</span><br><span class="line">myFunc one two</span><br><span class="line">echo "three is : $?"</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux之Shell脚本基础&quot;&gt;&lt;a href=&quot;#Linux之Shell脚本基础&quot; class=&quot;headerlink&quot; title=&quot;Linux之Shell脚本基础&quot;&gt;&lt;/a&gt;Linux之Shell脚本基础&lt;/h1&gt;
    
    </summary>
    
      <category term="Linux相关" scheme="http://yoursite.com/categories/Linux%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Shell脚本" scheme="http://yoursite.com/tags/Shell%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Linux之ps命令</title>
    <link href="http://yoursite.com/2021/02/23/Linux%E7%9B%B8%E5%85%B3/Linux%E4%B9%8Bps%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2021/02/23/Linux相关/Linux之ps命令/</id>
    <published>2021-02-23T02:41:48.000Z</published>
    <updated>2021-02-23T02:49:19.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux之ps命令"><a href="#Linux之ps命令" class="headerlink" title="Linux之ps命令"></a>Linux之ps命令</h1><a id="more"></a><p>ps命令为我们提供了一次性的查看进程结果，它所提供的查看结果不是动态连续的；如果想对进程时间监控，应该用top工具</p><p>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p><p><strong>linux上进程有5种状态:</strong> </p><p>1、运行(正在运行或在运行队列中等待) </p><p>2、中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) </p><p>3、不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) </p><p>4、僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) </p><p>5、停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) </p><p><strong>ps工具标识进程的5种状态码:</strong> </p><p>1、D 不可中断 uninterruptible sleep (usually IO) </p><p>2、R 运行 runnable (on run queue) </p><p>3、S 中断 sleeping </p><p>4、T 停止 traced or stopped </p><p>5、Z 僵死 a defunct (”zombie”) process</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 3．命令参数：</span><br><span class="line">a  显示所有进程</span><br><span class="line">-a 显示同一终端下的所有程序</span><br><span class="line">-A 显示所有进程</span><br><span class="line">c  显示进程的真实名称</span><br><span class="line">-N 反向选择</span><br><span class="line">-e 等于“-A”</span><br><span class="line">e  显示环境变量</span><br><span class="line">f  显示程序间的关系</span><br><span class="line">-H 显示树状结构</span><br><span class="line">r  显示当前终端的进程</span><br><span class="line">T  显示当前终端的所有程序</span><br><span class="line">u  指定用户的所有进程</span><br><span class="line">-au 显示较详细的资讯</span><br><span class="line">-aux 显示所有包含其他使用者的行程 </span><br><span class="line">-C&lt;命令&gt; 列出指定命令的状况</span><br><span class="line">--lines&lt;行数&gt; 每页显示的行数</span><br><span class="line">--width&lt;字符数&gt; 每页显示的字符数</span><br><span class="line">--help 显示帮助信息</span><br><span class="line">--version 显示版本显示</span><br><span class="line">-o 自定义输出字段 我们设定显示字段为 stat（状态）, ppid（进程父id）, pid(进程id)，cmd（命令）这四个参数</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 用例</span><br><span class="line">ps -A    # 显示所有进程信息</span><br><span class="line">ps -u root    # 显示指定用户信息</span><br><span class="line">ps -ef    # 显示所有进程信息</span><br><span class="line">ps -ef | grep ssh    # ps与grep常用组合用法，查找指定进程</span><br><span class="line">ps -l    # 将目前属于您自己这次登入的PID与相关信息列出来</span><br><span class="line">ps -aux    # 列出目前所有正在内存中的程序</span><br><span class="line">ps -axjf    # 列出类似程序树的程序显示</span><br><span class="line">ps -aux |more    # 可以用管道| 和 more连接起来分页查看</span><br><span class="line">ps -aux &gt; ps001.txt    # 将所有进程信息重定向输出到指定文件中</span><br><span class="line">ps -A -o stat,ppid,pid,cmd | grep -e '^[Zz]'</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux之ps命令&quot;&gt;&lt;a href=&quot;#Linux之ps命令&quot; class=&quot;headerlink&quot; title=&quot;Linux之ps命令&quot;&gt;&lt;/a&gt;Linux之ps命令&lt;/h1&gt;
    
    </summary>
    
      <category term="Linux相关" scheme="http://yoursite.com/categories/Linux%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux之用户态和内核态</title>
    <link href="http://yoursite.com/2021/02/23/Linux%E7%9B%B8%E5%85%B3/Linux%E4%B9%8B%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"/>
    <id>http://yoursite.com/2021/02/23/Linux相关/Linux之用户态和内核态/</id>
    <published>2021-02-23T02:38:41.000Z</published>
    <updated>2021-02-23T02:40:14.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux之用户态和内核态"><a href="#Linux之用户态和内核态" class="headerlink" title="Linux之用户态和内核态"></a>Linux之用户态和内核态</h1><a id="more"></a><h2 id="一、Linux的体系结构"><a href="#一、Linux的体系结构" class="headerlink" title="一、Linux的体系结构"></a>一、Linux的体系结构</h2><p><img src="/2021/02/23/Linux相关/Linux之用户态和内核态/linux%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.png" alt="linux体系架构"></p><h3 id="内核态访问方式"><a href="#内核态访问方式" class="headerlink" title="内核态访问方式"></a>内核态访问方式</h3><p>用户态可以访问内核态资源可以通过一下三种方式访问。</p><p>1）系统调用</p><p>2）库函数</p><p>3）Shell脚本</p><p><strong>系统调用</strong>：如上图所示，从宏观上来看，Linux操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p><p>系统调用是操作系统的最小功能单位，这些系统调用根据不同的应用场景可以进行扩展和裁剪，现在各种版本的Unix实现都提供了不同数量的系统调用，如Linux的不同版本提供了240-260个系统调用，FreeBSD大约提供了320个（reference：UNIX环境高级编程）。我们可以把系统调用看成是一种不能再化简的操作（类似于原子操作，但是不同概念），有人把它比作一个汉字的一个“笔画”，而一个“汉字”就代表一个上层应用，我觉得这个比喻非常贴切。因此，有时候如果要实现一个完整的汉字（给某个变量分配内存空间），就必须调用很多的系统调用。如果从实现者（程序员）的角度来看，这势必会加重程序员的负担，良好的程序设计方法是：重视上层的业务逻辑操作，而尽可能避免底层复杂的实现细节。</p><p> <strong>库函数</strong>：正是为了将程序员从复杂的细节中解脱出来而提出的一种有效方法。它实现对系统调用的封装，将简单的业务逻辑接口呈现给用户，方便用户调用，从这个角度上看，库函数就像是组成汉字的“偏旁”。这样的一种组成方式极大增强了程序设计的灵活性，对于简单的操作，我们可以直接调用系统调用来访问资源，如“人”，对于复杂操作，我们借助于库函数来实现，如“仁”。显然，这样的库函数依据不同的标准也可以有不同的实现版本，如ISO C 标准库，POSIX标准库等。</p><p><strong>Shell</strong>：是一个特殊的应用程序，俗称命令行，本质上是一个命令解释器，它下通系统调用，上通各种应用，通常充当着一种“胶水”的角色，来连接各个小功能程序，让不同程序能够以一个清晰的接口协同工作，从而增强各个程序的功能。同时，Shell是可编程的，它可以执行符合Shell语法的文本，这样的文本称为Shell脚本，通常短短的几行Shell脚本就可以实现一个非常大的功能，原因就是这些Shell语句通常都对系统调用做了一层封装。为了方便用户和系统交互，一般，一个Shell对应一个终端，终端是一个硬件设备，呈现给用户的是一个图形化窗口。我们可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。</p><h3 id="Linux体系细分结构"><a href="#Linux体系细分结构" class="headerlink" title="Linux体系细分结构"></a>Linux体系细分结构</h3><p><img src="/2021/02/23/Linux相关/Linux之用户态和内核态/Linux%E4%BD%93%E7%B3%BB%E7%BB%86%E5%88%86%E7%BB%93%E6%9E%84.jpg" alt="Linux体系细分结构"> </p><p>上图是对Linux体系结构的一个细分结构，从这个图上可以更进一步对内核所做的事有一个“全景式”的印象。主要表现为：向下控制硬件资源，向内管理操作系统资源：包括进程的调度和管理、内存的管理、文件系统的管理、设备驱动程序的管理以及网络资源的管理，向上则向应用程序提供系统调用的接口。从整体上来看，整个操作系统分为两层：用户态和内核态，这种分层的架构极大地提高了资源管理的可扩展性和灵活性，而且方便用户对资源的调用和集中式的管理，带来一定的安全性。</p><h2 id="二、用户态和内核态的切换"><a href="#二、用户态和内核态的切换" class="headerlink" title="二、用户态和内核态的切换"></a>二、用户态和内核态的切换</h2><p>因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。所以，为了减少有限资源的访问和使用冲突，Unix/Linux的设计哲学之一就是：对不同的操作赋予不同的执行等级，就是所谓特权的概念。简单说就是有多大能力做多大的事，与系统相关的一些特别关键的操作必须由最高特权的程序来完成。Intel的X86架构的CPU提供了0到3四个特权级，数字越小，特权越高，Linux操作系统中主要采用了0和3两个特权级，分别对应的就是内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存，当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换，类似的函数还有printf()，调用的是wirte()系统调用来输出字符串，等等。</p><p><img src="/2021/02/23/Linux相关/Linux之用户态和内核态/%E7%94%A8%E6%88%B7%E6%80%81%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2.gif" alt="用户态内核态的切换"></p><p>　到底在什么情况下会发生从用户态到内核态的切换，一般存在以下三种情况：</p><p>1）当然就是系统调用：原因如上的分析。</p><p>2）异常事件： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</p><p>3）外围设备的中断：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</p><p>　　注意：系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断，这是操作系统为用户特别开放的一种中断，如Linux int 80h中断。所以，从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本文仅是从宏观的角度去理解Linux用户态和内核态的设计，并没有去深究它们的具体实现方式。从实现上来看，必须要考虑到的一点我想就是性能问题，因为用户态和内核态之间的切换也会消耗大量资源。关于实现的细节，目前学艺不精不敢乱说，等日后补上。但知道了这一点，我相信对很多问题也就很容易理解了，比如说基于缓冲区的IO和无缓冲的IO，用户进程和内核进程之间的切换，IO复用中的读写内核事件表，等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux之用户态和内核态&quot;&gt;&lt;a href=&quot;#Linux之用户态和内核态&quot; class=&quot;headerlink&quot; title=&quot;Linux之用户态和内核态&quot;&gt;&lt;/a&gt;Linux之用户态和内核态&lt;/h1&gt;
    
    </summary>
    
      <category term="Linux相关" scheme="http://yoursite.com/categories/Linux%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Linux系统" scheme="http://yoursite.com/tags/Linux%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux之find命令</title>
    <link href="http://yoursite.com/2021/02/23/Linux%E7%9B%B8%E5%85%B3/Linux%E4%B9%8Bfind%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2021/02/23/Linux相关/Linux之find命令/</id>
    <published>2021-02-23T02:13:51.000Z</published>
    <updated>2021-02-23T02:37:02.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux之find命令"><a href="#Linux之find命令" class="headerlink" title="Linux之find命令"></a>Linux之find命令</h1><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>find pathname -options [-print -exec -ok …]</p><p>补充一下：</p><p>1.在这行中有个”|”,表示将前面命令的输出结果让后面的命令去执行，如果有时间大家也可以学学shell，是一个很容易上手的脚本语言；</p><p>2.”wc -l”统计文件的行数，包括空格行都统计的哟；</p><p>3.wc的语法：wc [参数] 文件</p><p>参数   含义</p><p>-c        显示文件的Bytes数(字节数)及文件名输出到屏幕上<br>-l        将每个文件的行数及文件名输出到屏幕上<br>-m      将每个文件的字符数及文件名输出到屏幕上，如果当前系统不支持多字节字符其将显示与-c参数相同的结果<br>-w      将每个文件含有多少个词及文件名输出到屏幕上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 统计文件数目</span><br><span class="line"><span class="meta">#</span> Total number of .jpg files</span><br><span class="line"><span class="meta">$</span> find . -type f -name '*.jpg' | wc -l</span><br><span class="line">165501</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Number of photos for male</span><br><span class="line"><span class="meta">$</span> find . -type f -path '*/111/*' | wc -l</span><br><span class="line">101526</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>eg：</span><br><span class="line"><span class="meta">#</span>统计当前目录下所有jpg文件数目</span><br><span class="line">find . -type f -name '*.jpg' | wc -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件</span><br><span class="line">find ./ -type f</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找目录</span><br><span class="line">find ./ -type d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找名字为test的文件或目录</span><br><span class="line">find ./ -name test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找名字符合正则表达式的文件,注意前面的‘.*’(查找到的文件带有目录)</span><br><span class="line">find ./ -regex .*so.*\.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找目录并列出目录下的文件(为找到的每一个目录单独执行ls命令，没有选项-print时文件列表前一行不会显示目录名称)</span><br><span class="line">find ./ -type d -print -exec ls &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找目录并列出目录下的文件(为找到的每一个目录单独执行ls命令,执行命令前需要确认)</span><br><span class="line">find ./ -type d -ok ls &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找目录并列出目录下的文件(将找到的目录添加到ls命令后一次执行，参数过长时会分多次执行)</span><br><span class="line">find ./ -type d -exec ls &#123;&#125; +</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件名匹配*.c的文件</span><br><span class="line">find ./ -name \*.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>打印test文件名后，打印test文件的内容</span><br><span class="line">find ./ -name test -print -exec cat &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>不打印test文件名，只打印test文件的内容</span><br><span class="line">find ./ -name test -exec cat &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新日时在距现在时刻二天以内的文件</span><br><span class="line">find ./ -mtime -2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新日时在距现在时刻二天以上的文件</span><br><span class="line">find ./ -mtime +2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新日时在距现在时刻一天以上二天以内的文件</span><br><span class="line">find ./ -mtime 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新日时在距现在时刻二分以内的文件</span><br><span class="line">find ./ -mmin -2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新日时在距现在时刻二分以上的文件</span><br><span class="line">find ./ -mmin +2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新日时在距现在时刻一分以上二分以内的文件</span><br><span class="line">find ./ -mmin 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件更新时间比文件abc的内容更新时间新的文件</span><br><span class="line">find ./ -newer abc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件访问时间比文件abc的内容更新时间新的文件</span><br><span class="line">find ./ -anewer abc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找空文件或空目录</span><br><span class="line">find ./ -empty</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找空文件并删除</span><br><span class="line">find ./ -empty -type f -print -delete</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找权限为644的文件或目录(需完全符合)</span><br><span class="line">find ./ -perm 664</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找用户/组权限为读写，其他用户权限为读(其他权限不限)的文件或目录</span><br><span class="line">find ./ -perm -664</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找用户有写权限或者组用户有写权限的文件或目录</span><br><span class="line">find ./ -perm /220</span><br><span class="line">find ./ -perm /u+w,g+w</span><br><span class="line">find ./ -perm /u=w,g=w</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找所有者权限有读权限的目录或文件</span><br><span class="line">find ./ -perm -u=r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找用户组权限有读权限的目录或文件</span><br><span class="line">find ./ -perm -g=r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找其它用户权限有读权限的目录或文件</span><br><span class="line">find ./ -perm -o=r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找所有者为lzj的文件或目录</span><br><span class="line">find ./ -user lzj</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找组名为gname的文件或目录</span><br><span class="line">find ./ -group gname</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件的用户ID不存在的文件</span><br><span class="line">find ./ -nouser</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件的组ID不存在的文件</span><br><span class="line">find ./ -nogroup</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找有执行权限但没有可读权限的文件</span><br><span class="line">find ./ -executable \! -readable</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件size小于10个字节的文件或目录</span><br><span class="line">find ./ -size -10c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件size等于10个字节的文件或目录</span><br><span class="line">find ./ -size 10c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件size大于10个字节的文件或目录</span><br><span class="line">find ./ -size +10c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件size小于10k的文件或目录</span><br><span class="line">find ./ -size -10k</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件size小于10M的文件或目录</span><br><span class="line">find ./ -size -10M</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查找文件size小于10G的文件或目录</span><br><span class="line">find ./ -size -10G</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux之find命令&quot;&gt;&lt;a href=&quot;#Linux之find命令&quot; class=&quot;headerlink&quot; title=&quot;Linux之find命令&quot;&gt;&lt;/a&gt;Linux之find命令&lt;/h1&gt;
    
    </summary>
    
      <category term="Linux相关" scheme="http://yoursite.com/categories/Linux%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux之vim使用详解</title>
    <link href="http://yoursite.com/2021/02/22/Linux%E7%9B%B8%E5%85%B3/Linux%E4%B9%8Bvim%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2021/02/22/Linux相关/Linux之vim使用详解/</id>
    <published>2021-02-22T09:34:53.000Z</published>
    <updated>2021-02-23T03:03:52.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux之vim使用详解"><a href="#Linux之vim使用详解" class="headerlink" title="Linux之vim使用详解"></a>Linux之vim使用详解</h1><a id="more"></a><h2 id="vim简介"><a href="#vim简介" class="headerlink" title="vim简介"></a>vim简介</h2><p>Vim是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，和Emacs并列成为类Unix系统用户最喜欢的文本编辑器。</p><p>vim的设计理念是命令的组合。用户学习了各种各样的文本间移动/跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效的进行文本编辑。同时VIM与很多快捷键设置和正则表达式类似,可以辅助记忆。并且vim针对程序员做了优化。</p><h3 id="vim模式"><a href="#vim模式" class="headerlink" title="vim模式"></a>vim模式</h3><p>打开文件方法：vim filename，默认为编辑模式。</p><p>vim是模块化的编辑器，包含三种基本模式：</p><p>1、一般指令模式：Normal，默认模式，移动光标，剪切/粘贴文本。</p><p>2、编辑模式：Insert，插入模式，用于修改文本。</p><p>3、命令行命令模式：内置命令接口（extended command），用于保存、退出等。</p><h3 id="vim模式替换"><a href="#vim模式替换" class="headerlink" title="vim模式替换"></a>vim模式替换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">一般指令模式 --&gt; 编辑模式：</span><br><span class="line">i：insert, 在光标所在处输入</span><br><span class="line">a: append，在光标在处后方输入</span><br><span class="line">o：在光标所在处的下方打开一个新行</span><br><span class="line">I：在光标所在行的行首输入</span><br><span class="line">A：在光标所在行的行尾输入</span><br><span class="line">O：在光标所在处的上方打开一个新行</span><br><span class="line"></span><br><span class="line">编辑模式 --&gt; 一般指令模式</span><br><span class="line">ESC</span><br><span class="line"></span><br><span class="line">一般指令模式 --&gt; 命令行命令模式</span><br><span class="line">:</span><br><span class="line"></span><br><span class="line">命令行命令模式 --&gt; 一般指令模式模式</span><br><span class="line">ESC，Enter</span><br></pre></td></tr></table></figure><h2 id="常用vim指令"><a href="#常用vim指令" class="headerlink" title="常用vim指令"></a>常用vim指令</h2><h3 id="一般指令模式"><a href="#一般指令模式" class="headerlink" title="一般指令模式"></a>一般指令模式</h3><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZZ                     # 保存并退出</span><br><span class="line">ZQ                     # 不保存退出</span><br></pre></td></tr></table></figure><h4 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 字符间跳转</span><br><span class="line">h                          # 左</span><br><span class="line">j                          # 下</span><br><span class="line">k                          # 上</span><br><span class="line">l                          # 右</span><br><span class="line"><span class="meta">#</span>COMMAND                   # 跳转由#指定的个数的字符</span><br><span class="line">5k                         # 向上跳转5个字符</span><br><span class="line">3l                         # 向右跳转3个字符</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 单词间跳转</span><br><span class="line">w                          # 下一个单词的词首</span><br><span class="line">e                          # 当前或后一个单词的词尾</span><br><span class="line">b                          # 当前或前一个单词的词首</span><br><span class="line"><span class="meta">#</span>COMMAND                   # 跳转由#指定的个数的单词</span><br><span class="line">3w                         # 跳转到下三个单词的词首</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 行首行尾跳转</span><br><span class="line">^                          # 跳转至行首的第一个非空白字符</span><br><span class="line">0                          # 跳转至行首，数字 0 ，字母 O 和 o 是由编辑模式进入到输入模式</span><br><span class="line"><span class="meta">$</span>                          # 跳转至行尾</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 当前页跳转</span><br><span class="line">H                          # 页首</span><br><span class="line">M                          # 页中间行</span><br><span class="line">L                          # 页底</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 行间跳转</span><br><span class="line"><span class="meta">#</span>G                         # 跳转至由#指定的行</span><br><span class="line">1G, gg                     # 第一行</span><br><span class="line">G                          # 最后一行</span><br><span class="line">5G                         # 跳转至第5行</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 句间跳转</span><br><span class="line">)                          # 下一句</span><br><span class="line">(                          # 上一句</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 段间跳转</span><br><span class="line">&#125;                          # 下一段</span><br><span class="line">&#123;                          # 上一段</span><br></pre></td></tr></table></figure><h4 id="翻屏"><a href="#翻屏" class="headerlink" title="翻屏"></a>翻屏</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+f                     # 向文件尾翻一屏</span><br><span class="line">Ctrl+b                     # 向文件首部翻一屏</span><br><span class="line">Ctrl+d                     # 向文件尾部翻半屏</span><br><span class="line">Ctrl+u                     # 向文件首部翻半屏</span><br><span class="line">Enter                      # 按行向后翻</span><br></pre></td></tr></table></figure><h4 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 字符编辑</span><br><span class="line">x                          # 删除光标所在处的字符</span><br><span class="line"><span class="meta">#</span>x                         # 删除光标所在处起始的#个字符</span><br><span class="line"></span><br><span class="line">xp                         # 交换光标所在处的字符与其后面的字符的位置</span><br><span class="line">~                          # 转换大小写</span><br><span class="line">J                          # 删除当前行后的换行符</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 替换命令</span><br><span class="line">r                          # 替换光标所在处的字符</span><br><span class="line">R                          # 切换成 REPLACE 模式，可以输入任意字符进行更换</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除命令 delete</span><br><span class="line">d                          # 删除命令，可结合光标跳转字符，实现范围删除</span><br><span class="line"><span class="meta">d$</span>                     # 删除到行尾</span><br><span class="line">d^                     # 删除到非空行首 </span><br><span class="line">d0                     # 删除到行首</span><br><span class="line">dw                     # 删除光标所在处的单词或符号</span><br><span class="line">d3w                    # 删除光标所在处的三个单词</span><br><span class="line">de                     # 删除当前或下一个单词</span><br><span class="line">db                     # 删除当前或前一个单词</span><br><span class="line"><span class="meta">#</span>COMMAND               # 支持使用数字</span><br><span class="line"></span><br><span class="line">dd                     # 删除光标所在处的行</span><br><span class="line"><span class="meta">#</span>dd                    # 删除光标所处的行起始的共#行</span><br><span class="line">3dd                    # 删除光标所处的行起始的3行</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 复制命令</span><br><span class="line">y                          # 复制，工作行为相似于d命令</span><br><span class="line"><span class="meta">y$</span>                     # 复制当前光标处到行尾</span><br><span class="line">y^                     # 复制当前光标处到非空行首</span><br><span class="line">y0                     # 复制当前光标处到行首</span><br><span class="line"></span><br><span class="line">ye                     # 复制当前或下一个单词</span><br><span class="line">yw                     # 复制光标所在处的单词</span><br><span class="line">yb                     # 复制当前或前一个单词</span><br><span class="line"><span class="meta">#</span>COMMAND</span><br><span class="line"></span><br><span class="line">yy                     # 复制一整行</span><br><span class="line"><span class="meta">#</span>yy                    # 复制#行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 粘贴命令</span><br><span class="line">p           # 缓冲区中的内容如果为整行，则粘贴在当前光标所在行的下方</span><br><span class="line">        # 否则，则粘贴至当前光标所在处的后方</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 改变命令 （相当于移动光标，删除，并进入输入模式）</span><br><span class="line"><span class="meta">c$</span>                         # 删除光标所在处至行尾，并切换到输入模式 </span><br><span class="line">c^                         # 非空行首</span><br><span class="line">c0                         # 行首</span><br><span class="line"></span><br><span class="line">cb                         # 当前或前一个单词</span><br><span class="line">ce                         # 当前或下一个单词</span><br><span class="line">cw                         # 当前单词</span><br><span class="line"><span class="meta">#</span>COMMAND</span><br><span class="line"></span><br><span class="line">cc                         # 删除光标所在的行，并转换为输入模式</span><br><span class="line"><span class="meta">#</span>cc                        # 删除光标所在行为起始行3行，并转换为输入模式</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 撤销模式</span><br><span class="line">撤销(undo)操作：</span><br><span class="line">u                      # 撤销此前的操作；</span><br><span class="line"><span class="meta">#</span>u                     # 撤销此前的#个操作；</span><br><span class="line"></span><br><span class="line">Ctrl+r                   # 撤销此前的撤销</span><br><span class="line"></span><br><span class="line">.                      # 重复执行前一个编辑操作</span><br></pre></td></tr></table></figure><h3 id="命令行命令模式"><a href="#命令行命令模式" class="headerlink" title="命令行命令模式"></a>命令行命令模式</h3><h4 id="文件操作-1"><a href="#文件操作-1" class="headerlink" title="文件操作"></a>文件操作</h4><p>在编辑模式下，输入“:”进入末行模式，会创建一个命令提示符，处于屏幕底部左侧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">:q                     # 退出</span><br><span class="line">:q!                    # 强制退出，不保存此前的编辑操作</span><br><span class="line">:wq                    # 保存并退出</span><br><span class="line">:w, :q                 # 保存并退出</span><br><span class="line">:x                     # 保存并退出</span><br><span class="line">:w /PATH/TO/SOMEFILE   # 保存文件至指定的路径</span><br><span class="line">r filename             # 读文件内容到当前文件中</span><br><span class="line">w filename             # 将当前文件内容写入另一个文件</span><br><span class="line">!command               # 执行命令</span><br><span class="line">r!command              # 读入命令的输出</span><br></pre></td></tr></table></figure><h4 id="地址定界"><a href="#地址定界" class="headerlink" title="地址定界"></a>地址定界</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">:start_pos[,end_pos]</span><br><span class="line"><span class="meta">#</span>                           # 特定的第#行，例如5即第5行</span><br><span class="line">.                           # 当前行</span><br><span class="line"><span class="meta">$</span>                           # 最后一行</span><br><span class="line"><span class="meta">#</span>,#                         # 指定行范围，左侧为起始行，右侧为结束行</span><br><span class="line"><span class="meta">#</span>,+#                        # 指定行范围，左侧为超始行绝对编号，右侧为相对左侧行号的偏移量；例如：3,+7</span><br><span class="line">.,$-1</span><br><span class="line">1,$</span><br><span class="line"><span class="meta">%</span>                           # 全文 </span><br><span class="line">/pattern/                   # 从光标所在处起始向文件尾部第一次被模式所匹配到的行</span><br><span class="line">/first/,$</span><br><span class="line">/pat1/,/pat2/               # 从光标所在处起始，第一次由pat1匹配到的行开始，至第一次由pat2匹配到的行结束之间的所有行</span><br><span class="line"></span><br><span class="line">可同编辑命令一同使用，实现编辑操作：</span><br><span class="line">d</span><br><span class="line">y</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">w /PATH/TO/SOMEFILE          # 将范围内的文本保存至指定的文件中；</span><br><span class="line">r  /PATH/FROM/SOMEFILE       # 将指定的文件中的文本读取并插入至指定位置；</span><br></pre></td></tr></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/PATTERN：#从当前光标所在处向文件尾部查找能够被当前模式匹配到的所有字符串；</span><br><span class="line">?PATTERN：#从当前光标所在处向文件首部查找能够被当前模式匹配到的所有字符串；</span><br><span class="line">n：#下一个，与命令方向相同；</span><br><span class="line">N：#上一个，与命令方向相反；</span><br><span class="line"></span><br><span class="line">s：末行模式的命令；使用格式：</span><br><span class="line">s/要查找的内容/替换为的内容/修饰符</span><br><span class="line">要查找的内容：可使用正则表达式；</span><br><span class="line">替换为的内容：不能使用下则表达式，但可以引用；</span><br><span class="line">如果“要查找的内容”部分在模式中使用分组符号：在“替换为的内容”中使用后向引用；</span><br><span class="line">直接引用查找模式匹配到的全部文本，要使用&amp;符号；</span><br><span class="line">修饰符：</span><br><span class="line">i：忽略大小写；</span><br><span class="line">g：全局替换，意味着一行中如果匹配到多次，则均替换；</span><br><span class="line"></span><br><span class="line">可把分隔符替换为其它非常用字符：</span><br><span class="line">s@@@</span><br><span class="line"><span class="meta">s#</span>##</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">1、复制/etc/grub2.cfg文件至/tmp目录中，用查找替换命令删除/tmp/grub2.cfg文件中以空白字符开头的行的行首的空白字符；</span><br><span class="line"><span class="meta">%</span>s@^[[:space:]]\+@@</span><br><span class="line">2、复制/etc/rc.d/init.d/functions文件至/tmp目录中，用查找替换命令为/tmp/functions文件的每个以空白字符开头的行的行首加上#；</span><br><span class="line"><span class="meta">%</span>s@^[[:space:]]\+[^[:space:]]@#&amp;@g</span><br><span class="line">3、为/tmp/grub2.cfg文件的前三行的行首加上#号；</span><br><span class="line">1,3s@^@#@</span><br><span class="line">4、将/etc/yum.repos.d/CentOS-Base.repo文件中所有的enabled=0替换为enabled=1，所有gpgcheck=0替换为gpgcheck=1；</span><br><span class="line"><span class="meta">%</span>s@\(enabled\|gpgcheck\)=0@\1=1@g</span><br></pre></td></tr></table></figure><h2 id="vim其它功能"><a href="#vim其它功能" class="headerlink" title="vim其它功能"></a>vim其它功能</h2><h3 id="多文件功能"><a href="#多文件功能" class="headerlink" title="多文件功能"></a>多文件功能</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">多文件命令格式：</span><br><span class="line"><span class="meta">#</span> vim FILE1 FILE2 ...</span><br><span class="line">在文件间切换：</span><br><span class="line">:next  下一个</span><br><span class="line">:prev  上一个</span><br><span class="line">:first   第一个 </span><br><span class="line">:last   最后一个</span><br><span class="line"></span><br><span class="line">退出所有文件：</span><br><span class="line">:wqall 保存所有文件并退出；</span><br><span class="line">:wall</span><br><span class="line">:qall</span><br></pre></td></tr></table></figure><h3 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-o：水平分割窗口</span><br><span class="line">-O：垂直分割窗口</span><br><span class="line"></span><br><span class="line">在窗口间切换：Ctrl+w, ARROW</span><br><span class="line"></span><br><span class="line">注意：单个文件也可以分割为多个窗口进行查看：</span><br><span class="line">Ctrl+w, s：水平分割窗口</span><br><span class="line">Ctrl+w, v：垂直分割窗口</span><br></pre></td></tr></table></figure><h3 id="定制vim工作特性"><a href="#定制vim工作特性" class="headerlink" title="定制vim工作特性"></a>定制vim工作特性</h3><p>1、临时有效：在末行模式下的设定，仅对当前vim进程有效</p><p>2、永久有效：需要修改相应的配置文件，全局配置文件（/etc/vimrc）；用户个人配置文件（～/.vimrc，需要首先创建此文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 行号</span><br><span class="line">显示：set number, 简写为set nu</span><br><span class="line">取消显示：set nomber, set nonu</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>  括号匹配高亮</span><br><span class="line">匹配：set showmatch, set sm</span><br><span class="line">取消：set nosm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 自动缩进</span><br><span class="line">启用：set ai</span><br><span class="line">禁用：set noai</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 高亮搜索</span><br><span class="line">启用：set  hlsearch</span><br><span class="line">禁用：set nohlsearch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 语法高亮</span><br><span class="line">启用：syntax on</span><br><span class="line">禁用：syntax off </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>忽略字符大小写</span><br><span class="line">启用：set ic</span><br><span class="line">禁用：set noic</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取帮助</span><br><span class="line">:help</span><br><span class="line">:help subject</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按TAB产生4个空格</span><br><span class="line">set ts=4        # 注：ts是tabstop的缩写，设TAB宽4个空格</span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">对于已保存的文件，可以使用下面的方法进行空格和TAB的替换：</span><br><span class="line">TAB替换为空格：</span><br><span class="line">:set ts=4</span><br><span class="line">:set expandtab</span><br><span class="line">:%retab!</span><br><span class="line"></span><br><span class="line">空格替换为TAB：</span><br><span class="line">:set ts=4</span><br><span class="line">:set noexpandtab</span><br><span class="line">:%retab!</span><br><span class="line"></span><br><span class="line">加!是用于处理非空白字符之后的TAB，即所有的TAB，若不加!，则只处理行首的TAB。</span><br></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>图片引自网络（侵删）</p><p><img src="/2021/02/22/Linux相关/Linux之vim使用详解/image-20210223100320707.png" alt="image-20210223100320707"></p><p>来自鸟哥私房菜基础篇：</p><p><strong>第一部分</strong>：</p><p><img src="/2021/02/22/Linux相关/Linux之vim使用详解/image-20210223105458430.png" alt="image-20210223105458430"></p><p><img src="/2021/02/22/Linux相关/Linux之vim使用详解/image-20210223105516589.png" alt="image-20210223105516589"></p><p><img src="/2021/02/22/Linux相关/Linux之vim使用详解/image-20210223105529558.png" alt="image-20210223105529558"></p><p><strong>第二部分</strong>：</p><p><img src="/2021/02/22/Linux相关/Linux之vim使用详解/image-20210223105607302.png" alt="image-20210223105607302"></p><p><strong>第三部分</strong>：</p><p><img src="/2021/02/22/Linux相关/Linux之vim使用详解/image-20210223105625388.png" alt="image-20210223105625388"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux之vim使用详解&quot;&gt;&lt;a href=&quot;#Linux之vim使用详解&quot; class=&quot;headerlink&quot; title=&quot;Linux之vim使用详解&quot;&gt;&lt;/a&gt;Linux之vim使用详解&lt;/h1&gt;
    
    </summary>
    
      <category term="Linux相关" scheme="http://yoursite.com/categories/Linux%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="vim使用详解" scheme="http://yoursite.com/tags/vim%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java八大排序算法</title>
    <link href="http://yoursite.com/2021/02/20/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/02/20/Java数据结构与算法/Java八大排序算法/</id>
    <published>2021-02-20T09:41:53.000Z</published>
    <updated>2021-02-20T09:43:30.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java八大排序算法"><a href="#Java八大排序算法" class="headerlink" title="Java八大排序算法"></a>Java八大排序算法</h1><a id="more"></a><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>八大排序算法：直接插入排序（Insertion Sort）、希尔排序（Shell Sort）、选择排序（Selection Sort）、堆排序（Heap Sort）、冒泡排序（Bubble Sort）、快速排序（Quick Sort）、归并排序（Merging Sort）、基数排序（Radix Sort），基数排序也称桶排序。</p><p>都属于内部排序算法，其中直接插入排序和希尔排序属于<strong>插入排序</strong>，简单选择排序和堆排序属于<strong>选择排序</strong>，冒泡排序和快速排序属于<strong>交换排序</strong>。</p><h2 id="直接插入排序算法"><a href="#直接插入排序算法" class="headerlink" title="直接插入排序算法"></a>直接插入排序算法</h2><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。插入排序非常类似于整扑克牌。在开始摸牌时，左手是空的，牌面朝下放在桌上。接着，一次从桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将它与手中已有的牌从右到左地进行比较。无论什么时候，左手中的牌都是排好序的。<br>如果输入数组已经是排好序的话，插入排序出现最佳情况，其运行时间是输入规模的一个线性函数。如果输入数组是逆序排列的，将出现最坏情况。平均情况与最坏情况一样，其时间代价是(n2)。</p><p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。</p><p>通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了要给插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><p>1、从第一个元素开始，该元素可以认为已经被排序。</p><p>2、取出下一个元素，在已经排序的元素序列中从后向前扫描。</p><p>3、如果该元素（已排序）大于新元素，将该元素移到下一位置。</p><p>4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。</p><p>5、将新元素插入到该位置后。</p><p>6、重复步骤2~5。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过将较大的元素都向右移动而不总是交换两个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 装载临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">temp = data[i];</span><br><span class="line"><span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果前一位比当前数据要大，那么进入循环比较</span></span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; data[j] &gt; temp; j--) &#123;</span><br><span class="line"><span class="comment">// 往后退一个位置，让当前数据与之前前位进行比较</span></span><br><span class="line">data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出内层循环，则说明找到了合适的位置，并将当前数据插入合适的位置中</span></span><br><span class="line">data[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过交换进行插入排序，借鉴冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 装载临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"><span class="comment">// 如果前一位比当前数据要大，那么进入循环比较，并两两交换，参考冒泡排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; data[j] &gt; data[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">temp = data[j + <span class="number">1</span>];</span><br><span class="line">data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sortTwo end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>插入排序所需的时间取决于输入元素的初始顺序。例如，对一个很大且其中的元素已经有序(或接近有序)的数组进行排序将会比随机顺序的数组或是逆序数组进行排序要快得多。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell 于1959 年提出而得名。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。<br>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是初次取数组长度的一半为增量，之后每次再减半，直到增量为1。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>1、选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1。</p><p>2、按增量序列个数 k，对序列进行 k 趟排序。</p><p>3、每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><p>引用自网上一张图（侵删）：</p><p><img src="/2021/02/20/Java数据结构与算法/Java八大排序算法/image-20210220134535850.png" alt="image-20210220134535850"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">// 增量每次都/2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> step = data.length / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 从增量那组开始进行插入排序，直至完毕</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; data.length; i++) &#123;</span><br><span class="line">temp = data[i];</span><br><span class="line"><span class="keyword">int</span> j = i - step;</span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; data[j] &gt; temp; j -= step) &#123;</span><br><span class="line"><span class="comment">// 往后退一个step位置，让当前数据与之前前位进行比较</span></span><br><span class="line">data[j + step] = data[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出内层循环，则说明找到了合适的位置，并将当前数据插入合适的位置中</span></span><br><span class="line">data[j + step] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td></tr></tbody></table><p>希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始(末尾)位置，直到全部待排序的数据元素排完。选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5 挪动到第二个5 后面）。</p><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n个元素的表进行排序总共进行至多 n-1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><h3 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h3><p>1、从未排序序列中，找到关键字最小的元素。</p><p>2、如果最小元素不是未排序序列的第一个元素，将其和未排序序列第一个元素互换。</p><p>3、重复1、2步，直到排序结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 记录当前趟数的最小值的角标</span></span><br><span class="line"><span class="keyword">int</span> minPos;</span><br><span class="line"><span class="comment">// 交换的变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"><span class="comment">// 新的趟数的起点</span></span><br><span class="line">minPos = i;</span><br><span class="line"><span class="comment">// 选出之后排序中值最小的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; data.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (data[j] &lt; data[i]) &#123;</span><br><span class="line">minPos = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最小值不等于当前值时进行交换</span></span><br><span class="line"><span class="keyword">if</span> (minPos != i) &#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">data[i] = data[minPos];</span><br><span class="line">data[minPos] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。</p><h3 id="算法描述：-1"><a href="#算法描述：-1" class="headerlink" title="算法描述："></a>算法描述：</h3><p>描述一：</p><p>1、i从0开始，i与i+1比较，如果后面的数（i+1）小于前面的数（i），则交换。<br>2、i不断增加，直到i&lt;n-1（数组长度减一），一趟下来，可以让数组元素中的最大值排在数组的最后，直到完成。</p><p>描述二：</p><p>1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><p>3、针对所有的元素重复以上的步骤，除了最后一个。</p><p>4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试用，记录执行了多少趟</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 装载临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">// 外层是排序的趟数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 内层循环是当前趟数需要比较的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="comment">// 前一位与后一位相比较，如果前一位比后一位要大，则交换</span></span><br><span class="line"><span class="keyword">if</span> (data[j + <span class="number">1</span>] &lt; data[j]) &#123;</span><br><span class="line">temp = data[j + <span class="number">1</span>];</span><br><span class="line">data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"Sort run frequency is : "</span> + num);</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p><h3 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h3><p>如果数据足够乱的情况下，例如反序，需要数据长度-1趟才能将数据完整排好序。</p><p>但是在部分有序情况下，例如在第3趟比较后就已经得到了排好序的数组，就没有必要执行后面的计算了。我们可以做如下优化：</p><ul><li>如果在某趟排序中没有发生交换位置，那么我们可以认为该数组已经排好顺序了。（我们每趟排序的目的就是为了将当前趟最大的数置换到对应的位置上，如果没有发生置换说明已经是排好序的了）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">betterSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试用，记录执行了多少趟</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 装载临时变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">// 记录是否发生了置换，0代表没有发生置换，1代表发生了置换</span></span><br><span class="line"><span class="keyword">int</span> isChange;</span><br><span class="line"><span class="comment">// 外层是排序的趟数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 每比较一趟就重新初始化为0</span></span><br><span class="line">isChange = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 内层循环是当前趟数需要比较的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="comment">// 前一位与后一位相比较，如果前一位比后一位要大，则交换</span></span><br><span class="line"><span class="keyword">if</span> (data[j + <span class="number">1</span>] &lt; data[j]) &#123;</span><br><span class="line">temp = data[j + <span class="number">1</span>];</span><br><span class="line">data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果进到这里面了，说明发生了置换</span></span><br><span class="line">isChange = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果比较完一趟没有发生置换，那么说明已经排好序了，不需要再执行下去了</span></span><br><span class="line"><span class="keyword">if</span> (isChange == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"betterSort run frequency is : "</span> + num);</span><br><span class="line">&#125; <span class="comment">// better sort end</span></span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序由C. A. R. Hoare 在1962 年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>一次循环：从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。找到这个值之后，又从前往后开始比较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的值才交换。直到从前往后的比较索引&gt;从后往前比较的索引，结束第一次循环，此时，对于基准值来说，左右两边就是有序的了。</p><h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好。</p><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists），算法步骤：</p><p>1、从数列中挑出一个元素，称为”基准”（pivot）。</p><p>2、重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p><p>3、递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"sort start, L : "</span> + L + <span class="string">" ,R : "</span> + R);</span><br><span class="line"><span class="keyword">int</span> i = L;</span><br><span class="line"><span class="keyword">int</span> j = R;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换的变量</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">// 支点</span></span><br><span class="line"><span class="keyword">int</span> pivot = data[L + (R - L) / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左右两端进行扫描，只要两端没有交替，就一直扫描</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line"><span class="comment">// 左边寻找直到比支点大的数</span></span><br><span class="line"><span class="keyword">while</span> (pivot &gt; data[i]) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边寻找直到比支点小的数</span></span><br><span class="line"><span class="keyword">while</span> (pivot &lt; data[j]) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时已经分别找到了比支点小的数（右边）、比支点大的数（左边），它们进行交换</span></span><br><span class="line"><span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">data[i] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line"><span class="comment">// 左边右移一位</span></span><br><span class="line">i++;</span><br><span class="line"><span class="comment">// 右边左移一位</span></span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面一个while保证了第一趟排序支点的左边比支点小，支点的右边比支点大了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左边再做排序，直到左边剩下一个数（递归出口）</span></span><br><span class="line"><span class="keyword">if</span> (L &lt; j) &#123;</span><br><span class="line">System.out.println(<span class="string">"sort left before, L : "</span> + L + <span class="string">" ,j : "</span> + j);</span><br><span class="line">sort(data, L, j);</span><br><span class="line">System.out.println(<span class="string">"sort left end, L : "</span> + L + <span class="string">" ,j : "</span> + j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右边再做排序，直到右边剩下一个数（递归出口）</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; R) &#123;</span><br><span class="line">System.out.println(<span class="string">"sort right before, i : "</span> + i + <span class="string">" ,R : "</span> + R);</span><br><span class="line">sort(data, i, R);</span><br><span class="line">System.out.println(<span class="string">"sort right end, i : "</span> + i + <span class="string">" ,R : "</span> + R);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(n²)</td><td>O(1)</td></tr></tbody></table><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用<strong>分治法（Divide and Conquer）</strong>的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>归并排序可通过两种方式实现:</p><ul><li>自上而下的递归</li><li>自下而上的迭代</li></ul><p>递归法（假设序列共有n个元素）：</p><p>1、将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</p><p>2、将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</p><p>3、重复步骤2，直到所有元素排序完毕。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>迭代法归并操作的工作原理如下：</p><p>1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。</p><p>2、设定两个指针，最初位置分别为两个已经排序序列的起始位置。</p><p>3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。</p><p>4、重复步骤3 直到某一指针超出序列尾。</p><p>5、将另一序列剩下的所有元素直接复制到合并序列尾。</p><p>归并排序其实要做两件事：</p><ul><li>分解：将序列每次折半拆分</li><li>合并：将划分后的序列段两两排序合并</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果只有一个元素，那就不用排序了</span></span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 取中间的数，进行拆分</span></span><br><span class="line"><span class="keyword">int</span> M = L + (R - L) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"sort left before, L : "</span> + L + <span class="string">" ,M : "</span> + M);</span><br><span class="line"><span class="comment">// 左边的数不断进行拆分</span></span><br><span class="line">sort(data, L, M);</span><br><span class="line">System.out.println(<span class="string">"sort left end, L : "</span> + L + <span class="string">" ,M : "</span> + M);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"sort right before, M+1 : "</span> + (M + <span class="number">1</span>) + <span class="string">" ,R : "</span> + R);</span><br><span class="line"><span class="comment">// 右边的数不断进行拆分</span></span><br><span class="line">sort(data, M + <span class="number">1</span>, R);</span><br><span class="line">System.out.println(<span class="string">"sort right end, M+1 : "</span> + (M + <span class="number">1</span>) + <span class="string">" ,R : "</span> + R);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"merge before, L: "</span> + L + <span class="string">", M+1 : "</span> + (M + <span class="number">1</span>) + <span class="string">" ,R : "</span> + R);</span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">merge(data, L, M + <span class="number">1</span>, R);</span><br><span class="line">System.out.println(<span class="string">"merge end, L: "</span> + L + <span class="string">", M+1 : "</span> + (M + <span class="number">1</span>) + <span class="string">" ,R : "</span> + R);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 左边数组的大小</span></span><br><span class="line"><span class="keyword">int</span>[] leftData = <span class="keyword">new</span> <span class="keyword">int</span>[M - L];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边数组的大小</span></span><br><span class="line"><span class="keyword">int</span>[] rightData = <span class="keyword">new</span> <span class="keyword">int</span>[R - M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往这两个数组填充数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; M; i++) &#123;</span><br><span class="line">leftData[i - L] = data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt;= R; i++) &#123;</span><br><span class="line">rightData[i - M] = data[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// data数组的第一个元素</span></span><br><span class="line"><span class="keyword">int</span> k = L;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个数组的值，哪个小，就往数组上放</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; leftData.length &amp;&amp; j &lt; rightData.length) &#123;</span><br><span class="line"><span class="comment">// 谁比较小，谁将元素放入大数组中，移动指针，继续比较下一个</span></span><br><span class="line"><span class="keyword">if</span> (leftData[i] &lt; rightData[j]) &#123;</span><br><span class="line">data[k] = leftData[i];</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">data[k] = rightData[j];</span><br><span class="line"></span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果左边数组没有比较完，右边数组已经完了，那么将左边数组复制到大数组中（剩下的都是大数字）</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; leftData.length) &#123;</span><br><span class="line">data[k] = leftData[i];</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果右边数组没有比较完，左边数组已经完了，那么将右边数组复制到大数组中（剩下的都是大数字）</span></span><br><span class="line"><span class="keyword">while</span> (j &lt; rightData.length) &#123;</span><br><span class="line">data[k] = rightData[j];</span><br><span class="line"></span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// merge end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>O(1)</td></tr></tbody></table><p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p><p>归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比，它的主要缺点则是他所需的额外空间和N成正比。</p><h2 id="基数排序（桶排序）"><a href="#基数排序（桶排序）" class="headerlink" title="基数排序（桶排序）"></a>基数排序（桶排序）</h2><p>基数排序(radix sort)属于”分配式排序”(distribution sort)，又称”桶子法”(bucket sort)或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些”桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r 为所采取的基数，而m 为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。基数排序不同与其他的7种排序，其他7 种排序本质上都是按照交换或者比较来进行排序，但是基数排序并不是，它是按照分配，回收(分配到不同的位置上，然后回收)..不断分配..回收来进行排序，直到有序。</p><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p><p><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</p><p><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</p><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>基数排序按照优先从高位或低位来排序有两种实现方案：</p><ul><li><p>MSD（Most significant digital） 从最左侧高位开始进行排序。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。MSD方式适用于位数多的序列。</p></li><li><p>LSD （Least significant digital）从最右侧低位开始进行排序。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。LSD方式适用于位数少的序列。</p></li></ul><p>以LSD为例，从最低位开始，算法步骤：</p><p>1、取得数组中的最大数，并取得位数；</p><p>2、arr为原始数组，从最低位开始取每个位组成radix数组；</p><p>3、对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (data.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得数组中最大的数，并取得位数</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; data[i]) &#123;</span><br><span class="line">max = data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 位数计算</span></span><br><span class="line"><span class="keyword">int</span> maxDigit = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (max / <span class="number">10</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">maxDigit++;</span><br><span class="line">max = max / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请一个桶空间，二维数组</span></span><br><span class="line"><span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][data.length];</span><br><span class="line"><span class="keyword">int</span> base = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从低位到高位，对每一位遍历，将所有元素分配到桶中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++) &#123;</span><br><span class="line"><span class="comment">// 存储各个桶中存储元素的数量</span></span><br><span class="line"><span class="keyword">int</span>[] bktLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配，将所有元素分配到桶中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> whichBucket = (data[j] % base) / (base / <span class="number">10</span>);</span><br><span class="line">buckets[whichBucket][bktLen[whichBucket]] = data[j];</span><br><span class="line">bktLen[whichBucket]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集，将不同桶里的数据挨个捞出来，为下一轮高位排序做准备，由于靠近桶底的元素排名靠前，因此从桶底先捞</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; buckets.length; b++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; bktLen[b]; p++) &#123;</span><br><span class="line">data[k++] = buckets[b][p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">base *= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// sort end</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(d*(n + r))</td><td>O(d*(n + r))</td><td>O(d*(n + r))</td><td>O(n+r)</td></tr></tbody></table><p>其中，d 为位数，r 为基数，n 为原数组个数。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d*(n + r))。</p><p>备注：</p><p>基数排序更适合用于对时间, 字符串等这些 整体权值未知的数据 进行排序。</p><p>基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p>基数排序 vs 计数排序 vs 桶排序</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><p>1、基数排序：根据键值的每位数字来分配桶</p><p>2、计数排序：每个桶只存储单一键值</p><p>3、桶排序：每个桶存储一定范围的数值</p><h2 id="八大排序算法总结"><a href="#八大排序算法总结" class="headerlink" title="八大排序算法总结"></a>八大排序算法总结</h2><p>从时间复杂度来说：</p><p>1、平方阶O(n²)排序：<strong>各类简单排序：直接插入、直接选择和冒泡排序</strong></p><p>2、线性对数阶O(nlog₂n)排序：<strong>快速排序、堆排序和归并排序</strong></p><p>3、O(n1+§))排序，§是介于0和1之间的常数：<strong>希尔排序</strong></p><p>4、线性阶O(n)排序：<strong>基数排序，此外还有桶、箱排序</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java八大排序算法&quot;&gt;&lt;a href=&quot;#Java八大排序算法&quot; class=&quot;headerlink&quot; title=&quot;Java八大排序算法&quot;&gt;&lt;/a&gt;Java八大排序算法&lt;/h1&gt;
    
    </summary>
    
      <category term="Java数据结构与算法" scheme="http://yoursite.com/categories/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java数据结构与算法概览</title>
    <link href="http://yoursite.com/2021/02/19/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2021/02/19/Java数据结构与算法/Java数据结构与算法概览/</id>
    <published>2021-02-19T08:04:53.000Z</published>
    <updated>2021-02-19T08:08:29.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java数据结构与算法概览"><a href="#Java数据结构与算法概览" class="headerlink" title="Java数据结构与算法概览"></a>Java数据结构与算法概览</h1><a id="more"></a><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>1、数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。</p><p>2、数据元素之间的相互关系包括：数据的逻辑结构、数据的存储结构、数据的运算结构。</p><p>3、数据结构的设计过程分为：抽象层、数据结构层、实现层。</p><h3 id="逻辑结构分类"><a href="#逻辑结构分类" class="headerlink" title="逻辑结构分类"></a>逻辑结构分类</h3><p>线性数据结构：数组，线性表，栈，队列，串等。</p><p>非线性数据结构：多维数组，集合，树，图，散列表(hash)。</p><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>定义：树形结构，作者觉得它是一种特殊的链形数据结构。最少有一个根节点组成，可以有多个子节点。树，显然是由递归算法组成。</p><p>种类：</p><p>（1）二叉树：每个节点最多含有两个子节点的树称为二叉树。</p><ul><li>1）一般二叉树：无限制，每个子节点的父亲节点不一定有两个子节点的二叉树成为一般二叉树。</li><li>2）完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</li><li>3）满二叉树：所有的节点都是二叉的二叉树成为满二叉树。</li></ul><p>（2）二叉搜索树/BST：二叉排序树、二叉查找树。是有序的。要点：如果不为空，那么其左子树节点的值都小于根节点的值；右子树节点的值都大于根节点的值。</p><ul><li>1）二叉平衡树：二叉搜索树，是有序的排序树，但左右两边包括子节点不一定平衡，而二叉平衡树是排序树的一种，并且加点条件，就是任意一个节点的两个叉的深度差不多（比如差值的绝对值小于某个常数，或者一个不能比另一个深出去一倍之类的）。这样的树可以保证二分搜索任意元素都是O(log n)的，一般还附带带有插入或者删除某个元素也是O(log n)的的性质。</li><li>2）AVL树：最早的平衡二叉树之一。windows对进程地址空间的管理用到了AVL树。</li><li>3）红黑树：通过制定了一些红黑标记和左右旋转规则来保证二叉树平衡。</li></ul><p>（3）B树/B-tree：又叫平衡(balance)多路查找树。树中每个结点最多含有m个孩子（m&gt;=2）。它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。</p><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系，通常记为，G=(V,E)。</p><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><p>分为无向图和有向图。</p><p>无向图G1：</p><p><img src="/2021/02/19/Java数据结构与算法/Java数据结构与算法概览/image-20210210105538609.png" alt="image-20210210105538609"></p><p>上面的图是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V1,{E1})。其中，</p><p>（1）V1={A,C,B,F,D,E}。 V2表示由”A,B,C,D,E,F”几个顶点组成的集合。</p><p>（2）E1={&lt;A,B&gt;,&lt;A,C&gt;,&lt;A,D&gt;,&lt;C,D&gt;,&lt;C,E&gt;,&lt;C,F&gt;,&lt;D,C&gt;,&lt;E,D&gt;}。 E1是由矢量&lt;A,B&gt;,矢量&lt;A,C&gt;…等等组成的集合。其中，矢量&lt;A,B)表示由”顶点A”指向”顶点B”的有向边。</p><p>无向图G2：</p><p><img src="/2021/02/19/Java数据结构与算法/Java数据结构与算法概览/image-20210210105554780.png" alt="image-20210210105554780"></p><p>上面的图是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中，</p><p>（1）V1={A,B,C,D,E,F}。 V1表示由”A,B,C,D,E,F”几个顶点组成的集合。</p><p>（2）E1={(A,C),(A,D),(B,C),(D,E),(E,F)}。 E1是由边(A,C),边(A,D)…等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。</p><h5 id="邻接点"><a href="#邻接点" class="headerlink" title="邻接点"></a>邻接点</h5><p>一条边上的两个顶点叫做邻接点。<br>例如，上面无向图中的顶点A和顶点C就是邻接点。<br>在有向图中，除了邻接点之外；还有”入边”和”出边”的概念。<br>顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。<br>例如，上面有向图中的A和C是邻接点；&lt;A,C&gt;是A的出边，还是C的入边。</p><h5 id="度"><a href="#度" class="headerlink" title="度"></a>度</h5><p>在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。<br>例如，上面无向图G2中顶点A的度是2。<br>在有向图中，度还有”入度”和”出度”之分。<br>某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。<br>顶点的度=入度+出度。<br>例如，上面有向图G1中，顶点C的入度是2，出度是3；顶点B的度=2+3=5。</p><h5 id="路径和回路"><a href="#路径和回路" class="headerlink" title="路径和回路"></a>路径和回路</h5><p>路径：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。<br>路径长度：路径中”边的数量”。<br>简单路径：若一条路径上顶点不重复出现，则是简单路径。<br>回路：若路径的第一个顶点和最后一个顶点相同，则是回路。<br>简单回路：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。</p><h5 id="连通图和连通分量"><a href="#连通图和连通分量" class="headerlink" title="连通图和连通分量"></a>连通图和连通分量</h5><p>连通图：对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。 对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。<br>连通分量：非连通图中的各个连通子图称为该图的连通分量。</p><h5 id="权"><a href="#权" class="headerlink" title="权"></a>权</h5><p>带权图如下：</p><p><img src="/2021/02/19/Java数据结构与算法/Java数据结构与算法概览/image-20210210110001284.png" alt="image-20210210110001284"></p><h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5><p>图的存储结构，常用的是<strong>邻接矩阵</strong>和<strong>邻接表</strong></p><h5 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h5><p>深度优先搜索（DFS）：递归实现；或者定义栈，使用非递归方法。</p><p>广度优先搜索（BFS）：队列实现，自动查找从一个顶点到另一个相邻顶点的最短路径。</p><h5 id="图的算法"><a href="#图的算法" class="headerlink" title="图的算法"></a>图的算法</h5><p>（1）最短路径问题：Dijkstra算法，算法的思路如下，Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。 然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点， 然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。</p><p>（2）拓扑排序：拓扑排序（Topological Sorting）是一个<strong>有向无环图</strong>（DAG, Directed Acyclic Graph）的所有顶点的线性序列。序列必须满足下面两个条件：一个是每个顶点出现且只出现一次，另一个是若存在一条从顶点A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</p><p>计算方法：</p><ul><li>从DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</li><li>从图中删除该顶点和所有以它为起点的有向边。</li><li>重复1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</li></ul><p>（3）最小生成树：</p><ul><li>Kruskal算法：此算法可以称为 “加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。</li><li>Prime算法：此算法可以称为 “加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点 s 开始，逐渐长大覆盖整个连通网的所有顶点。</li></ul><h5 id="现实应用"><a href="#现实应用" class="headerlink" title="现实应用"></a>现实应用</h5><p>（1）交通流量建模：顶点可以表示街道的十字路口，边表示街道。加权的边可以表示限速或者车道的数量。建模人员可以用这个系统来判断最佳路线及最有可能堵车的街道。</p><p>（2）运输系统：比如，航空公司可以用图来为其飞行系统建模。将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。加权的边可以看作从一个机场到另一个机场的航班成本，或两个机场之间的距离，这取决与建模的对象是什么。</p><p>（3）局域网、广域网等计算机网络</p><p>（4）消费市场：顶点可以用来表示供应商和消费者。</p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>定义：</p><p>（1）Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。</p><p>（2）所谓的Hash算法都是散列算法，把任意长度的输入，变换成固定长度的输出，该输出就是散列值.（如：MD5,SHA1,加解密算法等）</p><p>（3）简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><h5 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h5><p>Java中数据存储方式最底层的两种结构，一种是数组，另一种就是链表。而Hash表就是综合了这两种数据结构。</p><p>例如：HashTable,HashMap，哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。</p><h5 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h5><p>Hash很好的解决了单体应用情况下的数据查找和插入的速度问题。但是毕竟单体应用的储存空间是有限的，所有在分布式环境下，应运而生了一致性Hash算法。</p><p>用意和hashCode的用意一样，只不过它是取模放在不同的IP机器上而已。</p><p>一致性Hash需要注意的就是默认分配的桶比较多些，而当其中一台机器挂了，影响的面比较小一些。</p><p>需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。</p><h3 id="评定"><a href="#评定" class="headerlink" title="评定"></a>评定</h3><p>时间复杂度：算法的时间复杂度是指执行算法所需要的计算工作量。简单理解，算法在规模为n的情况下，一个算法语句执行的次数。</p><p>空间复杂度：算法的空间复杂度是指算法需要消耗的内存空间。简单理解，算法在规模为n的情况下额外消耗的存储空间。</p><h3 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h3><p>查找：顺序查找、二分查找、插值查找、</p><p>排序（八大排序算法）：直接插入排序（Insertion Sort）、希尔排序（Shell Sort）、选择排序（Selection Sort）、堆排序（Heap Sort）、冒泡排序（Bubble Sort）、快速排序（Quick Sort）、归并排序（Merging Sort）、基数排序（Radix Sort）</p><p>其它：分治法、贪心算法、动态规划算法、回溯法、分支限界法</p><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>对称加密算法、非对称加密算法、签名</p><p>常见算法：AES、RSA、CRC、MD5</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java数据结构与算法概览&quot;&gt;&lt;a href=&quot;#Java数据结构与算法概览&quot; class=&quot;headerlink&quot; title=&quot;Java数据结构与算法概览&quot;&gt;&lt;/a&gt;Java数据结构与算法概览&lt;/h1&gt;
    
    </summary>
    
      <category term="Java数据结构与算法" scheme="http://yoursite.com/categories/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法概览" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse的环境配置</title>
    <link href="http://yoursite.com/2021/02/09/%E6%9D%82/Eclipse%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2021/02/09/杂/Eclipse的环境配置/</id>
    <published>2021-02-09T12:11:20.000Z</published>
    <updated>2021-02-10T01:12:51.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Eclipse环境配置"><a href="#Eclipse环境配置" class="headerlink" title="Eclipse环境配置"></a>Eclipse环境配置</h1><a id="more"></a><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="1、修改Eclipse默认工作空间编码集，修改成UTF-8"><a href="#1、修改Eclipse默认工作空间编码集，修改成UTF-8" class="headerlink" title="1、修改Eclipse默认工作空间编码集，修改成UTF-8"></a>1、修改Eclipse默认工作空间编码集，修改成UTF-8</h3><p>路径： Window → Preferences →  General →  Workspace，修改编码集为 UTF-8。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209201308485.png" alt="image-20210209201308485"></p><h3 id="2、修改Eclipse的资源文件编码集，修改成UTF-8"><a href="#2、修改Eclipse的资源文件编码集，修改成UTF-8" class="headerlink" title="2、修改Eclipse的资源文件编码集，修改成UTF-8"></a>2、修改Eclipse的资源文件编码集，修改成UTF-8</h3><p>路径：Window → Preferences →  General →  Content Types，并点击打开Content Types：中的Text下面的Java Properties File。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209201547784.png" alt="image-20210209201547784"></p><h3 id="3、自动化格式所有行"><a href="#3、自动化格式所有行" class="headerlink" title="3、自动化格式所有行"></a>3、自动化格式所有行</h3><p>路径：Window → Preferences →  Java→  Editor  →  Save Actions。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209201742842.png" alt="image-20210209201742842"></p><h3 id="4、设置内容自动提示"><a href="#4、设置内容自动提示" class="headerlink" title="4、设置内容自动提示"></a>4、设置内容自动提示</h3><p>路径：Window → Preferences →  Java→  Editor  →  Content Assist。</p><p>在Auto activation triggers for java对应输入框中输入“.qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM”。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209201922362.png" alt="image-20210209201922362"></p><h3 id="5、修改默认浏览器"><a href="#5、修改默认浏览器" class="headerlink" title="5、修改默认浏览器"></a>5、修改默认浏览器</h3><p>路径：Window → Preferences →  General →  Web Browser。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202043441.png" alt="image-20210209202043441"></p><h3 id="6、Eclipse代码模板的构建"><a href="#6、Eclipse代码模板的构建" class="headerlink" title="6、Eclipse代码模板的构建"></a>6、Eclipse代码模板的构建</h3><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径：Window → Preferences →  Java→  Editor  →  Templates。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202209208.png" alt="image-20210209202209208"></p><p>  代码模板构建操作如下图：</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202251247.png" alt="image-20210209202251247"></p><h3 id="7、Eclipse配置类注释模板和方法注释模板"><a href="#7、Eclipse配置类注释模板和方法注释模板" class="headerlink" title="7、Eclipse配置类注释模板和方法注释模板"></a>7、Eclipse配置类注释模板和方法注释模板</h3><p>路径：Window → Preferences →  Java→ Code Style → Code Templates。</p><p>备注：</p><p>1、将光标放到类名上，按下快捷键 alt+shift+j 会添加类的注释。</p><p>2、将光标放到方法名上，按下快捷键 alt+shift+j 会添加方法的注释。</p><p>配置类的注释模板内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @版权 : Copyright (c) 2020-2021 *********公司技术开发部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 作者姓名(一般是写姓名的拼音)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@E</span>-mail: 邮箱</span></span><br><span class="line"><span class="comment"> * @版本: 1.0</span></span><br><span class="line"><span class="comment"> * @创建日期: $&#123;date&#125; $&#123;time&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> $&#123;type_name&#125;</span></span><br><span class="line"><span class="comment"> * @类描述-Description:  $&#123;todo&#125;(这里用一句话描述这个方法的作用)</span></span><br><span class="line"><span class="comment"> * @修改记录:</span></span><br><span class="line"><span class="comment"> * @版本: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>配置方法的注释模板内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: $&#123;enclosing_method&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $&#123;todo&#125;(这里用一句话描述这个方法的作用)</span></span><br><span class="line"><span class="comment"> * $&#123;tags&#125;    參數描述</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> $&#123;return_type&#125;  返回类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>操作如下图：</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202613197.png" alt="image-20210209202613197"></p><p>配置创建类时的注释模板：</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209202928859.png" alt="image-20210209202928859"></p><h3 id="8、Eclipse字体大小设置"><a href="#8、Eclipse字体大小设置" class="headerlink" title="8、Eclipse字体大小设置"></a>8、Eclipse字体大小设置</h3><p>路径：Window → Preferences →  General → Appearance → Colors and Fonts。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209203054240.png" alt="image-20210209203054240"></p><h2 id="环境配置保存"><a href="#环境配置保存" class="headerlink" title="环境配置保存"></a>环境配置保存</h2><p>右键点击Package Explorer，点击Export，导出Perferences。</p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209203629604.png" alt="image-20210209203629604"></p><p><img src="/2021/02/09/杂/Eclipse的环境配置/image-20210209203727742.png" alt="image-20210209203727742"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Eclipse环境配置&quot;&gt;&lt;a href=&quot;#Eclipse环境配置&quot; class=&quot;headerlink&quot; title=&quot;Eclipse环境配置&quot;&gt;&lt;/a&gt;Eclipse环境配置&lt;/h1&gt;
    
    </summary>
    
      <category term="杂" scheme="http://yoursite.com/categories/%E6%9D%82/"/>
    
    
      <category term="杂" scheme="http://yoursite.com/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>递归算法</title>
    <link href="http://yoursite.com/2021/02/09/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/02/09/Java数据结构与算法/递归算法/</id>
    <published>2021-02-09T03:26:25.000Z</published>
    <updated>2021-02-09T08:02:00.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><a id="more"></a><h2 id="尾递归的数学理解"><a href="#尾递归的数学理解" class="headerlink" title="尾递归的数学理解"></a>尾递归的数学理解</h2><p>示例：阶乘f(n) = n * f(n-1)</p><p>以计算f(5)为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f(5)</span><br><span class="line">=&gt;5 * f(4)</span><br><span class="line">=&gt;5 * (4 * f(3))</span><br><span class="line">=&gt;5 * (4 * (3 * f(2)))</span><br><span class="line">=&gt;5 * (4 * (3 * (2 * f(1))))</span><br><span class="line">&lt;=5 * (4 * (3 * (2 * 1))) </span><br><span class="line">&lt;=5 * (4 * (3 * 2)) </span><br><span class="line">&lt;=5 * (4 * 6) </span><br><span class="line">&lt;=5 * 24</span><br><span class="line">&lt;=120</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>备注：=&gt;是一个递进的过程，&lt;=是回归的过程，这就是尾递归的逻辑</span><br><span class="line"><span class="meta">#</span>递归是一个入栈出栈的过程</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归定义：程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有<strong>边界条件</strong>、<strong>递归前进段</strong>和<strong>递归返回段</strong>。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p><p>通俗来讲，递归是函数调用自身函数的一种现象，函数不断引用自身，直到引用对象已知。</p><p>递归三大要素为：<strong>递归前进段</strong>，<strong>边界条件</strong>，<strong>递归返回段</strong></p><p>递归可以总结以下三点：</p><p>（1）明确函数的功能，即需要解决什么样的问题。</p><p>（2）具备边界调节，否则一直递归下去。</p><p>（3）函数的等价关系，则可以理解如何前进，如何返回。</p><p>例如阶乘的函数等价关系为f(n) = n * f(n-1)，这种跟数学归纳法有点类似，但是递归是有限处理并得到最终结果，而数学归纳法是归纳一种现象，且可以无限延生。</p><p>优缺点：</p><p>（1）优点：思路清晰，代码简单；将复杂大问题分解为小问题解决。</p><p>（2）缺点：基于栈内存运气，占空间。</p><p>备注：明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节。千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。</p><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p>边界条件：当n为1的时候结束返回数值1</p><p>函数等价关系：f(n) = n * f(n-1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorialRecursion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 边界条件</span></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数等价关系</span></span><br><span class="line"><span class="keyword">return</span> n * factorialRecursion(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>问题描述：斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34….，即第一项 f(1) = 1,第二项 f(2) = 1…..,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。</p><p>边界条件：当n为1或者2的时候结束返回数值1</p><p>函数等价关系：f(n) = f(n-1) + f(n-2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacciRecursion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 边界条件</span></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数等价关系</span></span><br><span class="line"><span class="keyword">return</span> fibonacciRecursion(n - <span class="number">1</span>) + fibonacciRecursion(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上知乎的理解（侵删）：</p><p><img src="/2021/02/09/Java数据结构与算法/递归算法/image-20210209143340154.png" alt="image-20210209143340154"></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="循环与递归"><a href="#循环与递归" class="headerlink" title="循环与递归"></a>循环与递归</h4><p>循环是有去无回，而递归则是有去有回(因为存在终止条件)。</p><p>例如：</p><p>（1）你用你手中的钥匙打开一扇门，结果去发现前方还有一扇门，紧接着你又用钥匙打开了这扇门，然后你又看到一扇们…但是当你开到某扇门时，发现前方是一堵墙无路可走了，你选择原路返回——这就是递归。</p><p>（2）但是如果你打开一扇门后，同样发现前方也有一扇们，紧接着你又打开下一扇门…直到打开最后一扇门出去，或者一直没有碰到尽头 （死循环）——这就是循环。</p><h4 id="分治算法与递归"><a href="#分治算法与递归" class="headerlink" title="分治算法与递归"></a>分治算法与递归</h4><p>分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。</p><p>分治算法是用迭代的方法将每一次的过程不断重复，每次迭代的结果会作为下次迭代的初始值。分治算法典型案例为二分查找。</p><ul><li>递归能写的，迭代不一定能写。</li><li>迭代能写的，递归一定能完成。</li></ul><h4 id="回溯算法与递归"><a href="#回溯算法与递归" class="headerlink" title="回溯算法与递归"></a>回溯算法与递归</h4><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。</p><p><strong>回溯的思路</strong>基本如下：当前局面下，我们有若干种选择，所以我们对每一种选择进行尝试。如果发现某种选择违反了某些限定条件，此时 return；如果尝试某种选择到了最后，发现该选择是正确解，那么就将其加入到解集中。<br>在这种思想下，我们需要清晰的找出三个要素：<strong>选择 (Options)</strong>，<strong>限制 (Restraints)</strong>，<strong>结束条件 (Termination)</strong>。</p><p>用回溯算法解决问题的一般步骤为:<br>1、定义一个解空间，它包含问题的解。<br>2、利用适于搜索的方法组织解空间。<br>3、利用深度优先法搜索解空间。<br>4、利用限界函数避免移动到不可能产生解的子空间。<br>问题的解空间通常是在搜索问题的解的过程中动态产生的，这是回溯算法的一个重要特性。</p><p>例如探索迷宫问题。</p><p>回溯算法的基本框架如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><h5 id="回溯算法与递归的区别"><a href="#回溯算法与递归的区别" class="headerlink" title="回溯算法与递归的区别"></a>回溯算法与递归的区别</h5><p>递归是一种算法结构。递归会出现在子程序中，形式上表现为直接或间接的自己调用自己。典型的例子是阶乘，计算规律为：n!=n×(n−1)!<br>回溯是一种算法思想，它是用递归实现的。回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。例如有求和问题，给定有 7 个元素的组合 [1, 2, 3, 4, 5, 6, 7]，求加和为 7 的子集。累加计算中，选择 1+2+3+4 时，判断得到结果为 10 大于 7，那么后面的 5, 6, 7 就没有必要计算了。这种方法属于搜索过程中的优化，即“剪枝”功能。<br>用一个比较通俗的说法来解释递归和回溯：<br>我们在路上走着，前面是一个多岔路口，因为我们并不知道应该走哪条路，所以我们需要尝试。尝试的过程就是一个函数。<br>我们选择了一个方向，后来发现又有一个多岔路口，这时候又需要进行一次选择。所以我们需要在上一次尝试结果的基础上，再做一次尝试，即在函数内部再调用一次函数，这就是递归的过程。<br>这样重复了若干次之后，发现这次选择的这条路走不通，这时候我们知道我们上一个路口选错了，所以我们要回到上一个路口重新选择其他路，这就是回溯的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;递归算法&quot;&gt;&lt;a href=&quot;#递归算法&quot; class=&quot;headerlink&quot; title=&quot;递归算法&quot;&gt;&lt;/a&gt;递归算法&lt;/h1&gt;
    
    </summary>
    
      <category term="Java数据结构与算法" scheme="http://yoursite.com/categories/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归算法" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找算法</title>
    <link href="http://yoursite.com/2021/02/08/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/02/08/Java数据结构与算法/二分查找算法/</id>
    <published>2021-02-08T13:44:06.000Z</published>
    <updated>2021-02-09T09:43:54.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h1><a id="more"></a><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>定义：二分查找（binary search）算法又叫折半查找算法，是一种在<strong>有序数组</strong>中，查找某一特定元素的搜索算法。</p><p>使用条件：必须是有序。</p><p>大致流程：搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><p>算法复杂度分析：</p><table><thead><tr><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(logN)</td><td>O(1)</td></tr></tbody></table><p>解决方法：非递归方法、递归方法</p><h2 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化左右指针, [left, right]</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历</span></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line"><span class="comment">// (right + left) / 2</span></span><br><span class="line"><span class="comment">// 目的:防止溢出</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line"><span class="comment">// 返回该数值的位置</span></span><br><span class="line"><span class="keyword">return</span> mid;    </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line"><span class="comment">// 目标值在右边,移动左指针</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line"><span class="comment">// 目标值在左边,移动右指针</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// whild end</span></span><br><span class="line"><span class="comment">// 未找到这个值</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="comment">// binarySearch end</span></span><br></pre></td></tr></table></figure><p>需要注意一下几点：</p><p>1、为什么while循环的条件中是&lt;=，而不是&lt;？</p><p>回答：因为初始化 right 的赋值是 nums.length - 1 ，即最后⼀个元素的索引，⽽不是 nums.length。可以理解为每次搜索空间两端都为闭区间[left， right]；</p><p>while退出条件：</p><p>（1）当找到目标的时候，即mid索引的值等于target的值就返回索引。</p><p>（2）当没有该目标的时候，终止条件为left==right + 1。</p><p>例如数组[1,2,4]，开始查找left和right相邻且指向1、4两个值，我们需要查找的值为3。第一次查找没找到，mid索引为1，则移动左指针mid+1为2；此时跟右指针相等都指向4这个值，进行逻辑判断，此时目标值在该值的左边，则移动右指针mid-1；此时right索引为3，left索引为4，没找到该值，则退出循环返回-1。</p><p>语言描述不够形象，后续补上动图。</p><p>2、为什么要写成left = mid +1，right = mid -1。而不是left = mid，right = mid。</p><p>由于我们的<strong>搜索区间</strong>左右都是闭区间[left，right]，当我们发现mid不是需要找的target时，我们下一步则需要去找[left，mid-1]或者[mid+1，right]。当然我们也可以写成left = mid，right = mid的形式，则需要修改相应的代码。</p><p>3、算法缺陷</p><p>如果有序数组[1,2,2,2,3]，target为2，算法返回的索引是2，结果正确，但是如果我们想得到target的左边界或者右边界的索引（1或者3），这种方法无法处理。</p><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchRecursion</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="comment">// 目的:防止溢出</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line"><span class="comment">// 目标值在右边,向右递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearchRecursion(nums, mid + <span class="number">1</span>, right, target);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line"><span class="comment">// 目标值在左边,向左递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearchRecursion(nums, left, mid - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：判断条件left &lt;= right与left &lt; right的区别。</p><h2 id="二分查找使用场景及优缺点"><a href="#二分查找使用场景及优缺点" class="headerlink" title="二分查找使用场景及优缺点"></a>二分查找使用场景及优缺点</h2><p>二分查找的时间复杂度为O(logN)，具有非常高效的查找算法。除了二分查找，在堆、二叉树的操作时间复杂度也可以为O(logN)。</p><p><strong>优点</strong>：时间复杂度低，用来查找数据效率很高。</p><p><strong>局限性</strong>：</p><p>（1）依赖顺序表结构，例如数组支持的下标随机访问，如果为链表，查找索引的值得时间复杂度为O(N)。</p><p>（2）数据有序，无序数据需要在二分查找之前进行排序，所以二分查找不适合频繁插入删除操作的数据。</p><p>（3）数据量小不适合二分查找，时间复杂度O(logN)是指的时间开销趋势，如果数据量小，顺序遍历的查找跟二分查找速度基本相差不大。</p><p>（4）数据量大也不适合二分查找，由于二分查找底层依赖于数组这类数据结构，如果几个G以上的数据，用数组存储需要连续内存空间，这种是不符合实际的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二分查找算法&quot;&gt;&lt;a href=&quot;#二分查找算法&quot; class=&quot;headerlink&quot; title=&quot;二分查找算法&quot;&gt;&lt;/a&gt;二分查找算法&lt;/h1&gt;
    
    </summary>
    
      <category term="Java数据结构与算法" scheme="http://yoursite.com/categories/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找算法" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java抽象类和接口</title>
    <link href="http://yoursite.com/2021/02/08/Java/%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2021/02/08/Java/基础/深入理解Java抽象类和接口/</id>
    <published>2021-02-08T03:17:36.000Z</published>
    <updated>2021-02-09T01:21:33.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Java抽象类和接口"><a href="#深入理解Java抽象类和接口" class="headerlink" title="深入理解Java抽象类和接口"></a>深入理解Java抽象类和接口</h1><a id="more"></a><p>对于面向对象编程来说，抽象是它的一大特征之一。在Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。</p><h2 id="一、抽象类"><a href="#一、抽象类" class="headerlink" title="一、抽象类"></a>一、抽象类</h2><p>抽象类和抽象方法必须使用abstract关键字进行修饰。</p><p>使用方法：使用extends关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstractDoor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含抽象方法的类称为抽象类，除了定义抽象方法，其它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：</p><p>  1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</p><p>  2）抽象类可以理解成在普通类的基础上拓展定义抽象方法，提供一种模板，由于抽象类是“半成品”，所以不能用来创建对象，即不能被实例化；但可以通过向上转型实例化，参考代理模式。</p><p>  3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。若子类没有完全实现父类所有抽象方法，则该子类也必须定为抽象类。</p><p>  在其他方面，抽象类和普通的类并没有区别。</p><h2 id="二、接口"><a href="#二、接口" class="headerlink" title="二、接口"></a>二、接口</h2><p>接口泛指指供别人调用的方法或者函数，它是对行为的抽象。</p><p>使用方法：使用implements关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeHandle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dealHandle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterHandle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口可以含有变量和方法（且方法不能有具体实现），变量会被隐式地指定为public static final变量（只能是public static final变量，否则编译报错），方法会被隐式地指定为public abstract方法且只能是public abstract方法，即接口中的方法必须全为抽象方法。允许一个类遵循多个特定的接口。</p><ul><li>非抽象类遵循了某个接口，就必须实现该接口中的所有方法。</li><li>抽象类遵循了某个接口，可以不实现该接口中的抽象方法。</li></ul><h2 id="三、抽象类和接口的区别"><a href="#三、抽象类和接口的区别" class="headerlink" title="三、抽象类和接口的区别"></a>三、抽象类和接口的区别</h2><h3 id="1、语法层面的区别"><a href="#1、语法层面的区别" class="headerlink" title="1、语法层面的区别"></a>1、语法层面的区别</h3><p>1）方法：抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法<br>2）成员变量：抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的<br>3）静态代码块和静态方法：接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法<br>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><h3 id="2、设计层面的区别"><a href="#2、设计层面的区别" class="headerlink" title="2、设计层面的区别"></a>2、设计层面的区别</h3><p>1）抽象类是对一种事物的抽象、对类抽象，而接口是对行为的抽象。<strong>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象</strong>。</p><p>eg：例如，飞机和鸟都具有飞的属性，可以设计一个接口Fly，包含Fly()方法。如果有不同类别的战斗机，可以继承飞机抽象类。</p><p>总结：<strong>继承是一个“是不是”的关系，而接口是“有没有”的关系</strong>。如果一个类继承了一个抽象类，那么子类也是属于这个抽象类的一种。而接口只是约束行为（方法）。</p><p>2）抽象类可以作为很多子类的父类，它是一种模板式设计；而接口是一种行为规范，它是一种辐射式设计。</p><p>模板式设计：如果两个B、C子类继承C抽象类，B、C子类公共部分就是模板A，如果公共部分需要改动，只需要改动模板A了，不需要重新改动B、C子类。</p><p>辐射式设计：比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstractDoor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterfaceDoor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p><p>　　1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p><p>　　2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p><p>​    从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类衍生接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterfaceAlarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAlarmDoor</span> <span class="keyword">extends</span> <span class="title">TestAbstractDoor</span> <span class="keyword">implements</span> <span class="title">TestInterfaceAlarm</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深入理解Java抽象类和接口&quot;&gt;&lt;a href=&quot;#深入理解Java抽象类和接口&quot; class=&quot;headerlink&quot; title=&quot;深入理解Java抽象类和接口&quot;&gt;&lt;/a&gt;深入理解Java抽象类和接口&lt;/h1&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java面向对象" scheme="http://yoursite.com/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>UML类图的使用</title>
    <link href="http://yoursite.com/2021/02/07/%E6%9D%82/UML%E7%B1%BB%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2021/02/07/杂/UML类图的使用/</id>
    <published>2021-02-07T07:14:36.000Z</published>
    <updated>2021-02-07T07:15:20.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UML类图的使用"><a href="#UML类图的使用" class="headerlink" title="UML类图的使用"></a>UML类图的使用</h1><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>UML类图包含6种关系：继承关系、实现关系、依赖关系、关联关系、聚合关系、组合关系</p><h2 id="1、继承关系"><a href="#1、继承关系" class="headerlink" title="1、继承关系"></a>1、继承关系</h2><p>一个类（子类、子接口）继承另外一个类（称为父类、父接口）的功能，并可以增加自己新功能的能力。在Java继承关系中通过关键字<strong>extends</strong>标识。</p><p>图形表示：<strong>空心三角箭头，实线</strong>表示，从子类指向父类，或者子接口指向父接口；</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204163339948.png" alt="image-20210204163339948"></p><h3 id="2、实现关系"><a href="#2、实现关系" class="headerlink" title="2、实现关系"></a>2、实现关系</h3><p>一个Class类实现interface接口（可以多个）的功能，是类与接口之间的关系。在Java中实现关系通过<strong>implements</strong>明确标识。</p><p>图形表示：<strong>空心三角箭头，虚线</strong>表示。从类指向接口。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204163735026.png" alt="image-20210204163735026"></p><h3 id="3、依赖关系"><a href="#3、依赖关系" class="headerlink" title="3、依赖关系"></a>3、依赖关系</h3><p>依赖是一个类A使用到了另一个类B，关系较弱，偶尔调用另一对象或者临时调用，类B的改动会影响到类A。在代码层面为，类B作为参数被类A中的某个method方法中使用。</p><p>图形表示：<strong>箭头，虚线</strong>。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204172535428.png" alt="image-20210204172535428"></p><h3 id="4、关联关系"><a href="#4、关联关系" class="headerlink" title="4、关联关系"></a>4、关联关系</h3><p>关联体现两个类之间有强依赖关系，这种关系比依赖更强，不存在偶然性或者临时性，一般是长期性质的，并且两个类之间的关系是平等的。关联可以是单向、双向的，在代码层面，被关联类B以类的属性存在于关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。</p><p>图形表示：<strong>箭头，实线</strong>。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204173144804.png" alt="image-20210204173144804"></p><h3 id="5、聚合关系"><a href="#5、聚合关系" class="headerlink" title="5、聚合关系"></a>5、聚合关系</h3><p>聚合是关联关系的一种特例，体现整体与部分的关系，即has-a的关系。聚合关系整体与部分可以分离，可以跟组合关系做对比。</p><p>例如：家庭和孩子的关系，一个家庭里面可以没有孩子，可以有也可以没有。</p><p>图形表示：<strong>空心棱形，实线</strong>。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204173444209.png" alt="image-20210204173444209"></p><h3 id="6、组合关系"><a href="#6、组合关系" class="headerlink" title="6、组合关系"></a>6、组合关系</h3><p>组合是关联关系的一种特例，体现contains-a的关系，比聚合更强。整体与部分不可分。</p><p>例如：人和大脑的关系，人必须有大脑。</p><p>图形表示：<strong>实心棱形，实线</strong>。</p><p><img src="/2021/02/07/杂/UML类图的使用/image-20210204174510211.png" alt="image-20210204174510211"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UML类图的使用&quot;&gt;&lt;a href=&quot;#UML类图的使用&quot; class=&quot;headerlink&quot; title=&quot;UML类图的使用&quot;&gt;&lt;/a&gt;UML类图的使用&lt;/h1&gt;
    
    </summary>
    
      <category term="杂" scheme="http://yoursite.com/categories/%E6%9D%82/"/>
    
    
      <category term="UML" scheme="http://yoursite.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://yoursite.com/2021/02/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/02/05/设计模式/工厂模式/</id>
    <published>2021-02-05T12:45:12.000Z</published>
    <updated>2021-02-07T02:14:11.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><a id="more"></a><p>介绍简单工厂模式和工厂方法模式。</p><h2 id="1、简单工厂模式（静态工厂方法模式）"><a href="#1、简单工厂模式（静态工厂方法模式）" class="headerlink" title="1、简单工厂模式（静态工厂方法模式）"></a>1、简单工厂模式（静态工厂方法模式）</h2><p><strong>定义</strong>：简单工厂模式属于创建型模式，又被称为静态工厂方法模式，这是一个工厂对象决定创建出哪一种产品类的实例。</p><p><img src="/2021/02/05/设计模式/工厂模式/image-20210204213840439.png" alt="image-20210204213840439"></p><p>（1）抽象产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"><span class="comment">// 产品的抽象方法,由具体的产品类实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）具体产品类</p><p>继承抽象类，具体实现三种产品类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体产品类,联想计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"联想计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类,惠普计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"惠普计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类,华硕计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"华硕计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）工厂类</p><p>通过传入具体产品类别来实例化对应对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title">createComputer</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">Computer mComputer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"lenovo"</span>:</span><br><span class="line">mComputer = <span class="keyword">new</span> LenovoComputer();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"hp"</span>:</span><br><span class="line">mComputer = <span class="keyword">new</span> HpComputer();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"asus"</span>:</span><br><span class="line">mComputer = <span class="keyword">new</span> AsusComputer();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mComputer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）客户端调用工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端调用工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatComputer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ComputerFactory.createComputer(<span class="string">"hp"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单工厂模式优缺点</strong></p><p>优点：根据参数获取对应的类实例，避免类的直接实例化。</p><p>缺点：可实例化对象在编译期间就确定。如果需要新增加类型，则需要重新修改工厂类方法。简单工厂需要知道所有要生成的类型，当子类过多或者层次过多时候不宜使用。</p><h2 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h2><p><strong>定义</strong>：定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到子类。</p><p><img src="/2021/02/05/设计模式/工厂模式/image-20210204220304332.png" alt="image-20210204220304332"></p><p>（1）抽象产品类（同上、重复内容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"><span class="comment">// 产品的抽象方法,由具体的产品类实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）具体产品类（同上、重复内容）</p><p>继承抽象类，具体实现三种产品类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体产品类,联想计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"联想计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类,惠普计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"惠普计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类,华硕计算机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"华硕计算机启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）抽象工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Computer&gt; <span class="function">T <span class="title">createComputer</span><span class="params">(Class&lt;T&gt; clz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）具体工厂</p><p>具体工厂继承抽象工厂，通过反射来生产不同厂家的计算机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComputerFactor</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Computer&gt; <span class="function">T <span class="title">creatComputer</span><span class="params">(Class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">Computer computer = <span class="keyword">null</span>;</span><br><span class="line">String className = clz.getName();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 通过反射来实例化不同厂家的计算机</span></span><br><span class="line">computer = (Computer) Class.forName(className).newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T)computer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）客户端调用</p><p>通过反射和抽象工厂来实例化不同厂家计算机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 抽象工厂实例化</span></span><br><span class="line">ComputerFactory computerFactory = <span class="keyword">new</span> MyComputerFactor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射和抽象工厂来实例化不同厂家计算机</span></span><br><span class="line">LenovoComputer mLenovoComputer = computerFactory.createComputer(LenovoComputer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">mLenovoComputer.start();</span><br><span class="line"></span><br><span class="line">HpComputer mHpComputer = computerFactory.createComputer(HpComputer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">mHpComputer.start();</span><br><span class="line"></span><br><span class="line">AsusComputer mAsusComputer = computerFactory.createComputer(AsusComputer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">mAsusComputer.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工厂方法模式优缺点</strong></p><p>解决需求更改后不用修改工厂类，而是直接创建具体产品类，通过抽象工厂模式来实例化具体产品对象，解决了与具体产品的依赖，符合开放封闭原则。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h1&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="工厂模式" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客迁移记录</title>
    <link href="http://yoursite.com/2021/02/05/%E6%9D%82/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2021/02/05/杂/hexo博客迁移记录/</id>
    <published>2021-02-05T12:43:57.000Z</published>
    <updated>2021-02-07T02:14:11.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo博客迁移记录"><a href="#hexo博客迁移记录" class="headerlink" title="hexo博客迁移记录"></a>hexo博客迁移记录</h1><a id="more"></a><p>1、新建hexo分支</p><p>git checkout -b hexo</p><p>并将推送分支并merge到远程分支</p><p>git push origin hexo:hexo</p><p>2、删除hexo下面除了.git所有内容</p><p>3、将现有hexo目录拷贝到hexo分支下</p><p><img src="/2021/02/05/杂/hexo博客迁移记录/image-20210205105140194.png" alt="image-20210205105140194"></p><p>修改.gitgnore里的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><p>清除npm缓存</p><p>删除node_model文件夹，删除package.lock.json文件</p><p>npm cache clean –force</p><p>使用淘宝npm镜像</p><p>npm install cnpm -g –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><p>然后使用cnpm安装模块</p><p>cnpm install hexo</p><p>cnpm install</p><p>cnpm install hexo-deployer-git</p><p>hexo c &amp; hexo g &amp; hexo s</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hexo博客迁移记录&quot;&gt;&lt;a href=&quot;#hexo博客迁移记录&quot; class=&quot;headerlink&quot; title=&quot;hexo博客迁移记录&quot;&gt;&lt;/a&gt;hexo博客迁移记录&lt;/h1&gt;
    
    </summary>
    
      <category term="杂" scheme="http://yoursite.com/categories/%E6%9D%82/"/>
    
    
      <category term="杂" scheme="http://yoursite.com/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/02/04/设计模式/单例模式/</id>
    <published>2021-02-04T02:40:49.000Z</published>
    <updated>2021-02-07T02:14:11.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><a id="more"></a><p>定义：保证一个类只有一个实例，并提供访问它的全局访问点。</p><p><img src="/2021/02/04/设计模式/单例模式/image-20210204091623224.png" alt="image-20210204091623224"></p><p>Client为客户端，Singleton为单例类，通过调用getInstance()方法获取实例对象</p><p>以下介绍单例模式的6种写法，其中第一种静态内部类单例模式是常用方法，后面5种介绍其他方法，并分析其优缺点。</p><h2 id="6种写法"><a href="#6种写法" class="headerlink" title="6种写法"></a>6种写法</h2><h3 id="1、静态内部类单例模式"><a href="#1、静态内部类单例模式" class="headerlink" title="1、静态内部类单例模式"></a>1、静态内部类单例模式</h3><p>静态内部类单例模式是推荐使用方法，在第一次加载Singleton类不会初始化sInstance，只有第一次调用getInstance()方法时JVM虚拟机加载SingletonHolder内部类并初始化sInstance。</p><p>优点：既能保证线程安全，也能保证Singleton的唯一性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHolder.sInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、枚举单例"><a href="#2、枚举单例" class="headerlink" title="2、枚举单例"></a>2、枚举单例</h3><p>默认枚举实例是线程安全的，并且在任何情况都是单例模式。普通类在反序列化的时候，会重新创建对象。由于枚举枚举默认继承Enum类，在枚举类中禁用了readObject方法，不会因为序列化的时候破坏单例，并且在反序列化的时候不会去重新创建对象。</p><p>优点：杜绝在反序列化的时候重新创建对象。</p><p>确定：使用较少，可读性不高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义枚举单例</span></span><br><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举单例方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、饿汉模式"><a href="#3、饿汉模式" class="headerlink" title="3、饿汉模式"></a>3、饿汉模式</h3><p>优点：基于类加载机制，避免多线程问题；获取对象较快。</p><p>缺点：在类加载时进行初始化，加载较慢；如果从未获取该实例，造成内存浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、懒汉模式（线程不安全）"><a href="#4、懒汉模式（线程不安全）" class="headerlink" title="4、懒汉模式（线程不安全）"></a>4、懒汉模式（线程不安全）</h3><p>在内部声明静态变量，只在调用的时候做初始化；</p><p>缺点：多线程不能正常工作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、懒汉模式（线程安全）"><a href="#5、懒汉模式（线程安全）" class="headerlink" title="5、懒汉模式（线程安全）"></a>5、懒汉模式（线程安全）</h3><p>将获取实例方法变成同步块方法，保证线程安全。</p><p>缺点：每次调用都需要同步，造成不必要的同步开销；（不建议使用该方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、双重检查模式（DCL）"><a href="#6、双重检查模式（DCL）" class="headerlink" title="6、双重检查模式（DCL）"></a>6、双重检查模式（DCL）</h3><p>在获取实例方法中进行两次判空，第一次是避免不必要的同步，第二次是判断Singleton类为空时创建实例。</p><p>优点：资源利用率高，解决资源消耗、多余同步、线程安全问题；</p><p>缺点：在某些情况会出现失效的问题，也就是DCL失效；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式参考书籍和设计思想</title>
    <link href="http://yoursite.com/2021/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2021/02/04/设计模式/设计模式参考书籍和设计思想/</id>
    <published>2021-02-04T02:20:42.000Z</published>
    <updated>2021-02-07T02:14:11.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式参考书籍和设计思想"><a href="#设计模式参考书籍和设计思想" class="headerlink" title="设计模式参考书籍和设计思想"></a>设计模式参考书籍和设计思想</h1><a id="more"></a><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h3><p>单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、迪米特原则、接口隔离原则</p><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p><strong>定义</strong>：一个类，应该有一个引起它变化的原因</p><p>松耦合，一个类只做一个事情。</p><h4 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h4><p><strong>定义</strong>：类、模块、函数等都应该是可拓展，但不可修改</p><p>一个对于拓展是开放的，一个对于修改是封闭的。传统方法，需求变化需要将类重新修改一遍；模式方法，如果需求更改，通过拓展的方式实现，而不是修改原有代码；</p><p>开放封闭原则解决方法：增加一个抽象的功能类，让添加、删除和查询等作为这个抽象类的子类。</p><p><strong>目的</strong>：如果新增功能，无须修改原有类，只需要添加一个功能类的子类实现原有功能类的方法就行了。</p><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p><strong>定义</strong>：所有引用基类（父类）的地方必须能透明地使用其子类的对象</p><p>在程序中将基类对象替换为子类对象，程序正常；反之，子类对象不一定能够使用基类对象；</p><p>由于使用基类对象的地方都可以使用子类对象，因此，在程序中尽量使用基类类型来进行对象定义，而在运行的时候再确定其子类的类型，用子类对象来替换父类对象。（向下转型？）</p><p>尽量将基类设计为抽象类或者接口，让子类继承父类实现父接口，并实现父类声明方法。</p><p><strong>目的</strong>：运行时，子类示例替换父类实例，可以方便拓展系统功能，同时无须修改原有子类代码；增加新功能可以通过增加一个新的子类来实现。</p><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p><strong>定义</strong>：高层模块不应该依赖底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><p>抽象：接口类或者抽象类；细节：实现类；高层模块：调用端；底层模块：具体实现类；</p><p>目的：模块之间依赖通过抽象发生，实现类不产生直接依赖关系，依赖关系通过接口或者抽象类产生；如果实现类与实现类直接依赖细节，则产生耦合关系。其目的也是为了松耦合。</p><h4 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h4><p><strong>定义</strong>：一个软件实体尽可能少于其它实体发生相互作用。</p><p>如果模块修改，尽可能少影响其它模块。如果其中一个对象需要调用另一个对象的方法，可以通过第三者转发这个调用。</p><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p><strong>定义</strong>：一个类对另一个类的依赖尽可能建立在最小接口上。</p><p>建立单一接口，不要建立庞大的臃肿的接口；尽可能细化接口，接口中方法尽量少。也就是为各个类建立专用的接口。</p><h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p>GoF提出23种</p><h4 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h4><p>单例模式</p><p>工厂方法模式</p><p>抽象工厂模式</p><p>创建者模式</p><p>原型模式</p><h4 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h4><p>设配器模式</p><p>装饰模式</p><p>代理模式</p><p>外观模式</p><p>桥接模式</p><p>组合模式</p><p>享元模式</p><h4 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h4><p>策略模式</p><p>模板方法模式</p><p>观察者模式</p><p>迭代器模式</p><p>责任链模式</p><p>命令模式</p><p>备忘录模式</p><p>状态模式</p><p>访问者模式</p><p>中介模式</p><p>解释器模式</p><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><p>《Android进阶之光》    刘望舒</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计模式参考书籍和设计思想&quot;&gt;&lt;a href=&quot;#设计模式参考书籍和设计思想&quot; class=&quot;headerlink&quot; title=&quot;设计模式参考书籍和设计思想&quot;&gt;&lt;/a&gt;设计模式参考书籍和设计思想&lt;/h1&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计思想" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/12/12/%E6%9D%82/hello-world/"/>
    <id>http://yoursite.com/2020/12/12/杂/hello-world/</id>
    <published>2020-12-12T12:43:57.000Z</published>
    <updated>2021-02-07T02:14:11.080Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my Blog.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my Blog.&lt;/p&gt;
    
    </summary>
    
      <category term="杂" scheme="http://yoursite.com/categories/%E6%9D%82/"/>
    
    
      <category term="杂" scheme="http://yoursite.com/tags/%E6%9D%82/"/>
    
  </entry>
  
</feed>
