---
title: 二分查找算法
categories: 
  - Java数据结构与算法
tags:
  - 二分查找算法
about: 无
date: 2021-02-08 21:44:06
---

# 二分查找算法

<!--more-->

## 简述

定义：二分查找（binary search）算法又叫折半查找算法，是一种在**有序数组**中，查找某一特定元素的搜索算法。

使用条件：必须是有序。

大致流程：搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。

算法复杂度分析：

| 时间复杂度 | 空间复杂度 |
| ---------- | ---------- |
| O(logN)    | O(1)       |

解决方法：非递归方法、递归方法



## 非递归方法

代码如下：

```java
public static int binarySearch(int[] nums, int target) {
	// 初始化左右指针, [left, right]
	int left = 0;
	int right = nums.length - 1;
		
	// 循环遍历
	while(left <= right) {
		// (right + left) / 2
		// 目的:防止溢出
		int mid = left + (right - left) / 2;
			
		if (nums[mid] == target) {
			// 返回该数值的位置
			return mid;    
		} else if (nums[mid] < target) {
			// 目标值在右边,移动左指针
			left = mid + 1;
		} else if (nums[mid] > target) {
			// 目标值在左边,移动右指针
			right = mid - 1;
		}
	}  // whild end
	// 未找到这个值
	return -1;
} // binarySearch end
```

需要注意一下几点：

1、为什么while循环的条件中是<=，而不是<？

回答：因为初始化 right 的赋值是 nums.length - 1 ，即最后⼀个元素的索引，⽽不是 nums.length。可以理解为每次搜索空间两端都为闭区间[left， right]；

while退出条件：

（1）当找到目标的时候，即mid索引的值等于target的值就返回索引。

（2）当没有该目标的时候，终止条件为left==right + 1。

例如数组[1,2,4]，开始查找left和right相邻且指向1、4两个值，我们需要查找的值为3。第一次查找没找到，mid索引为1，则移动左指针mid+1为2；此时跟右指针相等都指向4这个值，进行逻辑判断，此时目标值在该值的左边，则移动右指针mid-1；此时right索引为3，left索引为4，没找到该值，则退出循环返回-1。

语言描述不够形象，后续补上动图。

2、为什么要写成left = mid +1，right = mid -1。而不是left = mid，right = mid。

由于我们的**搜索区间**左右都是闭区间[left，right]，当我们发现mid不是需要找的target时，我们下一步则需要去找[left，mid-1]或者[mid+1，right]。当然我们也可以写成left = mid，right = mid的形式，则需要修改相应的代码。

3、算法缺陷

如果有序数组[1,2,2,2,3]，target为2，算法返回的索引是2，结果正确，但是如果我们想得到target的左边界或者右边界的索引（1或者3），这种方法无法处理。





## 递归方法



代码如下：