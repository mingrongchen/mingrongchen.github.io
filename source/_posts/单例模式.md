---
title: 单例模式
categories: 
  - 设计模式
tags:
  - 单例模式
about: 无
date: 2021-02-04 10:40:49
---

## 单例模式

<!--more-->

定义：保证一个类只有一个实例，并提供访问它的全局访问点。

![image-20210204091623224](单例模式/image-20210204091623224.png)

Client为客户端，Singleton为单例类，通过调用getInstance()方法获取实例对象

以下介绍单例模式的6种写法，其中第一种静态内部类单例模式是常用方法，后面5种介绍其他方法，并分析其优缺点。

### 6种写法

#### 1、静态内部类单例模式

静态内部类单例模式是推荐使用方法，在第一次加载Singleton类不会初始化sInstance，只有第一次调用getInstance()方法时JVM虚拟机加载SingletonHolder内部类并初始化sInstance。

优点：既能保证线程安全，也能保证Singleton的唯一性。

```java
public class Singleton {
	private Singleton() {
	}
	
	// 获取实例方法
	public static Singleton getInstance() {
		return SingletonHolder.sInstance;
	}
	
	// 静态内部类
	private static class SingletonHolder {
		private static final Singleton sInstance = new Singleton();
	}
}
```



#### 2、枚举单例

默认枚举实例是线程安全的，并且在任何情况都是单例模式。普通类在反序列化的时候，会重新创建对象。由于枚举枚举默认继承Enum类，在枚举类中禁用了readObject方法，不会因为序列化的时候破坏单例，并且在反序列化的时候不会去重新创建对象。

优点：杜绝在反序列化的时候重新创建对象。

确定：使用较少，可读性不高。

```java
// 定义枚举单例
enum Singleton {
	INSTANCE;
	public void dosomething() {
		
	}
}

// 使用枚举单例方法
private Object readResolve() throws ObjectStreamException {
	return Singleton;
}
```



#### 3、饿汉模式

优点：基于类加载机制，避免多线程问题；获取对象较快。

缺点：在类加载时进行初始化，加载较慢；如果从未获取该实例，造成内存浪费。

```java
public class Singleton {
	private static Singleton instance = new Singleton();
	private Singleton() {
		
	}
    
	// 获取实例方法
	public static Singleton getInstance() {
		return instance;
	}
}
```



#### 4、懒汉模式（线程不安全）

在内部声明静态变量，只在调用的时候做初始化；

缺点：多线程不能正常工作；

```java
public class Singleton {
	private static Singleton instance;
	private Singleton() {
		
	}
    
	// 获取实例方法
	public static Singleton getInstance() {
		if (instance == null) {
			instance = new Singleton();
		}
		
		return instance;
	}
}
```



#### 5、懒汉模式（线程安全）

将获取实例方法变成同步块方法，保证线程安全。

缺点：每次调用都需要同步，造成不必要的同步开销；（不建议使用该方式）

```java
class Singleton {
	private static Singleton instance;
	private Singleton() {
		
	}
	
    // 获取实例方法
	public static synchronized Singleton getInstance() {
		if (instance == null) {
			instance = new Singleton();
		}
		
		return instance;
	}
}
```



#### 6、双重检查模式（DCL）

在获取实例方法中进行两次判空，第一次是避免不必要的同步，第二次是判断Singleton类为空时创建实例。

优点：资源利用率高，解决资源消耗、多余同步、线程安全问题；

缺点：在某些情况会出现失效的问题，也就是DCL失效；

```java
class Singleton {
	private static Singleton instance;
	private Singleton() {
		
	}
	
    // 获取实例方法
	public static Singleton getInstance() {
		if (instance == null) {
			
			synchronized (Singleton.class) {
				if (instance == null) {
					instance = new Singleton();
				}
			}
		}
		
		return instance;
	}

```
